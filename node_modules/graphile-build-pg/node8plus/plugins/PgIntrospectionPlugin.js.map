{"version":3,"sources":["../../src/plugins/PgIntrospectionPlugin.js"],"names":["debug","WATCH_FIXTURES_PATH","__dirname","readFile","filename","encoding","Promise","resolve","reject","err","res","removeQuotes","str","trimmed","trim","length","Error","substr","toLowerCase","parseSqlColumn","array","parts","split","parsedParts","map","parseConstraintSpec","rawSpec","spec","tagComponents","parsed","join","tags","description","text","smartCommentConstraints","introspectionResults","attributesByNames","tbl","cols","debugStr","attributes","attribute","filter","a","classId","id","sort","b","num","pk","constraint","find","c","type","keyAttributeNums","n","namespaceName","name","colName","attr","class","forEach","klass","namespace","namespaceId","primaryKey","pkSpec","columns","notNull","fakeConstraint","kind","isFake","Math","random","foreignClassId","comment","foreignKeyAttributeNums","push","foreignKey","foreignKeys","Array","isArray","fkSpecRaw","index","fkSpec","matches","match","rawColumns","rawSchemaOrTable","rawTableOnly","rawForeignColumns","rawSchema","rawTable","foreignSchema","foreignTable","foreignColumns","foreignKlass","k","foreignNamespace","PgIntrospectionPlugin","builder","pgConfig","pgSchemas","schemas","pgEnableTags","persistentMemoizeWithKey","key","fn","pgThrowOnMissingSchema","pgIncludeExtensionResources","pgLegacyFunctionsOnly","pgSkipInstallingWatchFixtures","pgAugmentIntrospectionResults","pgOwnerConnectionString","augment","introspect","cacheKey","version","cloneResults","obj","result","Object","keys","reduce","memo","v","assign","introspectionResultsByKind","pgClient","versionResult","query","serverVersionNum","parseInt","rows","server_version_num","introspectionQuery","__pgVersion","procedure","extension","object","extensionConfigurationClassIds","e","configurationClassIds","isExtensionConfigurationTable","indexOf","freeze","knownSchemas","missingSchemas","s","errorMessage","console","warn","xByY","arrayOfX","attrKey","x","xByYAndZ","attrKey2","namespaceById","classById","typeById","attributeByClassIdAndNum","extensionById","relate","newAttr","lookupAttr","lookup","missingOk","entry","innerKey","JSON","stringify","_","arrayItemType","arrayType","canUseAsterisk","some","columnLevelSelectGrant","constraints","foreignConstraints","primaryKeyConstraint","keyAttributes","nr","foreignClass","foreignKeyAttributes","attributeNums","isIndexed","isUnique","every","idx","releasePgClient","listener","stopListening","catch","removeListener","registerWatcher","triggerRebuild","pg","Pool","connect","release","Client","on","end","watchSqlInner","sql","error","chalk","bold","yellow","handleChange","leading","trailing","notification","channel","payload","parse","commands","schema","command","affectsOurSchemas","schemaName","hook","build","pgQueryFromResolveData","supportsJSONB","extend","pgIntrospectionResultsByKind"],"mappings":";;;;;;AAEA;;;;AACA;;AACA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AAEA;;AACA;;;;;;AAEA,MAAMA,QAAQ,qBAAa,mBAAb,CAAd;AACA,MAAMC,sBAAuB,GAAEC,SAAU,+BAAzC;;AAEA;;AAmLA,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,QAA5B,EAAsC;AACpC,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,sBAAYJ,QAAZ,EAAsBC,QAAtB,EAAgC,CAACI,GAAD,EAAMC,GAAN,KAAc;AAC5C,UAAID,GAAJ,EAASD,OAAOC,GAAP,EAAT,KACKF,QAAQG,GAAR;AACN,KAHD;AAID,GALM,CAAP;AAMD;;AAED,MAAMC,eAAeC,OAAO;AAC1B,QAAMC,UAAUD,IAAIE,IAAJ,EAAhB;AACA,MAAID,QAAQ,CAAR,MAAe,GAAnB,EAAwB;AACtB,QAAIA,QAAQA,QAAQE,MAAR,GAAiB,CAAzB,MAAgC,GAApC,EAAyC;AACvC,YAAM,IAAIC,KAAJ,CACH,2CAA0CJ,GAAI,yGAD3C,CAAN;AAGD;AACD,WAAOC,QAAQI,MAAR,CAAe,CAAf,EAAkBJ,QAAQE,MAAR,GAAiB,CAAnC,CAAP;AACD,GAPD,MAOO;AACL;AACA,WAAOF,QAAQK,WAAR,EAAP;AACD;AACF,CAbD;;AAeA,MAAMC,iBAAiB,CAACP,GAAD,EAAMQ,QAAQ,KAAd,KAAwB;AAC7C,MAAI,CAACR,GAAL,EAAU;AACR,UAAM,IAAII,KAAJ,CAAW,iBAAgBJ,GAAI,GAA/B,CAAN;AACD;AACD,QAAMS,QAAQD,QAAQR,IAAIU,KAAJ,CAAU,GAAV,CAAR,GAAyB,CAACV,GAAD,CAAvC;AACA,QAAMW,cAAcF,MAAMG,GAAN,CAAUb,YAAV,CAApB;AACA,SAAOS,QAAQG,WAAR,GAAsBA,YAAY,CAAZ,CAA7B;AACD,CAPD;;AASA,SAASE,mBAAT,CAA6BC,OAA7B,EAAsC;AACpC,QAAM,CAACC,IAAD,EAAO,GAAGC,aAAV,IAA2BF,QAAQJ,KAAR,CAAc,IAAd,CAAjC;AACA,QAAMO,SAAS,sBAAUD,cAAcE,IAAd,CAAmB,IAAnB,CAAV,CAAf;AACA,SAAO;AACLH,QADK;AAELI,UAAMF,OAAOE,IAFR;AAGLC,iBAAaH,OAAOI;AAHf,GAAP;AAKD;;AAED,SAASC,uBAAT,CAAiCC,oBAAjC,EAAuD;AACrD,QAAMC,oBAAoB,CAACC,GAAD,EAAMC,IAAN,EAAYC,QAAZ,KAAyB;AACjD,UAAMC,aAAaL,qBAAqBM,SAArB,CAChBC,MADgB,CACTC,KAAKA,EAAEC,OAAF,KAAcP,IAAIQ,EADd,EAEhBC,IAFgB,CAEX,CAACH,CAAD,EAAII,CAAJ,KAAUJ,EAAEK,GAAF,GAAQD,EAAEC,GAFT,CAAnB;AAGA,QAAI,CAACV,IAAL,EAAW;AACT,YAAMW,KAAKd,qBAAqBe,UAArB,CAAgCC,IAAhC,CACTC,KAAKA,EAAER,OAAF,IAAaP,IAAIQ,EAAjB,IAAuBO,EAAEC,IAAF,KAAW,GAD9B,CAAX;AAGA,UAAIJ,EAAJ,EAAQ;AACN,eAAOA,GAAGK,gBAAH,CAAoB9B,GAApB,CAAwB+B,KAAKf,WAAWW,IAAX,CAAgBR,KAAKA,EAAEK,GAAF,KAAUO,CAA/B,CAA7B,CAAP;AACD,OAFD,MAEO;AACL,cAAM,IAAIvC,KAAJ,CACH,6BAA4BqB,IAAImB,aAAc,IAAGnB,IAAIoB,IAAK,WACzDpB,IAAIQ,EACL,sBAAqBN,QAAS,IAH3B,CAAN;AAKD;AACF;AACD,WAAOD,KAAKd,GAAL,CAASkC,WAAW;AACzB,YAAMC,OAAOnB,WAAWW,IAAX,CAAgBR,KAAKA,EAAEc,IAAF,KAAWC,OAAhC,CAAb;AACA,UAAI,CAACC,IAAL,EAAW;AACT,cAAM,IAAI3C,KAAJ,CACH,6BAA4B0C,OAAQ,SAAQrB,IAAImB,aAAc,IAC7DnB,IAAIoB,IACL,GAHG,CAAN;AAKD;AACD,aAAOE,IAAP;AACD,KAVM,CAAP;AAWD,GA7BD;;AA+BA;AACAxB,uBAAqByB,KAArB,CAA2BC,OAA3B,CAAmCC,SAAS;AAC1C,UAAMC,YAAY5B,qBAAqB4B,SAArB,CAA+BZ,IAA/B,CAChBI,KAAKA,EAAEV,EAAF,KAASiB,MAAME,WADJ,CAAlB;AAGA,QAAI,CAACD,SAAL,EAAgB;AACd;AACD;AACD,QAAID,MAAM/B,IAAN,CAAWkC,UAAf,EAA2B;AACzB,UAAI,OAAOH,MAAM/B,IAAN,CAAWkC,UAAlB,KAAiC,QAArC,EAA+C;AAC7C,cAAM,IAAIjD,KAAJ,CACH,iCAAgC8C,MAAMN,aAAc,IACnDM,MAAML,IACP,gEAHG,CAAN;AAKD;AACD,YAAM,EAAE9B,MAAMuC,MAAR,EAAgBnC,IAAhB,EAAsBC,WAAtB,KAAsCP,oBAC1CqC,MAAM/B,IAAN,CAAWkC,UAD+B,CAA5C;AAGA;AACA,YAAME,UAAoBhD,eAAe+C,MAAf,EAAuB,IAAvB,CAA1B;AACA,YAAM1B,aAAaJ,kBACjB0B,KADiB,EAEjBK,OAFiB,EAGhB,eAAcL,MAAM/B,IAAN,CAAWkC,UAAW,EAHpB,CAAnB;AAKAzB,iBAAWqB,OAAX,CAAmBF,QAAQ;AACzBA,aAAK5B,IAAL,CAAUqC,OAAV,GAAoB,IAApB;AACD,OAFD;AAGA,YAAMd,mBAAmBd,WAAWhB,GAAX,CAAemB,KAAKA,EAAEK,GAAtB,CAAzB;AACA;AACA,YAAMqB,iBAAiB;AACrBC,cAAM,YADe;AAErBC,gBAAQ,IAFa;AAGrB1B,YAAI2B,KAAKC,MAAL,EAHiB;AAIrBhB,cAAO,QAAOK,MAAMN,aAAc,IAAGM,MAAML,IAAK,aAJ3B;AAKrBJ,cAAM,GALe,EAKV;AACXT,iBAASkB,MAAMjB,EANM;AAOrB6B,wBAAgB,IAPK;AAQrBC,iBAAS,IARY;AASrB3C,mBATqB;AAUrBsB,wBAVqB;AAWrBsB,iCAAyB,IAXJ;AAYrB7C;AAZqB,OAAvB;AAcAI,2BAAqBe,UAArB,CAAgC2B,IAAhC,CAAqCR,cAArC;AACD;AACF,GA9CD;AA+CA;AACAlC,uBAAqByB,KAArB,CAA2BC,OAA3B,CAAmCC,SAAS;AAC1C,UAAMC,YAAY5B,qBAAqB4B,SAArB,CAA+BZ,IAA/B,CAChBI,KAAKA,EAAEV,EAAF,KAASiB,MAAME,WADJ,CAAlB;AAGA,QAAI,CAACD,SAAL,EAAgB;AACd;AACD;AACD,QAAID,MAAM/B,IAAN,CAAW+C,UAAf,EAA2B;AACzB,YAAMC,cACJ,OAAOjB,MAAM/B,IAAN,CAAW+C,UAAlB,KAAiC,QAAjC,GACI,CAAChB,MAAM/B,IAAN,CAAW+C,UAAZ,CADJ,GAEIhB,MAAM/B,IAAN,CAAW+C,UAHjB;AAIA,UAAI,CAACE,MAAMC,OAAN,CAAcF,WAAd,CAAL,EAAiC;AAC/B,cAAM,IAAI/D,KAAJ,CACH,mDACC8C,MAAMN,aACP,IAAGM,MAAML,IAAK,GAHX,CAAN;AAKD;AACDsB,kBAAYlB,OAAZ,CAAoB,CAACqB,SAAD,EAAYC,KAAZ,KAAsB;AACxC,YAAI,OAAOD,SAAP,KAAqB,QAAzB,EAAmC;AACjC,gBAAM,IAAIlE,KAAJ,CACH,6BAA4BmE,KAAM,SAAQrB,MAAMN,aAAc,IAC7DM,MAAML,IACP,GAHG,CAAN;AAKD;AACD,cAAM,EAAE9B,MAAMyD,MAAR,EAAgBrD,IAAhB,EAAsBC,WAAtB,KAAsCP,oBAC1CyD,SAD0C,CAA5C;AAGA,cAAMG,UAAUD,OAAOE,KAAP,CACd,0EADc,CAAhB;AAGA,YAAI,CAACD,OAAL,EAAc;AACZ,gBAAM,IAAIrE,KAAJ,CACH,kCAAiC8C,MAAMN,aAAc,IACpDM,MAAML,IACP,0FAAyFyB,SAAU,GAHhG,CAAN;AAKD;AACD,cAAM,GAEJK,UAFI,EAGJC,gBAHI,EAIJC,YAJI,EAKJC,iBALI,IAMFL,OANJ;AAOA,cAAMM,YAAYF,eACdD,gBADc,GAEb,IAAG1B,MAAMN,aAAc,GAF5B;AAGA,cAAMoC,WAAWH,gBAAgBD,gBAAjC;AACA;AACA,cAAMrB,UAAoBhD,eAAeoE,UAAf,EAA2B,IAA3B,CAA1B;AACA;AACA,cAAMM,gBAAwB1E,eAAewE,SAAf,CAA9B;AACA;AACA,cAAMG,eAAuB3E,eAAeyE,QAAf,CAA7B;AACA;AACA,cAAMG,iBAA2BL,oBAC7BvE,eAAeuE,iBAAf,EAAkC,IAAlC,CAD6B,GAE7B,IAFJ;;AAIA,cAAMM,eAAe7D,qBAAqByB,KAArB,CAA2BT,IAA3B,CACnB8C,KAAKA,EAAExC,IAAF,KAAWqC,YAAX,IAA2BG,EAAEzC,aAAF,KAAoBqC,aADjC,CAArB;AAGA,YAAI,CAACG,YAAL,EAAmB;AACjB,gBAAM,IAAIhF,KAAJ,CACH,iEAAgE6E,aAAc,MAAKC,YAAa,4FAA2FZ,SAAU,GADlM,CAAN;AAGD;AACD,cAAMgB,mBAAmB/D,qBAAqB4B,SAArB,CAA+BZ,IAA/B,CACvBI,KAAKA,EAAEV,EAAF,KAASmD,aAAahC,WADJ,CAAzB;AAGA,YAAI,CAACkC,gBAAL,EAAuB;AACrB;AACD;;AAED,cAAM5C,mBAAmBlB,kBACvB0B,KADuB,EAEvBK,OAFuB,EAGtB,eAAce,SAAU,EAHF,EAIvB1D,GAJuB,CAInBmB,KAAKA,EAAEK,GAJY,CAAzB;AAKA,cAAM4B,0BAA0BxC,kBAC9B4D,YAD8B,EAE9BD,cAF8B,EAG7B,eAAcb,SAAU,EAHK,EAI9B1D,GAJ8B,CAI1BmB,KAAKA,EAAEK,GAJmB,CAAhC;;AAMA;AACA,cAAMqB,iBAAiB;AACrBC,gBAAM,YADe;AAErBC,kBAAQ,IAFa;AAGrB1B,cAAI2B,KAAKC,MAAL,EAHiB;AAIrBhB,gBAAO,QAAOK,MAAMN,aAAc,IAAGM,MAAML,IAAK,eAAc0B,KAAM,EAJ/C;AAKrB9B,gBAAM,GALe,EAKV;AACXT,mBAASkB,MAAMjB,EANM;AAOrB6B,0BAAgBsB,aAAanD,EAPR;AAQrB8B,mBAAS,IARY;AASrB3C,qBATqB;AAUrBsB,0BAVqB;AAWrBsB,iCAXqB;AAYrB7C;AAZqB,SAAvB;AAcAI,6BAAqBe,UAArB,CAAgC2B,IAAhC,CAAqCR,cAArC;AACD,OArFD;AAsFD;AACF,GA1GD;AA2GD;;kBAEe,eAAe8B,qBAAf,CACdC,OADc,EAEd;AACEC,UADF;AAEEC,aAAWC,OAFb;AAGEC,cAHF;AAIEC,6BAA2B,CAACC,GAAD,EAAMC,EAAN,KAAaA,IAJ1C;AAKEC,2BAAyB,KAL3B;AAMEC,gCAA8B,KANhC;AAOEC,0BAAwB,KAP1B;AAQEC,kCAAgC,KARlC;AASEC,+BATF;AAUEC;AAVF,CAFc,EAcd;AACA,QAAMC,UAAU/E,wBAAwB;AACtC,KAAC6E,6BAAD,EAAgC9E,uBAAhC,EAAyD2B,OAAzD,CACE8C,MAAOA,KAAKA,GAAGxE,oBAAH,CAAL,GAAgC,IADzC;AAGD,GAJD;AAKA,iBAAegF,UAAf,GAA4B;AAC1B;AACA,QAAI,CAACnC,MAAMC,OAAN,CAAcsB,OAAd,CAAL,EAA6B;AAC3B,YAAM,IAAIvF,KAAJ,CAAU,wCAAV,CAAN;AACD;AACD,UAAMoG,WAAY,qDAAoDC,gBAAQ,EAA9E;AACA,UAAMC,eAAeC,OAAO;AAC1B,YAAMC,SAASC,OAAOC,IAAP,CAAYH,GAAZ,EAAiBI,MAAjB,CAAwB,CAACC,IAAD,EAAO3B,CAAP,KAAa;AAClD2B,aAAK3B,CAAL,IAAUjB,MAAMC,OAAN,CAAcsC,IAAItB,CAAJ,CAAd,IACNsB,IAAItB,CAAJ,EAAOzE,GAAP,CAAWqG,KAAKJ,OAAOK,MAAP,CAAc,EAAd,EAAkBD,CAAlB,CAAhB,CADM,GAENN,IAAItB,CAAJ,CAFJ;AAGA,eAAO2B,IAAP;AACD,OALc,EAKZ,EALY,CAAf;AAMA,aAAOJ,MAAP;AACD,KARD;AASA,UAAMO,6BAA6BT,cACjC,MAAMb,yBAAyBW,QAAzB,EAAmC,MACvC,4BAAaf,QAAb,EAAuB,MAAM2B,QAAN,IAAkB;AACvC,YAAMC,gBAAgB,MAAMD,SAASE,KAAT,CAC1B,0BAD0B,CAA5B;AAGA,YAAMC,mBAAmBC,SACvBH,cAAcI,IAAd,CAAmB,CAAnB,EAAsBC,kBADC,EAEvB,EAFuB,CAAzB;AAIA,YAAMC,qBAAqB,gDAAuBJ,gBAAvB,EAAyC;AAClErB;AADkE,OAAzC,CAA3B;AAGA,YAAM,EAAEuB,IAAF,KAAW,MAAML,SAASE,KAAT,CAAeK,kBAAf,EAAmC,CACxDhC,OADwD,EAExDM,2BAFwD,CAAnC,CAAvB;;AAKA,YAAMW,SAAS;AACbgB,qBAAaL,gBADA;AAEbpE,mBAAW,EAFE;AAGbH,eAAO,EAHM;AAIbnB,mBAAW,EAJE;AAKbY,cAAM,EALO;AAMbH,oBAAY,EANC;AAObuF,mBAAW,EAPE;AAQbC,mBAAW,EARE;AASbvD,eAAO;AATM,OAAf;AAWA,WAAK,MAAM,EAAEwD,MAAF,EAAX,IAAyBN,IAAzB,EAA+B;AAC7Bb,eAAOmB,OAAOrE,IAAd,EAAoBO,IAApB,CAAyB8D,MAAzB;AACD;;AAED;AACA,OACE,WADF,EAEE,OAFF,EAGE,WAHF,EAIE,MAJF,EAKE,YALF,EAME,WANF,EAOE,WAPF,EAQE,OARF,EASE9E,OATF,CASUS,QAAQ;AAChBkD,eAAOlD,IAAP,EAAaT,OAAb,CAAqB8E,UAAU;AAC7B;AACAA,iBAAOhE,OAAP,GAAiBgE,OAAO3G,WAAxB;AACA,cAAIwE,gBAAgBmC,OAAO3G,WAA3B,EAAwC;AACtC,kBAAMH,SAAS,sBAAU8G,OAAO3G,WAAjB,CAAf;AACA2G,mBAAO5G,IAAP,GAAcF,OAAOE,IAArB;AACA4G,mBAAO3G,WAAP,GAAqBH,OAAOI,IAA5B;AACD,WAJD,MAIO;AACL0G,mBAAO5G,IAAP,GAAc,EAAd;AACD;AACF,SAVD;AAWD,OArBD;;AAuBA,YAAM6G,iCAAiC,uBACrCpB,OAAOkB,SAD8B,EAErCG,KAAKA,EAAEC,qBAF8B,CAAvC;AAIAtB,aAAO5D,KAAP,CAAaC,OAAb,CAAqBC,SAAS;AAC5BA,cAAMiF,6BAAN,GACEH,+BAA+BI,OAA/B,CAAuClF,MAAMjB,EAA7C,KAAoD,CADtD;AAED,OAHD;;AAKA,OACE,WADF,EAEE,OAFF,EAGE,WAHF,EAIE,MAJF,EAKE,YALF,EAME,WANF,EAOE,WAPF,EAQE,OARF,EASEgB,OATF,CASUoC,KAAK;AACbuB,eAAOvB,CAAP,EAAUpC,OAAV,CAAkB4D,OAAOwB,MAAzB;AACD,OAXD;;AAaA,aAAOxB,OAAOwB,MAAP,CAAczB,MAAd,CAAP;AACD,KA9ED,CADI,CAD2B,EAAnC;;AAoFA,UAAM0B,eAAenB,2BAA2BhE,SAA3B,CAAqCvC,GAArC,CAAyC+B,KAAKA,EAAEE,IAAhD,CAArB;AACA,UAAM0F,iBAAiB5C,QAAQ7D,MAAR,CAAe0G,KAAKF,aAAaF,OAAb,CAAqBI,CAArB,IAA0B,CAA9C,CAAvB;AACA,QAAID,eAAepI,MAAnB,EAA2B;AACzB,YAAMsI,eAAgB,gCAA+B9C,QAAQzE,IAAR,CACnD,MADmD,CAEnD,oEAAmEqH,eAAerH,IAAf,CACnE,MADmE,CAEnE,GAJF;AAKA,UAAI8E,sBAAJ,EAA4B;AAC1B,cAAM,IAAI5F,KAAJ,CAAUqI,YAAV,CAAN;AACD,OAFD,MAEO;AACLC,gBAAQC,IAAR,CAAa,mBAAmBF,YAAhC,EADK,CAC0C;AAChD;AACF;;AAED,UAAMG,OAAO,CAACC,QAAD,EAAWC,OAAX,KACXD,SAAS9B,MAAT,CAAgB,CAACC,IAAD,EAAO+B,CAAP,KAAa;AAC3B/B,WAAK+B,EAAED,OAAF,CAAL,IAAmBC,CAAnB;AACA,aAAO/B,IAAP;AACD,KAHD,EAGG,EAHH,CADF;AAKA,UAAMgC,WAAW,CAACH,QAAD,EAAWC,OAAX,EAAoBG,QAApB,KACfJ,SAAS9B,MAAT,CAAgB,CAACC,IAAD,EAAO+B,CAAP,KAAa;AAC3B,UAAI,CAAC/B,KAAK+B,EAAED,OAAF,CAAL,CAAL,EAAuB9B,KAAK+B,EAAED,OAAF,CAAL,IAAmB,EAAnB;AACvB9B,WAAK+B,EAAED,OAAF,CAAL,EAAiBC,EAAEE,QAAF,CAAjB,IAAgCF,CAAhC;AACA,aAAO/B,IAAP;AACD,KAJD,EAIG,EAJH,CADF;AAMAG,+BAA2B+B,aAA3B,GAA2CN,KACzCzB,2BAA2BhE,SADc,EAEzC,IAFyC,CAA3C;AAIAgE,+BAA2BgC,SAA3B,GAAuCP,KACrCzB,2BAA2BnE,KADU,EAErC,IAFqC,CAAvC;AAIAmE,+BAA2BiC,QAA3B,GAAsCR,KACpCzB,2BAA2B1E,IADS,EAEpC,IAFoC,CAAtC;AAIA0E,+BAA2BkC,wBAA3B,GAAsDL,SACpD7B,2BAA2BtF,SADyB,EAEpD,SAFoD,EAGpD,KAHoD,CAAtD;AAKAsF,+BAA2BmC,aAA3B,GAA2CV,KACzCzB,2BAA2BW,SADc,EAEzC,IAFyC,CAA3C;;AAKA,UAAMyB,SAAS,CAAC/I,KAAD,EAAQgJ,OAAR,EAAiBC,UAAjB,EAA6BC,MAA7B,EAAqCC,YAAY,KAAjD,KAA2D;AACxEnJ,YAAMyC,OAAN,CAAc2G,SAAS;AACrB,cAAM9D,MAAM8D,MAAMH,UAAN,CAAZ;AACA,YAAIrF,MAAMC,OAAN,CAAcyB,GAAd,CAAJ,EAAwB;AACtB8D,gBAAMJ,OAAN,IAAiB1D,IACdlF,GADc,CACViJ,YAAY;AACf,kBAAMjD,SAAS8C,OAAOG,QAAP,CAAf;AACA,gBAAIA,YAAY,CAACjD,MAAjB,EAAyB;AACvB,kBAAI+C,SAAJ,EAAe;AACb;AACD;AACD,oBAAM,IAAIvJ,KAAJ,CACH,sBAAqBoJ,OAAQ,SAAQC,UAAW,OAAMI,QAAS,UAASC,KAAKC,SAAL,CACvEH,KADuE,CAEvE,GAHE,CAAN;AAKD;AACD,mBAAOhD,MAAP;AACD,WAdc,EAed9E,MAfc,CAePkI,KAAKA,CAfE,CAAjB;AAgBD,SAjBD,MAiBO;AACL,gBAAMpD,SAAS8C,OAAO5D,GAAP,CAAf;AACA,cAAIA,OAAO,CAACc,MAAZ,EAAoB;AAClB,gBAAI+C,SAAJ,EAAe;AACb;AACD;AACD,kBAAM,IAAIvJ,KAAJ,CACH,sBAAqBoJ,OAAQ,SAAQC,UAAW,SAAQK,KAAKC,SAAL,CACvDH,KADuD,CAEvD,GAHE,CAAN;AAKD;AACDA,gBAAMJ,OAAN,IAAiB5C,MAAjB;AACD;AACF,OAjCD;AAkCD,KAnCD;;AAqCAN,YAAQa,0BAAR;;AAEAoC,WACEpC,2BAA2BnE,KAD7B,EAEE,WAFF,EAGE,aAHF,EAIEmE,2BAA2B+B,aAJ7B,EAKE,IALF,CAKO;AALP;;AAQAK,WACEpC,2BAA2BnE,KAD7B,EAEE,MAFF,EAGE,QAHF,EAIEmE,2BAA2BiC,QAJ7B;;AAOAG,WACEpC,2BAA2BtF,SAD7B,EAEE,OAFF,EAGE,SAHF,EAIEsF,2BAA2BgC,SAJ7B;;AAOAI,WACEpC,2BAA2BtF,SAD7B,EAEE,MAFF,EAGE,QAHF,EAIEsF,2BAA2BiC,QAJ7B;;AAOAG,WACEpC,2BAA2BU,SAD7B,EAEE,WAFF,EAGE,aAHF,EAIEV,2BAA2B+B,aAJ7B;;AAOAK,WACEpC,2BAA2B1E,IAD7B,EAEE,OAFF,EAGE,SAHF,EAIE0E,2BAA2BgC,SAJ7B,EAKE,IALF;;AAQAI,WACEpC,2BAA2B1E,IAD7B,EAEE,gBAFF,EAGE,kBAHF,EAIE0E,2BAA2BiC,QAJ7B,EAKE,IALF,CAKO;AALP;;AAQAG,WACEpC,2BAA2B1E,IAD7B,EAEE,eAFF,EAGE,iBAHF,EAIE0E,2BAA2BiC,QAJ7B,EAKE,IALF,CAKO;AALP;;AAQAG,WACEpC,2BAA2B7E,UAD7B,EAEE,OAFF,EAGE,SAHF,EAIE6E,2BAA2BgC,SAJ7B;;AAOAI,WACEpC,2BAA2B7E,UAD7B,EAEE,cAFF,EAGE,gBAHF,EAIE6E,2BAA2BgC,SAJ7B,EAKE,IALF,CAKO;AALP;;AAQAI,WACEpC,2BAA2BW,SAD7B,EAEE,WAFF,EAGE,aAHF,EAIEX,2BAA2B+B,aAJ7B,EAKE,IALF,CAKO;AALP;;AAQAK,WACEpC,2BAA2BW,SAD7B,EAEE,sBAFF,EAGE,uBAHF,EAIEX,2BAA2BgC,SAJ7B,EAKE,IALF,CAKO;AALP;;AAQAI,WACEpC,2BAA2B5C,KAD7B,EAEE,OAFF,EAGE,SAHF,EAIE4C,2BAA2BgC,SAJ7B;;AAOA;AACAhC,+BAA2B1E,IAA3B,CAAgCQ,OAAhC,CAAwCR,QAAQ;AAC9C,UAAIA,KAAKwH,aAAT,EAAwB;AACtBxH,aAAKwH,aAAL,CAAmBC,SAAnB,GAA+BzH,IAA/B;AACD;AACF,KAJD;;AAMA;AACA0E,+BAA2BnE,KAA3B,CAAiCC,OAAjC,CAAyCC,SAAS;AAChDA,YAAMtB,UAAN,GAAmBuF,2BAA2BtF,SAA3B,CAAqCC,MAArC,CACjBiB,QAAQA,KAAKf,OAAL,KAAiBkB,MAAMjB,EADd,CAAnB;AAGAiB,YAAMiH,cAAN,GAAuB,CAACjH,MAAMtB,UAAN,CAAiBwI,IAAjB,CACtBrH,QAAQA,KAAKsH,sBADS,CAAxB;AAGAnH,YAAMoH,WAAN,GAAoBnD,2BAA2B7E,UAA3B,CAAsCR,MAAtC,CAClBQ,cAAcA,WAAWN,OAAX,KAAuBkB,MAAMjB,EADzB,CAApB;AAGAiB,YAAMqH,kBAAN,GAA2BpD,2BAA2B7E,UAA3B,CAAsCR,MAAtC,CACzBQ,cAAcA,WAAWwB,cAAX,KAA8BZ,MAAMjB,EADzB,CAA3B;AAGAiB,YAAMsH,oBAAN,GAA6BtH,MAAMoH,WAAN,CAAkB/H,IAAlB,CAC3BD,cAAcA,WAAWG,IAAX,KAAoB,GADP,CAA7B;AAGD,KAhBD;;AAkBA;AACA0E,+BAA2B7E,UAA3B,CAAsCW,OAAtC,CAA8CX,cAAc;AAC1D,UAAIA,WAAWI,gBAAX,IAA+BJ,WAAWU,KAA9C,EAAqD;AACnDV,mBAAWmI,aAAX,GAA2BnI,WAAWI,gBAAX,CAA4B9B,GAA5B,CAAgC8J,MACzDpI,WAAWU,KAAX,CAAiBpB,UAAjB,CAA4BW,IAA5B,CAAiCQ,QAAQA,KAAKX,GAAL,KAAasI,EAAtD,CADyB,CAA3B;AAGD,OAJD,MAIO;AACLpI,mBAAWmI,aAAX,GAA2B,EAA3B;AACD;AACD,UAAInI,WAAW0B,uBAAX,IAAsC1B,WAAWqI,YAArD,EAAmE;AACjErI,mBAAWsI,oBAAX,GAAkCtI,WAAW0B,uBAAX,CAAmCpD,GAAnC,CAChC8J,MAAMpI,WAAWqI,YAAX,CAAwB/I,UAAxB,CAAmCW,IAAnC,CAAwCQ,QAAQA,KAAKX,GAAL,KAAasI,EAA7D,CAD0B,CAAlC;AAGD,OAJD,MAIO;AACLpI,mBAAWsI,oBAAX,GAAkC,EAAlC;AACD;AACF,KAfD;;AAiBA;AACAzD,+BAA2B5C,KAA3B,CAAiCtB,OAAjC,CAAyCsB,SAAS;AAChD,YAAMhB,UAAUgB,MAAMsG,aAAN,CAAoBjK,GAApB,CAAwB8J,MACtCnG,MAAMvB,KAAN,CAAYpB,UAAZ,CAAuBW,IAAvB,CAA4BQ,QAAQA,KAAKX,GAAL,KAAasI,EAAjD,CADc,CAAhB;;AAIA;AACA,UAAInH,QAAQ,CAAR,CAAJ,EAAgB;AACdA,gBAAQ,CAAR,EAAWuH,SAAX,GAAuB,IAAvB;AACD;;AAED,UAAIvH,QAAQ,CAAR,KAAcA,QAAQpD,MAAR,KAAmB,CAAjC,IAAsCoE,MAAMwG,QAAhD,EAA0D;AACxDxH,gBAAQ,CAAR,EAAWwH,QAAX,GAAsB,IAAtB;AACD;;AAED;AACAxG,YAAMvB,KAAN,CAAYsH,WAAZ,CACGxI,MADH,CACUQ,cAAcA,WAAWG,IAAX,KAAoB,GAD5C,EAEGQ,OAFH,CAEWX,cAAc;AACrB,YACEA,WAAWI,gBAAX,CAA4BsI,KAA5B,CACE,CAACN,EAAD,EAAKO,GAAL,KAAa1G,MAAMsG,aAAN,CAAoBI,GAApB,MAA6BP,EAD5C,CADF,EAIE;AACApI,qBAAWwI,SAAX,GAAuB,IAAvB;AACD;AACF,OAVH;AAWD,KA1BD;;AA4BA,WAAO3D,0BAAP;AACD;;AAED,MAAIA,6BAA6B,MAAMZ,YAAvC;;AAEA,MAAIa,QAAJ,EAAc8D,eAAd,EAA+BC,QAA/B;;AAEA,WAASC,aAAT,GAAyB;AACvB,QAAIhE,QAAJ,EAAc;AACZA,eAASE,KAAT,CAAe,6BAAf,EAA8C+D,KAA9C,CAAoDpD,KAAK;AACvD7I,cAAO,4CAA2C6I,CAAE,EAApD;AACD,OAFD;AAGAb,eAASkE,cAAT,CAAwB,cAAxB,EAAwCH,QAAxC;AACD;AACD,QAAID,eAAJ,EAAqB;AACnBA;AACA9D,iBAAW,IAAX;AACD;AACF;;AAED5B,UAAQ+F,eAAR,CAAwB,MAAMC,cAAN,IAAwB;AAC9C;AACA,UAAMJ,eAAN;;AAEA;AACA,QAAI3F,oBAAoBgG,aAAGC,IAAvB,IAA+B,oCAAiBjG,QAAjB,CAAnC,EAA+D;AAC7D2B,iBAAW,MAAM3B,SAASkG,OAAT,EAAjB;AACAT,wBAAkB,MAAM9D,YAAYA,SAASwE,OAAT,EAApC;AACD,KAHD,MAGO,IAAI,OAAOnG,QAAP,KAAoB,QAAxB,EAAkC;AACvC2B,iBAAW,IAAIqE,aAAGI,MAAP,CAAcpG,QAAd,CAAX;AACA2B,eAAS0E,EAAT,CAAY,OAAZ,EAAqB7D,KAAK;AACxB7I,cAAM,6BAAN,EAAqC6I,CAArC;AACD,OAFD;AAGAiD,wBAAkB,MAChB,IAAIxL,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/B,YAAIwH,QAAJ,EAAcA,SAAS2E,GAAT,CAAalM,OAAQA,MAAMD,OAAOC,GAAP,CAAN,GAAoBF,SAAzC,EAAd,KACKA;AACN,OAHD,CADF;AAKA,YAAM,IAAID,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrC,YAAIwH,QAAJ,EAAc;AACZA,mBAASuE,OAAT,CAAiB9L,OAAQA,MAAMD,OAAOC,GAAP,CAAN,GAAoBF,SAA7C;AACD,SAFD,MAEO;AACLA;AACD;AACF,OANK,CAAN;AAOD,KAjBM,MAiBA;AACL,YAAM,IAAIS,KAAJ,CACJ,wEADI,CAAN;AAGD;AACD;AACA,QAAI,CAAC+F,6BAAL,EAAoC;AAClC,YAAM6F,gBAAgB,MAAMzM,SAASF,mBAAT,EAA8B,MAA9B,CAA5B;AACA,YAAM4M,MAAO,UAASD,aAAc,WAApC;AACA,UAAI;AACF,cAAM,4BAAa3F,2BAA2BZ,QAAxC,EAAkD2B,YACtDA,SAASE,KAAT,CAAe2E,GAAf,CADI,CAAN;AAGD,OAJD,CAIE,OAAOC,KAAP,EAAc;AACd;AACAxD,gBAAQC,IAAR,CACG,GAAEwD,gBAAMC,IAAN,CAAWC,MAAX,CACD,qDADC,CAED,OAHJ;AAKA3D,gBAAQC,IAAR,CACEwD,gBAAME,MAAN,CACE,sEADF,CADF;AAKA3D,gBAAQC,IAAR,CACEwD,gBAAME,MAAN,CACE,iEADF,CADF;AAKA3D,gBAAQC,IAAR,CACEwD,gBAAME,MAAN,CAAa,mDAAb,CADF;AAGAjN,cAAM8M,KAAN;AACA;AACA,cAAM9E,SAASE,KAAT,CAAe,UAAf,CAAN;AACD;AACF;;AAED,UAAMF,SAASE,KAAT,CAAe,2BAAf,CAAN;;AAEA,UAAMgF,eAAe,wBACnB,YAAY;AACVlN,YAAO,iDAAP;AACA+H,mCAA6B,MAAMZ,YAAnC;AACAnH,YAAO,uDAAP;AACAoM;AACD,KANkB,EAOnB,GAPmB,EAQnB;AACEe,eAAS,IADX;AAEEC,gBAAU;AAFZ,KARmB,CAArB;;AAcArB,eAAW,MAAMsB,YAAN,IAAsB;AAC/B,UAAIA,aAAaC,OAAb,KAAyB,oBAA7B,EAAmD;AACjD;AACD;AACD,UAAI;AACF,cAAMC,UAAU7C,KAAK8C,KAAL,CAAWH,aAAaE,OAAxB,CAAhB;AACAA,gBAAQA,OAAR,GAAkBA,QAAQA,OAAR,IAAmB,EAArC;AACA,YAAIA,QAAQlK,IAAR,KAAiB,KAArB,EAA4B;AAC1B,gBAAMoK,WAAWF,QAAQA,OAAR,CACd7K,MADc,CAEb,CAAC,EAAEgL,MAAF,EAAD,KAAgBA,UAAU,IAAV,IAAkBnH,QAAQyC,OAAR,CAAgB0E,MAAhB,KAA2B,CAFhD,EAIdlM,GAJc,CAIV,CAAC,EAAEmM,OAAF,EAAD,KAAiBA,OAJP,CAAjB;AAKA,cAAIF,SAAS1M,MAAb,EAAqB;AACnBmM;AACD;AACF,SATD,MASO,IAAIK,QAAQlK,IAAR,KAAiB,MAArB,EAA6B;AAClC,gBAAMuK,oBAAoBL,QAAQA,OAAR,CAAgBvC,IAAhB,CACxB6C,cAActH,QAAQyC,OAAR,CAAgB6E,UAAhB,KAA+B,CADrB,CAA1B;AAGA,cAAID,iBAAJ,EAAuB;AACrBV;AACD;AACF,SAPM,MAOA;AACL,gBAAM,IAAIlM,KAAJ,CAAW,iBAAgBuM,QAAQlK,IAAK,kBAAxC,CAAN;AACD;AACF,OAtBD,CAsBE,OAAOwF,CAAP,EAAU;AACV7I,cAAO,gDAA+C6I,CAAE,EAAxD;AACD;AACF,KA7BD;AA8BAb,aAAS0E,EAAT,CAAY,cAAZ,EAA4BX,QAA5B;AACAhE,iCAA6B,MAAMZ,YAAnC;AACD,GAhHD,EAgHG6E,aAhHH;;AAkHA5F,UAAQ0H,IAAR,CACE,OADF,EAEEC,SAAS;AACP,QAAIhG,2BAA2BS,WAA3B,GAAyC,KAA7C,EAAoD;AAClD;AACA;AACA;AACA;AACAuF,YAAMC,sBAAN,GAA+B,2CAA4B;AACzDC,uBAAe;AAD0C,OAA5B,CAA/B;AAGD;AACD,WAAOF,MAAMG,MAAN,CAAaH,KAAb,EAAoB;AACzBI,oCAA8BpG;AADL,KAApB,CAAP;AAGD,GAfH,EAgBE,CAAC,iBAAD,CAhBF,EAiBE,EAjBF,EAkBE,CAAC,UAAD,CAlBF;AAoBD,C","file":"PgIntrospectionPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport withPgClient, { quacksLikePgPool } from \"../withPgClient\";\nimport { parseTags } from \"../utils\";\nimport { readFile as rawReadFile } from \"fs\";\nimport pg from \"pg\";\nimport debugFactory from \"debug\";\nimport chalk from \"chalk\";\nimport throttle from \"lodash/throttle\";\nimport flatMap from \"lodash/flatMap\";\nimport { makeIntrospectionQuery } from \"./introspectionQuery\";\n\nimport { version } from \"../../package.json\";\nimport queryFromResolveDataFactory from \"../queryFromResolveDataFactory\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\nconst WATCH_FIXTURES_PATH = `${__dirname}/../../res/watch-fixtures.sql`;\n\n// Ref: https://github.com/graphile/postgraphile/tree/master/src/postgres/introspection/object\n\nexport type PgNamespace = {\n  kind: \"namespace\",\n  id: string,\n  name: string,\n  comment: ?string,\n  description: ?string,\n  tags: { [string]: string },\n};\n\nexport type PgProc = {\n  kind: \"procedure\",\n  id: string,\n  name: string,\n  comment: ?string,\n  description: ?string,\n  namespaceId: string,\n  namespaceName: string,\n  isStrict: boolean,\n  returnsSet: boolean,\n  isStable: boolean,\n  returnTypeId: string,\n  argTypeIds: Array<string>,\n  argNames: Array<string>,\n  argModes: Array<\"i\" | \"o\" | \"b\" | \"v\" | \"t\">,\n  inputArgsCount: number,\n  argDefaultsNum: number,\n  namespace: PgNamespace,\n  tags: { [string]: string },\n  cost: number,\n  aclExecutable: boolean,\n  language: string,\n};\n\nexport type PgClass = {\n  kind: \"class\",\n  id: string,\n  name: string,\n  comment: ?string,\n  description: ?string,\n  classKind: string,\n  namespaceId: string,\n  namespaceName: string,\n  typeId: string,\n  isSelectable: boolean,\n  isInsertable: boolean,\n  isUpdatable: boolean,\n  isDeletable: boolean,\n  isExtensionConfigurationTable: boolean,\n  namespace: PgNamespace,\n  type: PgType,\n  tags: { [string]: string },\n  attributes: [PgAttribute],\n  constraints: [PgConstraint],\n  foreignConstraints: [PgConstraint],\n  primaryKeyConstraint: ?PgConstraint,\n  aclSelectable: boolean,\n  aclInsertable: boolean,\n  aclUpdatable: boolean,\n  aclDeletable: boolean,\n  canUseAsterisk: boolean,\n};\n\nexport type PgType = {\n  kind: \"type\",\n  id: string,\n  name: string,\n  comment: ?string,\n  description: ?string,\n  namespaceId: string,\n  namespaceName: string,\n  type: string,\n  category: string,\n  domainIsNotNull: boolean,\n  arrayItemTypeId: ?string,\n  arrayItemType: ?PgType,\n  arrayType: ?PgType,\n  typeLength: ?number,\n  isPgArray: boolean,\n  classId: ?string,\n  domainBaseTypeId: ?string,\n  domainTypeModifier: ?number,\n  tags: { [string]: string },\n};\n\nexport type PgAttribute = {\n  kind: \"attribute\",\n  classId: string,\n  num: number,\n  name: string,\n  comment: ?string,\n  description: ?string,\n  typeId: string,\n  typeModifier: number,\n  isNotNull: boolean,\n  hasDefault: boolean,\n  identity: \"\" | \"a\" | \"d\",\n  class: PgClass,\n  type: PgType,\n  namespace: PgNamespace,\n  tags: { [string]: string },\n  aclSelectable: boolean,\n  aclInsertable: boolean,\n  aclUpdatable: boolean,\n  isIndexed: ?boolean,\n  isUnique: ?boolean,\n  columnLevelSelectGrant: boolean,\n};\n\nexport type PgConstraint = {\n  kind: \"constraint\",\n  id: string,\n  name: string,\n  type: string,\n  classId: string,\n  class: PgClass,\n  foreignClassId: ?string,\n  foreignClass: ?PgClass,\n  comment: ?string,\n  description: ?string,\n  keyAttributeNums: Array<number>,\n  keyAttributes: [PgAttribute],\n  foreignKeyAttributeNums: Array<number>,\n  foreignKeyAttributes: [PgAttribute],\n  namespace: PgNamespace,\n  isIndexed: ?boolean,\n  tags: { [string]: string },\n};\n\nexport type PgExtension = {\n  kind: \"extension\",\n  id: string,\n  name: string,\n  namespaceId: string,\n  namespaceName: string,\n  relocatable: boolean,\n  version: string,\n  configurationClassIds?: Array<string>,\n  comment: ?string,\n  description: ?string,\n  tags: { [string]: string },\n};\n\nexport type PgIndex = {\n  kind: \"index\",\n  id: string,\n  name: string,\n  namespaceName: string,\n  classId: string,\n  numberOfAttributes: number,\n  indexType: string,\n  isUnique: boolean,\n  isPrimary: boolean,\n  /*\n  Though these exist, we don't want to officially\n  support them yet.\n\n  isImmediate: boolean,\n  isReplicaIdentity: boolean,\n  isValid: boolean,\n  */\n  attributeNums: Array<number>,\n  attributePropertiesAsc: ?Array<boolean>,\n  attributePropertiesNullsFirst: ?Array<boolean>,\n  description: ?string,\n  tags: { [string]: string },\n};\n\nexport type PgEntity =\n  | PgNamespace\n  | PgProc\n  | PgClass\n  | PgType\n  | PgAttribute\n  | PgConstraint\n  | PgExtension\n  | PgIndex;\n\nfunction readFile(filename, encoding) {\n  return new Promise((resolve, reject) => {\n    rawReadFile(filename, encoding, (err, res) => {\n      if (err) reject(err);\n      else resolve(res);\n    });\n  });\n}\n\nconst removeQuotes = str => {\n  const trimmed = str.trim();\n  if (trimmed[0] === '\"') {\n    if (trimmed[trimmed.length - 1] !== '\"') {\n      throw new Error(\n        `We failed to parse a quoted identifier '${str}'. Please avoid putting quotes or commas in smart comment identifiers (or file a PR to fix the parser).`\n      );\n    }\n    return trimmed.substr(1, trimmed.length - 2);\n  } else {\n    // PostgreSQL lower-cases unquoted columns, so we should too.\n    return trimmed.toLowerCase();\n  }\n};\n\nconst parseSqlColumn = (str, array = false) => {\n  if (!str) {\n    throw new Error(`Cannot parse '${str}'`);\n  }\n  const parts = array ? str.split(\",\") : [str];\n  const parsedParts = parts.map(removeQuotes);\n  return array ? parsedParts : parsedParts[0];\n};\n\nfunction parseConstraintSpec(rawSpec) {\n  const [spec, ...tagComponents] = rawSpec.split(/\\|/);\n  const parsed = parseTags(tagComponents.join(\"\\n\"));\n  return {\n    spec,\n    tags: parsed.tags,\n    description: parsed.text,\n  };\n}\n\nfunction smartCommentConstraints(introspectionResults) {\n  const attributesByNames = (tbl, cols, debugStr) => {\n    const attributes = introspectionResults.attribute\n      .filter(a => a.classId === tbl.id)\n      .sort((a, b) => a.num - b.num);\n    if (!cols) {\n      const pk = introspectionResults.constraint.find(\n        c => c.classId == tbl.id && c.type === \"p\"\n      );\n      if (pk) {\n        return pk.keyAttributeNums.map(n => attributes.find(a => a.num === n));\n      } else {\n        throw new Error(\n          `No columns specified for '${tbl.namespaceName}.${tbl.name}' (oid: ${\n            tbl.id\n          }) and no PK found (${debugStr}).`\n        );\n      }\n    }\n    return cols.map(colName => {\n      const attr = attributes.find(a => a.name === colName);\n      if (!attr) {\n        throw new Error(\n          `Could not find attribute '${colName}' in '${tbl.namespaceName}.${\n            tbl.name\n          }'`\n        );\n      }\n      return attr;\n    });\n  };\n\n  // First: primary keys\n  introspectionResults.class.forEach(klass => {\n    const namespace = introspectionResults.namespace.find(\n      n => n.id === klass.namespaceId\n    );\n    if (!namespace) {\n      return;\n    }\n    if (klass.tags.primaryKey) {\n      if (typeof klass.tags.primaryKey !== \"string\") {\n        throw new Error(\n          `@primaryKey configuration of '${klass.namespaceName}.${\n            klass.name\n          }' is invalid; please specify just once \"@primaryKey col1,col2\"`\n        );\n      }\n      const { spec: pkSpec, tags, description } = parseConstraintSpec(\n        klass.tags.primaryKey\n      );\n      // $FlowFixMe\n      const columns: string[] = parseSqlColumn(pkSpec, true);\n      const attributes = attributesByNames(\n        klass,\n        columns,\n        `@primaryKey ${klass.tags.primaryKey}`\n      );\n      attributes.forEach(attr => {\n        attr.tags.notNull = true;\n      });\n      const keyAttributeNums = attributes.map(a => a.num);\n      // Now we need to fake a constraint for this:\n      const fakeConstraint = {\n        kind: \"constraint\",\n        isFake: true,\n        id: Math.random(),\n        name: `FAKE_${klass.namespaceName}_${klass.name}_primaryKey`,\n        type: \"p\", // primary key\n        classId: klass.id,\n        foreignClassId: null,\n        comment: null,\n        description,\n        keyAttributeNums,\n        foreignKeyAttributeNums: null,\n        tags,\n      };\n      introspectionResults.constraint.push(fakeConstraint);\n    }\n  });\n  // Now primary keys are in place, we can apply foreign keys\n  introspectionResults.class.forEach(klass => {\n    const namespace = introspectionResults.namespace.find(\n      n => n.id === klass.namespaceId\n    );\n    if (!namespace) {\n      return;\n    }\n    if (klass.tags.foreignKey) {\n      const foreignKeys =\n        typeof klass.tags.foreignKey === \"string\"\n          ? [klass.tags.foreignKey]\n          : klass.tags.foreignKey;\n      if (!Array.isArray(foreignKeys)) {\n        throw new Error(\n          `Invalid foreign key smart comment specified on '${\n            klass.namespaceName\n          }.${klass.name}'`\n        );\n      }\n      foreignKeys.forEach((fkSpecRaw, index) => {\n        if (typeof fkSpecRaw !== \"string\") {\n          throw new Error(\n            `Invalid foreign key spec (${index}) on '${klass.namespaceName}.${\n              klass.name\n            }'`\n          );\n        }\n        const { spec: fkSpec, tags, description } = parseConstraintSpec(\n          fkSpecRaw\n        );\n        const matches = fkSpec.match(\n          /^\\(([^()]+)\\) references ([^().]+)(?:\\.([^().]+))?(?:\\s*\\(([^()]+)\\))?$/i\n        );\n        if (!matches) {\n          throw new Error(\n            `Invalid foreignKey syntax for '${klass.namespaceName}.${\n              klass.name\n            }'; expected something like \"(col1,col2) references schema.table (c1, c2)\", you passed '${fkSpecRaw}'`\n          );\n        }\n        const [\n          ,\n          rawColumns,\n          rawSchemaOrTable,\n          rawTableOnly,\n          rawForeignColumns,\n        ] = matches;\n        const rawSchema = rawTableOnly\n          ? rawSchemaOrTable\n          : `\"${klass.namespaceName}\"`;\n        const rawTable = rawTableOnly || rawSchemaOrTable;\n        // $FlowFixMe\n        const columns: string[] = parseSqlColumn(rawColumns, true);\n        // $FlowFixMe\n        const foreignSchema: string = parseSqlColumn(rawSchema);\n        // $FlowFixMe\n        const foreignTable: string = parseSqlColumn(rawTable);\n        // $FlowFixMe\n        const foreignColumns: string[] = rawForeignColumns\n          ? parseSqlColumn(rawForeignColumns, true)\n          : null;\n\n        const foreignKlass = introspectionResults.class.find(\n          k => k.name === foreignTable && k.namespaceName === foreignSchema\n        );\n        if (!foreignKlass) {\n          throw new Error(\n            `@foreignKey smart comment referenced non-existant table/view '${foreignSchema}'.'${foreignTable}'. Note that this reference must use *database names* (i.e. it does not respect @name). (${fkSpecRaw})`\n          );\n        }\n        const foreignNamespace = introspectionResults.namespace.find(\n          n => n.id === foreignKlass.namespaceId\n        );\n        if (!foreignNamespace) {\n          return;\n        }\n\n        const keyAttributeNums = attributesByNames(\n          klass,\n          columns,\n          `@foreignKey ${fkSpecRaw}`\n        ).map(a => a.num);\n        const foreignKeyAttributeNums = attributesByNames(\n          foreignKlass,\n          foreignColumns,\n          `@foreignKey ${fkSpecRaw}`\n        ).map(a => a.num);\n\n        // Now we need to fake a constraint for this:\n        const fakeConstraint = {\n          kind: \"constraint\",\n          isFake: true,\n          id: Math.random(),\n          name: `FAKE_${klass.namespaceName}_${klass.name}_foreignKey_${index}`,\n          type: \"f\", // foreign key\n          classId: klass.id,\n          foreignClassId: foreignKlass.id,\n          comment: null,\n          description,\n          keyAttributeNums,\n          foreignKeyAttributeNums,\n          tags,\n        };\n        introspectionResults.constraint.push(fakeConstraint);\n      });\n    }\n  });\n}\n\nexport default (async function PgIntrospectionPlugin(\n  builder,\n  {\n    pgConfig,\n    pgSchemas: schemas,\n    pgEnableTags,\n    persistentMemoizeWithKey = (key, fn) => fn(),\n    pgThrowOnMissingSchema = false,\n    pgIncludeExtensionResources = false,\n    pgLegacyFunctionsOnly = false,\n    pgSkipInstallingWatchFixtures = false,\n    pgAugmentIntrospectionResults,\n    pgOwnerConnectionString,\n  }\n) {\n  const augment = introspectionResults => {\n    [pgAugmentIntrospectionResults, smartCommentConstraints].forEach(\n      fn => (fn ? fn(introspectionResults) : null)\n    );\n  };\n  async function introspect() {\n    // Perform introspection\n    if (!Array.isArray(schemas)) {\n      throw new Error(\"Argument 'schemas' (array) is required\");\n    }\n    const cacheKey = `PgIntrospectionPlugin-introspectionResultsByKind-v${version}`;\n    const cloneResults = obj => {\n      const result = Object.keys(obj).reduce((memo, k) => {\n        memo[k] = Array.isArray(obj[k])\n          ? obj[k].map(v => Object.assign({}, v))\n          : obj[k];\n        return memo;\n      }, {});\n      return result;\n    };\n    const introspectionResultsByKind = cloneResults(\n      await persistentMemoizeWithKey(cacheKey, () =>\n        withPgClient(pgConfig, async pgClient => {\n          const versionResult = await pgClient.query(\n            \"show server_version_num;\"\n          );\n          const serverVersionNum = parseInt(\n            versionResult.rows[0].server_version_num,\n            10\n          );\n          const introspectionQuery = makeIntrospectionQuery(serverVersionNum, {\n            pgLegacyFunctionsOnly,\n          });\n          const { rows } = await pgClient.query(introspectionQuery, [\n            schemas,\n            pgIncludeExtensionResources,\n          ]);\n\n          const result = {\n            __pgVersion: serverVersionNum,\n            namespace: [],\n            class: [],\n            attribute: [],\n            type: [],\n            constraint: [],\n            procedure: [],\n            extension: [],\n            index: [],\n          };\n          for (const { object } of rows) {\n            result[object.kind].push(object);\n          }\n\n          // Parse tags from comments\n          [\n            \"namespace\",\n            \"class\",\n            \"attribute\",\n            \"type\",\n            \"constraint\",\n            \"procedure\",\n            \"extension\",\n            \"index\",\n          ].forEach(kind => {\n            result[kind].forEach(object => {\n              // Keep a copy of the raw comment\n              object.comment = object.description;\n              if (pgEnableTags && object.description) {\n                const parsed = parseTags(object.description);\n                object.tags = parsed.tags;\n                object.description = parsed.text;\n              } else {\n                object.tags = {};\n              }\n            });\n          });\n\n          const extensionConfigurationClassIds = flatMap(\n            result.extension,\n            e => e.configurationClassIds\n          );\n          result.class.forEach(klass => {\n            klass.isExtensionConfigurationTable =\n              extensionConfigurationClassIds.indexOf(klass.id) >= 0;\n          });\n\n          [\n            \"namespace\",\n            \"class\",\n            \"attribute\",\n            \"type\",\n            \"constraint\",\n            \"procedure\",\n            \"extension\",\n            \"index\",\n          ].forEach(k => {\n            result[k].forEach(Object.freeze);\n          });\n\n          return Object.freeze(result);\n        })\n      )\n    );\n\n    const knownSchemas = introspectionResultsByKind.namespace.map(n => n.name);\n    const missingSchemas = schemas.filter(s => knownSchemas.indexOf(s) < 0);\n    if (missingSchemas.length) {\n      const errorMessage = `You requested to use schema '${schemas.join(\n        \"', '\"\n      )}'; however we couldn't find some of those! Missing schemas are: '${missingSchemas.join(\n        \"', '\"\n      )}'`;\n      if (pgThrowOnMissingSchema) {\n        throw new Error(errorMessage);\n      } else {\n        console.warn(\"⚠️ WARNING⚠️  \" + errorMessage); // eslint-disable-line no-console\n      }\n    }\n\n    const xByY = (arrayOfX, attrKey) =>\n      arrayOfX.reduce((memo, x) => {\n        memo[x[attrKey]] = x;\n        return memo;\n      }, {});\n    const xByYAndZ = (arrayOfX, attrKey, attrKey2) =>\n      arrayOfX.reduce((memo, x) => {\n        if (!memo[x[attrKey]]) memo[x[attrKey]] = {};\n        memo[x[attrKey]][x[attrKey2]] = x;\n        return memo;\n      }, {});\n    introspectionResultsByKind.namespaceById = xByY(\n      introspectionResultsByKind.namespace,\n      \"id\"\n    );\n    introspectionResultsByKind.classById = xByY(\n      introspectionResultsByKind.class,\n      \"id\"\n    );\n    introspectionResultsByKind.typeById = xByY(\n      introspectionResultsByKind.type,\n      \"id\"\n    );\n    introspectionResultsByKind.attributeByClassIdAndNum = xByYAndZ(\n      introspectionResultsByKind.attribute,\n      \"classId\",\n      \"num\"\n    );\n    introspectionResultsByKind.extensionById = xByY(\n      introspectionResultsByKind.extension,\n      \"id\"\n    );\n\n    const relate = (array, newAttr, lookupAttr, lookup, missingOk = false) => {\n      array.forEach(entry => {\n        const key = entry[lookupAttr];\n        if (Array.isArray(key)) {\n          entry[newAttr] = key\n            .map(innerKey => {\n              const result = lookup[innerKey];\n              if (innerKey && !result) {\n                if (missingOk) {\n                  return;\n                }\n                throw new Error(\n                  `Could not look up '${newAttr}' by '${lookupAttr}' ('${innerKey}') on '${JSON.stringify(\n                    entry\n                  )}'`\n                );\n              }\n              return result;\n            })\n            .filter(_ => _);\n        } else {\n          const result = lookup[key];\n          if (key && !result) {\n            if (missingOk) {\n              return;\n            }\n            throw new Error(\n              `Could not look up '${newAttr}' by '${lookupAttr}' on '${JSON.stringify(\n                entry\n              )}'`\n            );\n          }\n          entry[newAttr] = result;\n        }\n      });\n    };\n\n    augment(introspectionResultsByKind);\n\n    relate(\n      introspectionResultsByKind.class,\n      \"namespace\",\n      \"namespaceId\",\n      introspectionResultsByKind.namespaceById,\n      true // Because it could be a type defined in a different namespace - which is fine so long as we don't allow querying it directly\n    );\n\n    relate(\n      introspectionResultsByKind.class,\n      \"type\",\n      \"typeId\",\n      introspectionResultsByKind.typeById\n    );\n\n    relate(\n      introspectionResultsByKind.attribute,\n      \"class\",\n      \"classId\",\n      introspectionResultsByKind.classById\n    );\n\n    relate(\n      introspectionResultsByKind.attribute,\n      \"type\",\n      \"typeId\",\n      introspectionResultsByKind.typeById\n    );\n\n    relate(\n      introspectionResultsByKind.procedure,\n      \"namespace\",\n      \"namespaceId\",\n      introspectionResultsByKind.namespaceById\n    );\n\n    relate(\n      introspectionResultsByKind.type,\n      \"class\",\n      \"classId\",\n      introspectionResultsByKind.classById,\n      true\n    );\n\n    relate(\n      introspectionResultsByKind.type,\n      \"domainBaseType\",\n      \"domainBaseTypeId\",\n      introspectionResultsByKind.typeById,\n      true // Because not all types are domains\n    );\n\n    relate(\n      introspectionResultsByKind.type,\n      \"arrayItemType\",\n      \"arrayItemTypeId\",\n      introspectionResultsByKind.typeById,\n      true // Because not all types are arrays\n    );\n\n    relate(\n      introspectionResultsByKind.constraint,\n      \"class\",\n      \"classId\",\n      introspectionResultsByKind.classById\n    );\n\n    relate(\n      introspectionResultsByKind.constraint,\n      \"foreignClass\",\n      \"foreignClassId\",\n      introspectionResultsByKind.classById,\n      true // Because many constraints don't apply to foreign classes\n    );\n\n    relate(\n      introspectionResultsByKind.extension,\n      \"namespace\",\n      \"namespaceId\",\n      introspectionResultsByKind.namespaceById,\n      true // Because the extension could be a defined in a different namespace\n    );\n\n    relate(\n      introspectionResultsByKind.extension,\n      \"configurationClasses\",\n      \"configurationClassIds\",\n      introspectionResultsByKind.classById,\n      true // Because the configuration table could be a defined in a different namespace\n    );\n\n    relate(\n      introspectionResultsByKind.index,\n      \"class\",\n      \"classId\",\n      introspectionResultsByKind.classById\n    );\n\n    // Reverse arrayItemType -> arrayType\n    introspectionResultsByKind.type.forEach(type => {\n      if (type.arrayItemType) {\n        type.arrayItemType.arrayType = type;\n      }\n    });\n\n    // Table/type columns / constraints\n    introspectionResultsByKind.class.forEach(klass => {\n      klass.attributes = introspectionResultsByKind.attribute.filter(\n        attr => attr.classId === klass.id\n      );\n      klass.canUseAsterisk = !klass.attributes.some(\n        attr => attr.columnLevelSelectGrant\n      );\n      klass.constraints = introspectionResultsByKind.constraint.filter(\n        constraint => constraint.classId === klass.id\n      );\n      klass.foreignConstraints = introspectionResultsByKind.constraint.filter(\n        constraint => constraint.foreignClassId === klass.id\n      );\n      klass.primaryKeyConstraint = klass.constraints.find(\n        constraint => constraint.type === \"p\"\n      );\n    });\n\n    // Constraint attributes\n    introspectionResultsByKind.constraint.forEach(constraint => {\n      if (constraint.keyAttributeNums && constraint.class) {\n        constraint.keyAttributes = constraint.keyAttributeNums.map(nr =>\n          constraint.class.attributes.find(attr => attr.num === nr)\n        );\n      } else {\n        constraint.keyAttributes = [];\n      }\n      if (constraint.foreignKeyAttributeNums && constraint.foreignClass) {\n        constraint.foreignKeyAttributes = constraint.foreignKeyAttributeNums.map(\n          nr => constraint.foreignClass.attributes.find(attr => attr.num === nr)\n        );\n      } else {\n        constraint.foreignKeyAttributes = [];\n      }\n    });\n\n    // Detect which columns and constraints are indexed\n    introspectionResultsByKind.index.forEach(index => {\n      const columns = index.attributeNums.map(nr =>\n        index.class.attributes.find(attr => attr.num === nr)\n      );\n\n      // Indexed column (for orderBy / filter):\n      if (columns[0]) {\n        columns[0].isIndexed = true;\n      }\n\n      if (columns[0] && columns.length === 1 && index.isUnique) {\n        columns[0].isUnique = true;\n      }\n\n      // Indexed constraints (for reverse relations):\n      index.class.constraints\n        .filter(constraint => constraint.type === \"f\")\n        .forEach(constraint => {\n          if (\n            constraint.keyAttributeNums.every(\n              (nr, idx) => index.attributeNums[idx] === nr\n            )\n          ) {\n            constraint.isIndexed = true;\n          }\n        });\n    });\n\n    return introspectionResultsByKind;\n  }\n\n  let introspectionResultsByKind = await introspect();\n\n  let pgClient, releasePgClient, listener;\n\n  function stopListening() {\n    if (pgClient) {\n      pgClient.query(\"unlisten postgraphile_watch\").catch(e => {\n        debug(`Error occurred trying to unlisten watch: ${e}`);\n      });\n      pgClient.removeListener(\"notification\", listener);\n    }\n    if (releasePgClient) {\n      releasePgClient();\n      pgClient = null;\n    }\n  }\n\n  builder.registerWatcher(async triggerRebuild => {\n    // In case we started listening before, clean up\n    await stopListening();\n\n    // Check we can get a pgClient\n    if (pgConfig instanceof pg.Pool || quacksLikePgPool(pgConfig)) {\n      pgClient = await pgConfig.connect();\n      releasePgClient = () => pgClient && pgClient.release();\n    } else if (typeof pgConfig === \"string\") {\n      pgClient = new pg.Client(pgConfig);\n      pgClient.on(\"error\", e => {\n        debug(\"pgClient error occurred: %s\", e);\n      });\n      releasePgClient = () =>\n        new Promise((resolve, reject) => {\n          if (pgClient) pgClient.end(err => (err ? reject(err) : resolve()));\n          else resolve();\n        });\n      await new Promise((resolve, reject) => {\n        if (pgClient) {\n          pgClient.connect(err => (err ? reject(err) : resolve()));\n        } else {\n          resolve();\n        }\n      });\n    } else {\n      throw new Error(\n        \"Cannot watch schema with this configuration - need a string or pg.Pool\"\n      );\n    }\n    // Install the watch fixtures.\n    if (!pgSkipInstallingWatchFixtures) {\n      const watchSqlInner = await readFile(WATCH_FIXTURES_PATH, \"utf8\");\n      const sql = `begin; ${watchSqlInner}; commit;`;\n      try {\n        await withPgClient(pgOwnerConnectionString || pgConfig, pgClient =>\n          pgClient.query(sql)\n        );\n      } catch (error) {\n        /* eslint-disable no-console */\n        console.warn(\n          `${chalk.bold.yellow(\n            \"Failed to setup watch fixtures in Postgres database\"\n          )} ️️⚠️`\n        );\n        console.warn(\n          chalk.yellow(\n            \"This is likely because your Postgres user is not a superuser. If the\"\n          )\n        );\n        console.warn(\n          chalk.yellow(\n            \"fixtures already exist, the watch functionality may still work.\"\n          )\n        );\n        console.warn(\n          chalk.yellow(\"Enable DEBUG='graphile-build-pg' to see the error\")\n        );\n        debug(error);\n        /* eslint-enable no-console */\n        await pgClient.query(\"rollback\");\n      }\n    }\n\n    await pgClient.query(\"listen postgraphile_watch\");\n\n    const handleChange = throttle(\n      async () => {\n        debug(`Schema change detected: re-inspecting schema...`);\n        introspectionResultsByKind = await introspect();\n        debug(`Schema change detected: re-inspecting schema complete`);\n        triggerRebuild();\n      },\n      750,\n      {\n        leading: true,\n        trailing: true,\n      }\n    );\n\n    listener = async notification => {\n      if (notification.channel !== \"postgraphile_watch\") {\n        return;\n      }\n      try {\n        const payload = JSON.parse(notification.payload);\n        payload.payload = payload.payload || [];\n        if (payload.type === \"ddl\") {\n          const commands = payload.payload\n            .filter(\n              ({ schema }) => schema == null || schemas.indexOf(schema) >= 0\n            )\n            .map(({ command }) => command);\n          if (commands.length) {\n            handleChange();\n          }\n        } else if (payload.type === \"drop\") {\n          const affectsOurSchemas = payload.payload.some(\n            schemaName => schemas.indexOf(schemaName) >= 0\n          );\n          if (affectsOurSchemas) {\n            handleChange();\n          }\n        } else {\n          throw new Error(`Payload type '${payload.type}' not recognised`);\n        }\n      } catch (e) {\n        debug(`Error occurred parsing notification payload: ${e}`);\n      }\n    };\n    pgClient.on(\"notification\", listener);\n    introspectionResultsByKind = await introspect();\n  }, stopListening);\n\n  builder.hook(\n    \"build\",\n    build => {\n      if (introspectionResultsByKind.__pgVersion < 90500) {\n        // TODO:v5: remove this workaround\n        // This is a bit of a hack, but until we have plugin priorities it's the\n        // easiest way to conditionally support PG9.4.\n        // $FlowFixMe\n        build.pgQueryFromResolveData = queryFromResolveDataFactory({\n          supportsJSONB: false,\n        });\n      }\n      return build.extend(build, {\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n      });\n    },\n    [\"PgIntrospection\"],\n    [],\n    [\"PgBasics\"]\n  );\n}: Plugin);\n"]}