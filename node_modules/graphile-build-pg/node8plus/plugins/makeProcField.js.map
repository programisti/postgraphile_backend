{"version":3,"sources":["../../src/plugins/makeProcField.js"],"names":["makeProcField","nullableIf","GraphQLNonNull","condition","Type","firstValue","obj","firstKey","k","fieldName","proc","build","fieldWithHooks","computed","isMutation","forceList","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","getTypeByName","pgSql","sql","parseResolveInfo","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","gql2pg","pg2gql","newWithHooks","pgStrictFunctions","strictFunctions","pgTweakFragmentForTypeAndModifier","graphql","GraphQLList","GraphQLString","GraphQLObjectType","GraphQLInputObjectType","getNamedType","isCompositeType","inflection","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgViaTemporaryTable","viaTemporaryTable","describePgEntity","sqlCommentByAddingTags","pgField","options","subscriptions","Error","sliceAmount","argNames","argTypeIds","reduce","prev","_","idx","argModes","length","push","argTypes","typeId","typeById","argModesWithOutput","outputArgNames","includes","outputArgTypes","requiredArgCount","Math","max","argDefaultsNum","variantFromName","name","_type","match","variantFromTags","tags","variant","parseInt","notNullArgCount","isStrict","argGqlTypes","map","type","id","hint","class","chalk","bold","green","rawReturnType","returnTypeId","returnType","isPgArray","arrayItemType","returnTypeTable","classById","classId","fieldScope","payloadTypeScope","pgFieldIntrospection","pgIntrospection","returnFirstValueAsValue","TableType","isTableLike","isRecordLike","returnsSet","isPgFieldSimpleCollection","ConnectionType","connection","isPgFieldConnection","pgFieldIntrospectionTable","pgIntrospectionTable","RecordType","recordFunctionReturnType","recordFunctionConnection","connectionTypeName","scalarFunctionConnection","addDataGenerator","getDataFromParsedResolveInfoFragment","addArgDataGenerator","addPgCursorPrefix","pgCursorPrefix","literal","makeMutationCall","parsedResolveInfoFragment","ReturnType","implicitArgs","args","rawArgs","input","sqlArgValues","haveNames","argIndex","argName","gqlArgName","argument","value","sqlValue","sqlArgName","identifier","unshift","fragment","functionCall","namespace","join","makeQuery","sqlMutationQuery","functionAlias","parentQueryBuilder","resolveContext","resolveData","isConnection","query","useAsterisk","language","withPagination","withPaginationAsFields","asJson","asJsonAggregate","addNullCase","innerQueryBuilder","select","primaryKeyConstraint","selectIdentifiers","context","pgQuery","queryBuilder","parentTableAlias","getTableAlias","Symbol","alias","PayloadType","memo","resultFieldName","functionMutationResultFieldName","isNotVoid","String","functionPayloadType","description","functionMutationName","fields","Object","assign","clientMutationId","resolve","data","pgType","__origin","isMutationPayload","InputType","functionInputType","isMutationInput","scalarAwarePg2gql","v","notNull","_args","resolveInfo","liveRecord","safeAlias","makeRecordLive","record","__identifiers","_record","records","pgClient","queryResultRows","intermediateIdentifier","isVoid","isPgRecord","isPgClass","namespaceName","e","text","values","compile","debugSql","enabled","queryResult","rows","row","result","fv"],"mappings":"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","file":"makeProcField.js","sourcesContent":["// @flow\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nimport type { Build, FieldWithHooksFunction } from \"graphile-build\";\nimport type { PgProc } from \"./PgIntrospectionPlugin\";\nimport type { SQL } from \"pg-sql2\";\nimport debugSql from \"./debugSql\";\nimport chalk from \"chalk\";\n\nconst firstValue = obj => {\n  let firstKey;\n  for (const k in obj) {\n    if (k[0] !== \"_\" && k[1] !== \"_\") {\n      firstKey = k;\n    }\n  }\n  return obj[firstKey];\n};\n\nexport default function makeProcField(\n  fieldName: string,\n  proc: PgProc,\n  build: {| ...Build |},\n  {\n    fieldWithHooks,\n    computed = false,\n    isMutation = false,\n    forceList = false,\n  }: {\n    fieldWithHooks: FieldWithHooksFunction,\n    computed?: boolean,\n    isMutation?: boolean,\n    forceList?: boolean,\n  }\n) {\n  const {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlTypeByTypeIdAndModifier,\n    pgGetGqlInputTypeByTypeIdAndModifier,\n    getTypeByName,\n    pgSql: sql,\n    parseResolveInfo,\n    getSafeAliasFromResolveInfo,\n    getSafeAliasFromAlias,\n    gql2pg,\n    pg2gql,\n    newWithHooks,\n    pgStrictFunctions: strictFunctions,\n    pgTweakFragmentForTypeAndModifier,\n    graphql: {\n      GraphQLNonNull,\n      GraphQLList,\n      GraphQLString,\n      GraphQLObjectType,\n      GraphQLInputObjectType,\n      getNamedType,\n      isCompositeType,\n    },\n    inflection,\n    pgQueryFromResolveData: queryFromResolveData,\n    pgAddStartEndCursor: addStartEndCursor,\n    pgViaTemporaryTable: viaTemporaryTable,\n    describePgEntity,\n    sqlCommentByAddingTags,\n    pgField,\n    options: { subscriptions = false },\n  } = build;\n\n  if (computed && isMutation) {\n    throw new Error(\"Mutation procedure cannot be computed\");\n  }\n  const sliceAmount = computed ? 1 : 0;\n  const argNames = proc.argTypeIds.reduce((prev, _, idx) => {\n    if (\n      idx >= sliceAmount && // Was a .slice() call\n      (proc.argModes.length === 0 || // all args are `in`\n      proc.argModes[idx] === \"i\" || // this arg is `in`\n        proc.argModes[idx] === \"b\") // this arg is `inout`\n    ) {\n      prev.push(proc.argNames[idx] || \"\");\n    }\n    return prev;\n  }, []);\n  const argTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (\n      idx >= sliceAmount && // Was a .slice() call\n      (proc.argModes.length === 0 || // all args are `in`\n      proc.argModes[idx] === \"i\" || // this arg is `in`\n        proc.argModes[idx] === \"b\") // this arg is `inout`\n    ) {\n      prev.push(introspectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  const argModesWithOutput = [\n    \"o\", // OUT,\n    \"b\", // INOUT\n    \"t\", // TABLE\n  ];\n  const outputArgNames = proc.argTypeIds.reduce((prev, _, idx) => {\n    if (argModesWithOutput.includes(proc.argModes[idx])) {\n      prev.push(proc.argNames[idx] || \"\");\n    }\n    return prev;\n  }, []);\n  const outputArgTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (argModesWithOutput.includes(proc.argModes[idx])) {\n      prev.push(introspectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  const requiredArgCount = Math.max(0, argNames.length - proc.argDefaultsNum);\n  const variantFromName = (name, _type) => {\n    if (name.match(/(_p|P)atch$/)) {\n      return \"patch\";\n    }\n    return null;\n  };\n  const variantFromTags = (tags, idx) => {\n    const variant = tags[`arg${idx}variant`];\n    if (variant && variant.match && variant.match(/^[0-9]+$/)) {\n      return parseInt(variant, 10);\n    }\n    return variant;\n  };\n  const notNullArgCount =\n    proc.isStrict || strictFunctions ? requiredArgCount : 0;\n  const argGqlTypes = argTypes.map((type, idx) => {\n    // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod on function return values, but maybe a later version might\n    const variant =\n      variantFromTags(proc.tags, idx) || variantFromName(argNames[idx], type);\n    const Type = pgGetGqlInputTypeByTypeIdAndModifier(type.id, variant);\n    if (!Type) {\n      const hint = type.class\n        ? `; this might be because no INSERT column privileges are granted on ${describePgEntity(\n            type.class\n          )}. You can use smart comments to tell PostGraphile to instead use the \"${chalk.bold.green(\n            \"base\"\n          )}\" input type which includes all columns:\\n\\n  ${sqlCommentByAddingTags(\n            proc,\n            {\n              [`arg${idx}variant`]: \"base\",\n            }\n          )}\\n`\n        : \"\";\n      throw new Error(\n        `Could not determine type for argument ${idx} ('${\n          argNames[idx]\n        }') of function ${describePgEntity(proc)}${hint}`\n      );\n    }\n    if (idx >= notNullArgCount) {\n      return Type;\n    } else {\n      return new GraphQLNonNull(Type);\n    }\n  });\n\n  const rawReturnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n  const returnType = rawReturnType.isPgArray\n    ? rawReturnType.arrayItemType\n    : rawReturnType;\n  const returnTypeTable =\n    introspectionResultsByKind.classById[returnType.classId];\n  if (!returnType) {\n    throw new Error(\n      `Could not determine return type for function '${proc.name}'`\n    );\n  }\n  let type;\n  const fieldScope = {};\n  const payloadTypeScope = {};\n  fieldScope.pgFieldIntrospection = proc;\n  payloadTypeScope.pgIntrospection = proc;\n  let returnFirstValueAsValue = false;\n  const TableType =\n    returnTypeTable &&\n    pgGetGqlTypeByTypeIdAndModifier(returnTypeTable.type.id, null);\n\n  const isTableLike: boolean =\n    (TableType && isCompositeType(TableType)) || false;\n  const isRecordLike = returnType.id === \"2249\";\n  if (isTableLike) {\n    if (proc.returnsSet) {\n      if (isMutation) {\n        type = new GraphQLList(TableType);\n      } else if (forceList) {\n        type = new GraphQLList(TableType);\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.connection(TableType.name)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.connection(\n              TableType.name\n            )}' for '${TableType.name}' so cannot create procedure field`\n          );\n        }\n        type = new GraphQLNonNull(ConnectionType);\n        fieldScope.isPgFieldConnection = true;\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    } else {\n      type = TableType;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    }\n  } else if (isRecordLike) {\n    const RecordType = getTypeByName(inflection.recordFunctionReturnType(proc));\n    if (!RecordType) {\n      throw new Error(\n        `Do not have a record type '${inflection.recordFunctionReturnType(\n          proc\n        )}' for '${proc.name}' so cannot create procedure field`\n      );\n    }\n    if (proc.returnsSet) {\n      if (isMutation) {\n        type = new GraphQLList(RecordType);\n      } else if (forceList) {\n        type = new GraphQLList(RecordType);\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.recordFunctionConnection(proc)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.recordFunctionConnection(\n              proc\n            )}' for '${RecordType.name}' so cannot create procedure field`\n          );\n        }\n        type = new GraphQLNonNull(ConnectionType);\n        fieldScope.isPgFieldConnection = true;\n      }\n    } else {\n      type = RecordType;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  } else {\n    // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod on function return values, but maybe a later version might\n    const Type =\n      pgGetGqlTypeByTypeIdAndModifier(returnType.id, null) || GraphQLString;\n\n    if (proc.returnsSet) {\n      const connectionTypeName = inflection.scalarFunctionConnection(proc);\n      const ConnectionType = getTypeByName(connectionTypeName);\n      if (isMutation) {\n        // Cannot return a connection because it would have to run the mutation again\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n      } else if (forceList || !ConnectionType) {\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        type = new GraphQLNonNull(ConnectionType);\n        fieldScope.isPgFieldConnection = true;\n        // We don't return the first value as the value here because it gets\n        // sent down into PgScalarFunctionConnectionPlugin so the relevant\n        // EdgeType can return cursor / node; i.e. we might want to add an\n        // `__cursor` field so we can't just use a scalar.\n      }\n    } else {\n      returnFirstValueAsValue = true;\n      type = Type;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  }\n  return fieldWithHooks(\n    fieldName,\n    ({\n      addDataGenerator,\n      getDataFromParsedResolveInfoFragment,\n      addArgDataGenerator,\n    }) => {\n      if (\n        proc.returnsSet &&\n        !isTableLike &&\n        !returnFirstValueAsValue &&\n        !isMutation\n      ) {\n        // Natural ordering\n        addArgDataGenerator(function addPgCursorPrefix() {\n          return {\n            pgCursorPrefix: sql.literal(\"natural\"),\n          };\n        });\n      }\n      function makeMutationCall(\n        parsedResolveInfoFragment,\n        ReturnType,\n        { implicitArgs = [] } = {}\n      ): SQL {\n        const { args: rawArgs = {} } = parsedResolveInfoFragment;\n        const args = isMutation ? rawArgs.input : rawArgs;\n        const sqlArgValues = [];\n        let haveNames = true;\n        for (let argIndex = argNames.length - 1; argIndex >= 0; argIndex--) {\n          const argName = argNames[argIndex];\n          const gqlArgName = inflection.argument(argName, argIndex);\n          const value = args[gqlArgName];\n          const variant =\n            variantFromTags(proc.tags, argIndex) ||\n            variantFromName(argNames[argIndex], type);\n\n          const sqlValue = gql2pg(value, argTypes[argIndex], variant);\n\n          if (argIndex + 1 > requiredArgCount && haveNames && value == null) {\n            // No need to pass argument to function\n            continue;\n          } else if (argIndex + 1 > requiredArgCount && haveNames) {\n            const sqlArgName = argName ? sql.identifier(argName) : null;\n            if (sqlArgName) {\n              sqlArgValues.unshift(sql.fragment`${sqlArgName} := ${sqlValue}`);\n            } else {\n              haveNames = false;\n              sqlArgValues.unshift(sqlValue);\n            }\n          } else {\n            sqlArgValues.unshift(sqlValue);\n          }\n        }\n        const functionCall = sql.fragment`${sql.identifier(\n          proc.namespace.name,\n          proc.name\n        )}(${sql.join([...implicitArgs, ...sqlArgValues], \", \")})`;\n        return rawReturnType.isPgArray\n          ? sql.fragment`unnest(${functionCall})`\n          : functionCall;\n      }\n      function makeQuery(\n        parsedResolveInfoFragment,\n        ReturnType,\n        sqlMutationQuery,\n        functionAlias,\n        parentQueryBuilder,\n        resolveContext\n      ) {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        const isConnection = !forceList && !isMutation && proc.returnsSet;\n        const query = queryFromResolveData(\n          sqlMutationQuery,\n          functionAlias,\n          resolveData,\n          {\n            useAsterisk:\n              !isMutation &&\n              (isTableLike || isRecordLike) &&\n              (forceList || proc.returnsSet || rawReturnType.isPgArray) && // only bother with lists\n              proc.language !== \"sql\", // sql functions can be inlined, so GRANTs still apply\n            withPagination: isConnection,\n            withPaginationAsFields: isConnection && !computed,\n            asJson:\n              computed &&\n              (forceList || (!proc.returnsSet && !returnFirstValueAsValue)),\n            asJsonAggregate:\n              computed &&\n              (forceList || (!proc.returnsSet && rawReturnType.isPgArray)),\n            addNullCase:\n              !proc.returnsSet &&\n              !rawReturnType.isPgArray &&\n              (isTableLike || isRecordLike),\n          },\n          innerQueryBuilder => {\n            innerQueryBuilder.parentQueryBuilder = parentQueryBuilder;\n            if (!isTableLike) {\n              if (returnTypeTable) {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForTypeAndModifier(\n                    sql.fragment`${functionAlias}`,\n                    returnTypeTable.type,\n                    null,\n                    resolveData\n                  ),\n                  \"value\"\n                );\n              } else {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForTypeAndModifier(\n                    sql.fragment`${functionAlias}`,\n                    returnType,\n                    null, // We can't determine a type modifier for functions\n                    resolveData\n                  ),\n                  \"value\"\n                );\n              }\n            } else if (\n              subscriptions &&\n              returnTypeTable &&\n              !isConnection &&\n              returnTypeTable.primaryKeyConstraint\n            ) {\n              innerQueryBuilder.selectIdentifiers(returnTypeTable);\n            }\n          },\n          parentQueryBuilder ? parentQueryBuilder.context : resolveContext\n        );\n        return query;\n      }\n      if (computed) {\n        addDataGenerator((parsedResolveInfoFragment, ReturnType) => {\n          return {\n            pgQuery: queryBuilder => {\n              queryBuilder.select(() => {\n                const parentTableAlias = queryBuilder.getTableAlias();\n                const functionAlias = sql.identifier(Symbol());\n                const sqlMutationQuery = makeMutationCall(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  {\n                    implicitArgs: [parentTableAlias],\n                  }\n                );\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  sqlMutationQuery,\n                  functionAlias,\n                  queryBuilder\n                );\n                return sql.fragment`(${query})`;\n              }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n            },\n          };\n        });\n      }\n\n      let ReturnType = type;\n      let PayloadType;\n      let args = argNames.reduce((memo, argName, argIndex) => {\n        const gqlArgName = inflection.argument(argName, argIndex);\n        memo[gqlArgName] = {\n          type: argGqlTypes[argIndex],\n        };\n        return memo;\n      }, {});\n      if (isMutation) {\n        const resultFieldName = inflection.functionMutationResultFieldName(\n          proc,\n          getNamedType(type),\n          proc.returnsSet || rawReturnType.isPgArray,\n          outputArgNames\n        );\n        const isNotVoid = String(returnType.id) !== \"2278\";\n        // If set then plural name\n        PayloadType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.functionPayloadType(proc),\n            description: `The output of our \\`${inflection.functionMutationName(\n              proc\n            )}\\` mutation.`,\n            fields: ({ fieldWithHooks }) => {\n              return Object.assign(\n                {},\n                {\n                  clientMutationId: {\n                    type: GraphQLString,\n                  },\n                },\n                isNotVoid\n                  ? {\n                      [resultFieldName]: pgField(\n                        build,\n                        fieldWithHooks,\n                        resultFieldName,\n                        {\n                          type: type,\n                          ...(returnFirstValueAsValue\n                            ? {\n                                resolve(data) {\n                                  return data.data;\n                                },\n                              }\n                            : null),\n                        },\n                        {},\n                        false,\n                        {\n                          pgType: returnType,\n                        }\n                      ),\n                      // Result\n                    }\n                  : null\n              );\n            },\n          },\n          Object.assign(\n            {},\n            {\n              __origin: `Adding mutation function payload type for ${describePgEntity(\n                proc\n              )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n                proc,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              isMutationPayload: true,\n            },\n            payloadTypeScope\n          )\n        );\n        ReturnType = PayloadType;\n        const InputType = newWithHooks(\n          GraphQLInputObjectType,\n          {\n            name: inflection.functionInputType(proc),\n            description: `All input for the \\`${inflection.functionMutationName(\n              proc\n            )}\\` mutation.`,\n            fields: Object.assign(\n              {\n                clientMutationId: {\n                  type: GraphQLString,\n                },\n              },\n              args\n            ),\n          },\n          {\n            __origin: `Adding mutation function input type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isMutationInput: true,\n          }\n        );\n        args = {\n          input: {\n            type: new GraphQLNonNull(InputType),\n          },\n        };\n      }\n      // If this is a table we can process it directly; but if it's a scalar\n      // setof function we must dereference '.value' from it, because this\n      // makes space for '__cursor' to exist alongside it (whereas on a table\n      // the '__cursor' can just be on the table object itself)\n      const scalarAwarePg2gql = v =>\n        isTableLike\n          ? pg2gql(v, returnType)\n          : {\n              ...v,\n              value: pg2gql(v.value, returnType),\n            };\n\n      return {\n        description: proc.description\n          ? proc.description\n          : isTableLike && proc.returnsSet\n            ? `Reads and enables pagination through a set of \\`${\n                TableType.name\n              }\\`.`\n            : null,\n        type: nullableIf(GraphQLNonNull, !proc.tags.notNull, ReturnType),\n        args: args,\n        resolve: computed\n          ? (data, _args, resolveContext, resolveInfo) => {\n              const { liveRecord } = resolveContext;\n              const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n              const value = data[safeAlias];\n              if (returnFirstValueAsValue) {\n                // Is not table like; is not record like.\n                if (proc.returnsSet && !forceList) {\n                  // EITHER `isMutation` is true, or `ConnectionType` does not\n                  // exist - either way, we're not returning a connection.\n                  return value.data.map(v => pg2gql(firstValue(v), returnType));\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  return value.map(v => pg2gql(firstValue(v), returnType));\n                } else {\n                  return pg2gql(value, returnType);\n                }\n              } else {\n                const makeRecordLive =\n                  subscriptions && isTableLike && returnTypeTable && liveRecord\n                    ? record => {\n                        if (record) {\n                          liveRecord(\n                            \"pg\",\n                            returnTypeTable,\n                            record.__identifiers\n                          );\n                        }\n                      }\n                    : _record => {};\n                if (proc.returnsSet && !isMutation && !forceList) {\n                  // Connection - do not make live (the connection will handle this)\n                  return addStartEndCursor({\n                    ...value,\n                    data: value.data ? value.data.map(scalarAwarePg2gql) : null,\n                  });\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  // List\n                  const records = value.map(v => {\n                    makeRecordLive(v);\n                    return pg2gql(v, returnType);\n                  });\n                  return records;\n                } else {\n                  // Object\n                  if (value) {\n                    makeRecordLive(value);\n                  }\n                  return pg2gql(value, returnType);\n                }\n              }\n            }\n          : async (data, args, resolveContext, resolveInfo) => {\n              const { pgClient, liveRecord } = resolveContext;\n              const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n              parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n              const functionAlias = sql.identifier(Symbol());\n              const sqlMutationQuery = makeMutationCall(\n                parsedResolveInfoFragment,\n                resolveInfo.returnType,\n                {}\n              );\n\n              let queryResultRows;\n              if (isMutation) {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  functionAlias,\n                  functionAlias,\n                  null,\n                  resolveContext\n                );\n                const intermediateIdentifier = sql.identifier(Symbol());\n                const isVoid = returnType.id === \"2278\";\n                const isPgRecord = returnType.id === \"2249\";\n                const isPgClass =\n                  !isPgRecord &&\n                  (!returnFirstValueAsValue || returnTypeTable || false);\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  queryResultRows = await viaTemporaryTable(\n                    pgClient,\n                    isVoid\n                      ? null\n                      : sql.identifier(\n                          returnType.namespaceName,\n                          returnType.name\n                        ),\n                    sql.query`select ${\n                      isPgClass\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : isPgRecord\n                          ? sql.query`${intermediateIdentifier}.*`\n                          : sql.query`${intermediateIdentifier} as ${functionAlias}`\n                    } from ${sqlMutationQuery} ${intermediateIdentifier}`,\n                    functionAlias,\n                    query,\n                    isPgClass,\n                    isPgRecord\n                      ? {\n                          outputArgTypes,\n                          outputArgNames,\n                        }\n                      : null\n                  );\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n              } else {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  sqlMutationQuery,\n                  functionAlias,\n                  null,\n                  resolveContext\n                );\n                const { text, values } = sql.compile(query);\n                if (debugSql.enabled) debugSql(text);\n                const queryResult = await pgClient.query(text, values);\n                queryResultRows = queryResult.rows;\n              }\n              const rows = queryResultRows;\n              const [row] = rows;\n              const result = (() => {\n                const makeRecordLive =\n                  subscriptions && isTableLike && returnTypeTable && liveRecord\n                    ? record => {\n                        if (record) {\n                          liveRecord(\n                            \"pg\",\n                            returnTypeTable,\n                            record.__identifiers\n                          );\n                        }\n                      }\n                    : _record => {};\n                if (returnFirstValueAsValue) {\n                  // `returnFirstValueAsValue` implies either `isMutation` is\n                  // true, or `ConnectionType` does not exist - either way,\n                  // we're not returning a connection.\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    return row.data.map(v => {\n                      const fv = firstValue(v);\n                      makeRecordLive(fv);\n                      return pg2gql(fv, returnType);\n                    });\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    return rows.map(v => {\n                      const fv = firstValue(v);\n                      makeRecordLive(fv);\n                      return pg2gql(fv, returnType);\n                    });\n                  } else {\n                    const fv = firstValue(row);\n                    makeRecordLive(fv);\n                    const record = pg2gql(fv, returnType);\n                    return record;\n                  }\n                } else {\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    // Connection\n                    const data = row.data\n                      ? row.data.map(scalarAwarePg2gql)\n                      : null;\n                    return addStartEndCursor({\n                      ...row,\n                      data,\n                    });\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    // List\n                    return rows.map(row => {\n                      makeRecordLive(row);\n                      return pg2gql(row, returnType);\n                    });\n                  } else {\n                    // Object\n                    makeRecordLive(row);\n                    return pg2gql(row, returnType);\n                  }\n                }\n              })();\n              if (isMutation) {\n                return {\n                  clientMutationId: args.input.clientMutationId,\n                  data: result,\n                };\n              } else {\n                return result;\n              }\n            },\n      };\n    },\n    fieldScope\n  );\n}\n"]}