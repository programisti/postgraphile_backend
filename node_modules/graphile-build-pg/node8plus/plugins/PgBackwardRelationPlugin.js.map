{"version":3,"sources":["../../src/plugins/PgBackwardRelationPlugin.js"],"names":["debug","OMIT","DEPRECATED","ONLY","PgBackwardRelationPlugin","builder","pgLegacyRelations","pgSimpleCollections","subscriptions","legacyRelationMode","only","deprecated","hook","fields","build","context","extend","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","graphql","GraphQLNonNull","GraphQLList","inflection","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgOmit","omit","sqlCommentByAddingTags","describePgEntity","scope","isPgRowType","pgIntrospection","foreignTable","fieldWithHooks","Self","kind","foreignKeyConstraints","foreignConstraints","filter","con","type","foreignTableTypeName","tableType","gqlForeignTableType","id","reduce","memo","constraint","table","classById","classId","tableTypeName","gqlTableType","Error","name","schema","namespace","keys","keyAttributes","foreignKeys","foreignKeyAttributes","every","_","some","key","isUnique","constraints","find","c","keyAttributeNums","length","n","i","num","isDeprecated","singleRelationFieldName","singleRelationByKeysBackwards","primaryKeyConstraint","primaryKeys","shouldAddSingleRelation","shouldAddManyRelation","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","tableAlias","identifier","Symbol","foreignTableAlias","getTableAlias","query","useAsterisk","asJson","addNullCase","withPagination","innerQueryBuilder","parentQueryBuilder","selectIdentifiers","forEach","where","fragment","alias","description","tags","backwardDescription","args","resolve","data","_args","resolveContext","resolveInfo","safeAlias","record","liveRecord","__identifiers","pgFieldIntrospection","isPgBackwardSingleRelationField","foreignSingleFieldName","makeFields","isConnection","manyRelationFieldName","manyRelationByKeys","manyRelationByKeysSimple","ConnectionType","TableType","canUseAsterisk","withPaginationAsFields","asJsonAggregate","makeLiveCollection","addLiveCondition","beforeLock","isOrderUnique","cursorPrefix","orderBy","setOrderIsUnique","connection","liveCollection","__live","__id","rest","condition","liveConditions","checker","records","r","deprecationReason","isPgFieldConnection","isPgFieldSimpleCollection","isPgBackwardRelationField","simpleCollections","hasConnections","hasSimpleCollections"],"mappings":"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","file":"PgBackwardRelationPlugin.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\n\nimport type { Plugin } from \"graphile-build\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nconst OMIT = 0;\nconst DEPRECATED = 1;\nconst ONLY = 2;\n\nexport default (function PgBackwardRelationPlugin(\n  builder,\n  { pgLegacyRelations, pgSimpleCollections, subscriptions }\n) {\n  const legacyRelationMode =\n    {\n      only: ONLY,\n      deprecated: DEPRECATED,\n    }[pgLegacyRelations] || OMIT;\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        getSafeAliasFromResolveInfo,\n        getSafeAliasFromAlias,\n        graphql: { GraphQLNonNull, GraphQLList },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgAddStartEndCursor: addStartEndCursor,\n        pgOmit: omit,\n        sqlCommentByAddingTags,\n        describePgEntity,\n      } = build;\n      const {\n        scope: { isPgRowType, pgIntrospection: foreignTable },\n        fieldWithHooks,\n        Self,\n      } = context;\n      if (!isPgRowType || !foreignTable || foreignTable.kind !== \"class\") {\n        return fields;\n      }\n      // This is a relation in which WE are foreign\n      const foreignKeyConstraints = foreignTable.foreignConstraints.filter(\n        con => con.type === \"f\"\n      );\n      const foreignTableTypeName = inflection.tableType(foreignTable);\n      const gqlForeignTableType = pgGetGqlTypeByTypeIdAndModifier(\n        foreignTable.type.id,\n        null\n      );\n      if (!gqlForeignTableType) {\n        debug(\n          `Could not determine type for foreign table with id ${\n            foreignTable.type.id\n          }`\n        );\n        return fields;\n      }\n\n      return extend(\n        fields,\n        foreignKeyConstraints.reduce((memo, constraint) => {\n          if (omit(constraint, \"read\")) {\n            return memo;\n          }\n          const table =\n            introspectionResultsByKind.classById[constraint.classId];\n          const tableTypeName = inflection.tableType(table);\n          const gqlTableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          if (!gqlTableType) {\n            debug(\n              `Could not determine type for table with id ${constraint.classId}`\n            );\n            return memo;\n          }\n          if (!table) {\n            throw new Error(\n              `Could not find the table that referenced us (constraint: ${\n                constraint.name\n              })`\n            );\n          }\n          const schema = table.namespace;\n\n          const keys = constraint.keyAttributes;\n          const foreignKeys = constraint.foreignKeyAttributes;\n          if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n            throw new Error(\"Could not find key columns!\");\n          }\n          if (keys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n          if (foreignKeys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n          const isUnique = !!table.constraints.find(\n            c =>\n              (c.type === \"p\" || c.type === \"u\") &&\n              c.keyAttributeNums.length === keys.length &&\n              c.keyAttributeNums.every((n, i) => keys[i].num === n)\n          );\n\n          const isDeprecated = isUnique && legacyRelationMode === DEPRECATED;\n\n          const singleRelationFieldName = isUnique\n            ? inflection.singleRelationByKeysBackwards(\n                keys,\n                table,\n                foreignTable,\n                constraint\n              )\n            : null;\n\n          const primaryKeyConstraint = table.primaryKeyConstraint;\n          const primaryKeys =\n            primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n\n          const shouldAddSingleRelation =\n            isUnique && legacyRelationMode !== ONLY;\n\n          const shouldAddManyRelation =\n            !isUnique ||\n            legacyRelationMode === DEPRECATED ||\n            legacyRelationMode === ONLY;\n\n          if (\n            shouldAddSingleRelation &&\n            !omit(table, \"read\") &&\n            singleRelationFieldName\n          ) {\n            memo = extend(\n              memo,\n              {\n                [singleRelationFieldName]: fieldWithHooks(\n                  singleRelationFieldName,\n                  ({\n                    getDataFromParsedResolveInfoFragment,\n                    addDataGenerator,\n                  }) => {\n                    addDataGenerator(parsedResolveInfoFragment => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.select(() => {\n                            const resolveData = getDataFromParsedResolveInfoFragment(\n                              parsedResolveInfoFragment,\n                              gqlTableType\n                            );\n                            const tableAlias = sql.identifier(Symbol());\n                            const foreignTableAlias = queryBuilder.getTableAlias();\n                            const query = queryFromResolveData(\n                              sql.identifier(schema.name, table.name),\n                              tableAlias,\n                              resolveData,\n                              {\n                                useAsterisk: false, // Because it's only a single relation, no need\n                                asJson: true,\n                                addNullCase: true,\n                                withPagination: false,\n                              },\n                              innerQueryBuilder => {\n                                innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                                if (\n                                  subscriptions &&\n                                  table.primaryKeyConstraint\n                                ) {\n                                  innerQueryBuilder.selectIdentifiers(table);\n                                }\n                                keys.forEach((key, i) => {\n                                  innerQueryBuilder.where(\n                                    sql.fragment`${tableAlias}.${sql.identifier(\n                                      key.name\n                                    )} = ${foreignTableAlias}.${sql.identifier(\n                                      foreignKeys[i].name\n                                    )}`\n                                  );\n                                });\n                              },\n                              queryBuilder.context\n                            );\n                            return sql.fragment`(${query})`;\n                          }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                        },\n                      };\n                    });\n                    return {\n                      description:\n                        constraint.tags.backwardDescription ||\n                        `Reads a single \\`${tableTypeName}\\` that is related to this \\`${foreignTableTypeName}\\`.`,\n                      type: gqlTableType,\n                      args: {},\n                      resolve: (data, _args, resolveContext, resolveInfo) => {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        const record = data[safeAlias];\n                        if (record && resolveContext.liveRecord) {\n                          resolveContext.liveRecord(\n                            \"pg\",\n                            table,\n                            record.__identifiers\n                          );\n                        }\n                        return record;\n                      },\n                    };\n                  },\n                  {\n                    pgFieldIntrospection: table,\n                    isPgBackwardSingleRelationField: true,\n                  }\n                ),\n              },\n              `Backward relation (single) for ${describePgEntity(\n                constraint\n              )}. To rename this relation with smart comments:\\n\\n  ${sqlCommentByAddingTags(\n                constraint,\n                {\n                  foreignSingleFieldName: \"newNameHere\",\n                }\n              )}`\n            );\n          }\n          function makeFields(isConnection) {\n            if (isUnique && !isConnection) {\n              // Don't need this, use the singular instead\n              return;\n            }\n            if (shouldAddManyRelation && !omit(table, \"many\")) {\n              const manyRelationFieldName = isConnection\n                ? inflection.manyRelationByKeys(\n                    keys,\n                    table,\n                    foreignTable,\n                    constraint\n                  )\n                : inflection.manyRelationByKeysSimple(\n                    keys,\n                    table,\n                    foreignTable,\n                    constraint\n                  );\n\n              memo = extend(\n                memo,\n                {\n                  [manyRelationFieldName]: fieldWithHooks(\n                    manyRelationFieldName,\n                    ({\n                      getDataFromParsedResolveInfoFragment,\n                      addDataGenerator,\n                    }) => {\n                      addDataGenerator(parsedResolveInfoFragment => {\n                        return {\n                          pgQuery: queryBuilder => {\n                            queryBuilder.select(() => {\n                              const resolveData = getDataFromParsedResolveInfoFragment(\n                                parsedResolveInfoFragment,\n                                isConnection ? ConnectionType : TableType\n                              );\n                              const tableAlias = sql.identifier(Symbol());\n                              const foreignTableAlias = queryBuilder.getTableAlias();\n                              const query = queryFromResolveData(\n                                sql.identifier(schema.name, table.name),\n                                tableAlias,\n                                resolveData,\n                                {\n                                  useAsterisk: table.canUseAsterisk,\n                                  withPagination: isConnection,\n                                  withPaginationAsFields: false,\n                                  asJsonAggregate: !isConnection,\n                                },\n                                innerQueryBuilder => {\n                                  innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                                  if (subscriptions) {\n                                    innerQueryBuilder.makeLiveCollection(table);\n                                    innerQueryBuilder.addLiveCondition(\n                                      data => record => {\n                                        return keys.every(\n                                          key =>\n                                            record[key.name] === data[key.name]\n                                        );\n                                      },\n                                      keys.reduce((memo, key, i) => {\n                                        memo[\n                                          key.name\n                                        ] = sql.fragment`${foreignTableAlias}.${sql.identifier(\n                                          foreignKeys[i].name\n                                        )}`;\n                                        return memo;\n                                      }, {})\n                                    );\n                                  }\n                                  if (primaryKeys) {\n                                    if (\n                                      subscriptions &&\n                                      !isConnection &&\n                                      table.primaryKeyConstraint\n                                    ) {\n                                      innerQueryBuilder.selectIdentifiers(\n                                        table\n                                      );\n                                    }\n                                    innerQueryBuilder.beforeLock(\n                                      \"orderBy\",\n                                      () => {\n                                        // append order by primary key to the list of orders\n                                        if (\n                                          !innerQueryBuilder.isOrderUnique(\n                                            false\n                                          )\n                                        ) {\n                                          innerQueryBuilder.data.cursorPrefix = [\n                                            \"primary_key_asc\",\n                                          ];\n                                          primaryKeys.forEach(key => {\n                                            innerQueryBuilder.orderBy(\n                                              sql.fragment`${innerQueryBuilder.getTableAlias()}.${sql.identifier(\n                                                key.name\n                                              )}`,\n                                              true\n                                            );\n                                          });\n                                          innerQueryBuilder.setOrderIsUnique();\n                                        }\n                                      }\n                                    );\n                                  }\n\n                                  keys.forEach((key, i) => {\n                                    innerQueryBuilder.where(\n                                      sql.fragment`${tableAlias}.${sql.identifier(\n                                        key.name\n                                      )} = ${foreignTableAlias}.${sql.identifier(\n                                        foreignKeys[i].name\n                                      )}`\n                                    );\n                                  });\n                                },\n                                queryBuilder.context\n                              );\n                              return sql.fragment`(${query})`;\n                            }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                          },\n                        };\n                      });\n                      const ConnectionType = getTypeByName(\n                        inflection.connection(gqlTableType.name)\n                      );\n                      const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                        table.type.id,\n                        null\n                      );\n                      return {\n                        description:\n                          constraint.tags.backwardDescription ||\n                          `Reads and enables pagination through a set of \\`${tableTypeName}\\`.`,\n                        type: isConnection\n                          ? new GraphQLNonNull(ConnectionType)\n                          : new GraphQLNonNull(\n                              new GraphQLList(new GraphQLNonNull(TableType))\n                            ),\n                        args: {},\n                        resolve: (data, _args, resolveContext, resolveInfo) => {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          if (\n                            subscriptions &&\n                            resolveContext.liveCollection &&\n                            data.__live\n                          ) {\n                            const { __id, ...rest } = data.__live;\n                            const condition =\n                              resolveContext.liveConditions[__id];\n                            const checker = condition(rest);\n\n                            resolveContext.liveCollection(\"pg\", table, checker);\n                          }\n                          if (isConnection) {\n                            return addStartEndCursor(data[safeAlias]);\n                          } else {\n                            const records = data[safeAlias];\n                            if (subscriptions && resolveContext.liveRecord) {\n                              records.forEach(\n                                r =>\n                                  r &&\n                                  resolveContext.liveRecord(\n                                    \"pg\",\n                                    table,\n                                    r.__identifiers\n                                  )\n                              );\n                            }\n                            return records;\n                          }\n                        },\n                        ...(isDeprecated\n                          ? {\n                              deprecationReason:\n                                // $FlowFixMe\n                                `Please use ${singleRelationFieldName} instead`,\n                            }\n                          : null),\n                      };\n                    },\n                    {\n                      isPgFieldConnection: isConnection,\n                      isPgFieldSimpleCollection: !isConnection,\n                      isPgBackwardRelationField: true,\n                      pgFieldIntrospection: table,\n                    }\n                  ),\n                },\n\n                `Backward relation (${\n                  isConnection ? \"connection\" : \"simple collection\"\n                }) for ${describePgEntity(\n                  constraint\n                )}. To rename this relation with smart comments:\\n\\n  ${sqlCommentByAddingTags(\n                  constraint,\n                  {\n                    [isConnection\n                      ? \"foreignFieldName\"\n                      : \"foreignSimpleFieldName\"]: \"newNameHere\",\n                  }\n                )}`\n              );\n            }\n          }\n          const simpleCollections =\n            constraint.tags.simpleCollections ||\n            table.tags.simpleCollections ||\n            pgSimpleCollections;\n          const hasConnections = simpleCollections !== \"only\";\n          const hasSimpleCollections =\n            simpleCollections === \"only\" || simpleCollections === \"both\";\n          if (hasConnections) {\n            makeFields(true);\n          }\n          if (hasSimpleCollections) {\n            makeFields(false);\n          }\n          return memo;\n        }, {}),\n        `Adding backward relations for ${Self.name}`\n      );\n    },\n    [\"PgBackwardRelation\"]\n  );\n}: Plugin);\n"]}