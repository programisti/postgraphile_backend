{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","hook","build","pgSql","sql","pgTweakFragmentForTypeAndModifier","pgQueryFromResolveData","queryFromResolveData","getSelectValueForFieldAndTypeAndModifier","ReturnType","fieldScope","parsedResolveInfoFragment","sqlFullName","type","typeModifier","getDataFromParsedResolveInfoFragment","isPgArray","ident","identifier","Symbol","fragment","arrayItemType","resolveData","isDefinitelyNotATable","class","isSelectable","jsonBuildObject","onlyJsonField","addNullCase","addNotDistinctFromNullCase","extend","pgGetSelectValueForFieldAndTypeAndModifier","fields","context","pgGetGqlTypeByTypeIdAndModifier","pg2gql","graphql","GraphQLString","pgColumnFilter","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","scope","isPgRowType","isPgCompoundType","pgIntrospection","table","fieldWithHooks","kind","attributes","reduce","memo","attr","fieldName","column","Error","namespaceName","name","fieldContext","addDataGenerator","typeId","pgQuery","queryBuilder","select","getTableAlias","description","isNotNull","domainIsNotNull","tags","notNull","resolve","data","_args","_context","_resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeIdAndModifier","isPgPatch","isPgBaseInput","pgAddSubfield","action","identity","domainHasDefault","hasDefault"],"mappings":"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","file":"PgColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(builder) {\n  builder.hook(\n    \"build\",\n    build => {\n      const {\n        pgSql: sql,\n        pgTweakFragmentForTypeAndModifier,\n        pgQueryFromResolveData: queryFromResolveData,\n      } = build;\n      const getSelectValueForFieldAndTypeAndModifier = (\n        ReturnType,\n        fieldScope,\n        parsedResolveInfoFragment,\n        sqlFullName,\n        type,\n        typeModifier\n      ) => {\n        const { getDataFromParsedResolveInfoFragment } = fieldScope;\n        if (type.isPgArray) {\n          const ident = sql.identifier(Symbol());\n          return sql.fragment`\n          (\n            case\n            when ${sqlFullName} is null then null\n            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\n            else\n              (\n                select json_agg(${getSelectValueForFieldAndTypeAndModifier(\n                  ReturnType,\n                  fieldScope,\n                  parsedResolveInfoFragment,\n                  ident,\n                  type.arrayItemType,\n                  typeModifier\n                )})\n                from unnest(${sqlFullName}) as ${ident}\n              )\n            end\n          )\n        `;\n        } else {\n          const resolveData = getDataFromParsedResolveInfoFragment(\n            parsedResolveInfoFragment,\n            ReturnType\n          );\n          if (type.type === \"c\") {\n            const isDefinitelyNotATable =\n              type.class && !type.class.isSelectable;\n            const jsonBuildObject = queryFromResolveData(\n              sql.identifier(Symbol()), // Ignore!\n              sqlFullName,\n              resolveData,\n              {\n                onlyJsonField: true,\n                addNullCase: !isDefinitelyNotATable,\n                addNotDistinctFromNullCase: isDefinitelyNotATable,\n              }\n            );\n            return jsonBuildObject;\n          } else {\n            return pgTweakFragmentForTypeAndModifier(\n              sqlFullName,\n              type,\n              typeModifier,\n              resolveData\n            );\n          }\n        }\n      };\n      return build.extend(build, {\n        pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n      });\n    },\n    [\"PgColumns\"],\n    [],\n    [\"PgTypes\"]\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgSql: sql,\n        pg2gql,\n        graphql: { GraphQLString, GraphQLNonNull },\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n        pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      const {\n        scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n        fieldWithHooks,\n      } = context;\n\n      if (\n        !(isPgRowType || isPgCompoundType) ||\n        !table ||\n        table.kind !== \"class\"\n      ) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        table.attributes.reduce((memo, attr) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!pgColumnFilter(attr, build, context)) return memo;\n          if (omit(attr, \"read\")) return memo;\n\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                fieldContext => {\n                  const { addDataGenerator } = fieldContext;\n                  const ReturnType =\n                    pgGetGqlTypeByTypeIdAndModifier(\n                      attr.typeId,\n                      attr.typeModifier\n                    ) || GraphQLString;\n                  addDataGenerator(parsedResolveInfoFragment => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(\n                          getSelectValueForFieldAndTypeAndModifier(\n                            ReturnType,\n                            fieldContext,\n                            parsedResolveInfoFragment,\n                            sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                              attr.name\n                            )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                            attr.type,\n                            attr.typeModifier\n                          ),\n                          fieldName\n                        );\n                      },\n                    };\n                  });\n                  return {\n                    description: attr.description,\n                    type: nullableIf(\n                      GraphQLNonNull,\n                      !attr.isNotNull &&\n                        !attr.type.domainIsNotNull &&\n                        !attr.tags.notNull,\n                      ReturnType\n                    ),\n                    resolve: (data, _args, _context, _resolveInfo) => {\n                      return pg2gql(data[fieldName], attr.type);\n                    },\n                  };\n                },\n                { pgFieldIntrospection: attr }\n              ),\n            },\n            `Adding field for ${describePgEntity(\n              attr\n            )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n              attr,\n              {\n                name: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n        `Adding columns to '${describePgEntity(table)}'`\n      );\n    },\n    [\"PgColumns\"]\n  );\n  builder.hook(\n    \"GraphQLInputObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        graphql: { GraphQLString, GraphQLNonNull },\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      const {\n        scope: {\n          isPgRowType,\n          isPgCompoundType,\n          isPgPatch,\n          isPgBaseInput,\n          pgIntrospection: table,\n          pgAddSubfield,\n        },\n        fieldWithHooks,\n      } = context;\n      if (\n        !(isPgRowType || isPgCompoundType) ||\n        !table ||\n        table.kind !== \"class\"\n      ) {\n        return fields;\n      }\n      return extend(\n        fields,\n        table.attributes.reduce((memo, attr) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!pgColumnFilter(attr, build, context)) return memo;\n          const action = isPgBaseInput\n            ? \"base\"\n            : isPgPatch\n              ? \"update\"\n              : \"create\";\n          if (omit(attr, action)) return memo;\n          if (attr.identity === \"a\") return memo;\n\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on input class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                pgAddSubfield(\n                  fieldName,\n                  attr.name,\n                  attr.type,\n                  {\n                    description: attr.description,\n                    type: nullableIf(\n                      GraphQLNonNull,\n                      isPgBaseInput ||\n                        isPgPatch ||\n                        (!attr.isNotNull &&\n                          (!attr.type.domainIsNotNull ||\n                            attr.type.domainHasDefault) &&\n                          !attr.tags.notNull) ||\n                        attr.hasDefault ||\n                        attr.identity === \"d\",\n                      pgGetGqlInputTypeByTypeIdAndModifier(\n                        attr.typeId,\n                        attr.typeModifier\n                      ) || GraphQLString\n                    ),\n                  },\n                  attr.typeModifier\n                ),\n                { pgFieldIntrospection: attr }\n              ),\n            },\n            `Adding input object field for ${describePgEntity(\n              attr\n            )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n              attr,\n              {\n                name: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n        `Adding columns to input object for ${describePgEntity(table)}`\n      );\n    },\n    [\"PgColumns\"]\n  );\n}: Plugin);\n"]}