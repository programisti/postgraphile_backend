{"version":3,"sources":["../../src/plugins/PgRowNode.js"],"names":["PgRowNode","builder","subscriptions","hook","object","build","context","addNodeFetcherForTypeName","pgSql","sql","gql2pg","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isPgRowType","pgIntrospection","table","namespace","sqlFullTableName","identifier","name","primaryKeyConstraint","primaryKeys","keyAttributes","data","identifiers","resolveContext","parsedResolveInfoFragment","ReturnType","resolveData","resolveInfo","pgClient","liveRecord","rootValue","length","Error","query","undefined","useAsterisk","queryBuilder","selectIdentifiers","forEach","key","idx","where","fragment","getTableAlias","type","typeModifier","text","values","compile","debugSql","enabled","rows","row","__identifiers","fields","nodeIdFieldName","getTypeAndIdentifiersFromNodeId","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","graphql","GraphQLNonNull","GraphQLID","inflection","describePgEntity","sqlCommentByAddingTags","isRootQuery","fieldWithHooks","class","reduce","memo","TableType","id","fieldName","tableNode","getDataFromParsedResolveInfoFragment","description","args","resolve","parent","nodeId","Type","e","isPgNodeQuery","pgFieldIntrospection"],"mappings":";;;;;;AAEA;;;;;;kBAEgB,eAAeA,SAAf,CAAyBC,OAAzB,EAAkC,EAAEC,aAAF,EAAlC,EAAqD;AACnED,UAAQE,IAAR,CACE,mBADF,EAEE,CAACC,MAAD,EAASC,KAAT,EAAgBC,OAAhB,KAA4B;AAC1B,UAAM;AACJC,+BADI;AAEJC,aAAOC,GAFH;AAGJC,YAHI;AAIJC,8BAAwBC,oBAJpB;AAKJC,cAAQC;AALJ,QAMFT,KANJ;AAOA,UAAM;AACJU,aAAO,EAAEC,WAAF,EAAeC,iBAAiBC,KAAhC;AADH,QAEFZ,OAFJ;;AAIA,QAAI,CAACC,yBAAL,EAAgC;AAC9B;AACA,aAAOH,MAAP;AACD;AACD,QAAI,CAACY,WAAD,IAAgB,CAACE,MAAMC,SAAvB,IAAoCL,KAAKI,KAAL,EAAY,MAAZ,CAAxC,EAA6D;AAC3D,aAAOd,MAAP;AACD;AACD,UAAMgB,mBAAmBX,IAAIY,UAAJ,CAAeH,MAAMC,SAAN,CAAgBG,IAA/B,EAAqCJ,MAAMI,IAA3C,CAAzB;AACA,UAAMC,uBAAuBL,MAAMK,oBAAnC;AACA,QAAI,CAACA,oBAAL,EAA2B;AACzB,aAAOnB,MAAP;AACD;AACD,UAAMoB,cACJD,wBAAwBA,qBAAqBE,aAD/C;;AAGAlB,8BACEH,OAAOkB,IADT,EAEE,OACEI,IADF,EAEEC,WAFF,EAGEC,cAHF,EAIEC,yBAJF,EAKEC,UALF,EAMEC,WANF,EAOEC,WAPF,KAQK;AACH,YAAM,EAAEC,QAAF,KAAeL,cAArB;AACA,YAAMM,aACJF,eACAA,YAAYG,SADZ,IAEAH,YAAYG,SAAZ,CAAsBD,UAHxB;AAIA,UAAIP,YAAYS,MAAZ,KAAuBZ,YAAYY,MAAvC,EAA+C;AAC7C,cAAM,IAAIC,KAAJ,CAAU,YAAV,CAAN;AACD;AACD,YAAMC,QAAQ1B,qBACZQ,gBADY,EAEZmB,SAFY,EAGZR,WAHY,EAIZ;AACES,qBAAa,KADf,CACsB;AADtB,OAJY,EAOZC,gBAAgB;AACd,YAAIvC,iBAAiBgB,MAAMK,oBAA3B,EAAiD;AAC/CkB,uBAAaC,iBAAb,CAA+BxB,KAA/B;AACD;AACDM,oBAAYmB,OAAZ,CAAoB,CAACC,GAAD,EAAMC,GAAN,KAAc;AAChCJ,uBAAaK,KAAb,CACErC,IAAIsC,QAAS,GAAEN,aAAaO,aAAb,EAA6B,IAAGvC,IAAIY,UAAJ,CAC7CuB,IAAItB,IADyC,CAE7C,MAAKZ,OACLiB,YAAYkB,GAAZ,CADK,EAELrB,YAAYqB,GAAZ,EAAiBI,IAFZ,EAGLzB,YAAYqB,GAAZ,EAAiBK,YAHZ,CAIL,EAPJ;AASD,SAVD;AAWD,OAtBW,EAuBZtB,cAvBY,EAwBZI,eAAeA,YAAYG,SAxBf,CAAd;AA0BA,YAAM,EAAEgB,IAAF,EAAQC,MAAR,KAAmB3C,IAAI4C,OAAJ,CAAYf,KAAZ,CAAzB;AACA,UAAIgB,mBAASC,OAAb,EAAsB,wBAASJ,IAAT;AACtB,YAAM;AACJK,cAAM,CAACC,GAAD;AADF,UAEF,MAAMxB,SAASK,KAAT,CAAea,IAAf,EAAqBC,MAArB,CAFV;AAGA,UAAIlD,iBAAiBgC,UAAjB,IAA+BuB,GAAnC,EAAwC;AACtCvB,mBAAW,IAAX,EAAiBhB,KAAjB,EAAwBuC,IAAIC,aAA5B;AACD;AACD,aAAOD,GAAP;AACD,KAtDH;AAwDA,WAAOrD,MAAP;AACD,GAtFH,EAuFE,CAAC,WAAD,CAvFF;;AA0FAH,UAAQE,IAAR,CACE,0BADF,EAEE,CAACwD,MAAD,EAAStD,KAAT,EAAgBC,OAAhB,KAA4B;AAC1B,UAAM;AACJsD,qBADI;AAEJC,qCAFI;AAGJC,YAHI;AAIJC,sBAJI;AAKJC,qCALI;AAMJC,oCAA8BC,0BAN1B;AAOJ1D,aAAOC,GAPH;AAQJC,YARI;AASJyD,eAAS,EAAEC,cAAF,EAAkBC,SAAlB,EATL;AAUJC,gBAVI;AAWJ3D,8BAAwBC,oBAXpB;AAYJC,cAAQC,IAZJ;AAaJyD,sBAbI;AAcJC;AAdI,QAeFnE,KAfJ;AAgBA,UAAM;AACJU,aAAO,EAAE0D,WAAF,EADH;AAEJC;AAFI,QAGFpE,OAHJ;;AAKA,QAAI,CAACmE,WAAD,IAAgB,CAACb,eAArB,EAAsC;AACpC,aAAOD,MAAP;AACD;;AAED,WAAOG,OACLH,MADK,EAELO,2BAA2BS,KAA3B,CAAiCC,MAAjC,CAAwC,CAACC,IAAD,EAAO3D,KAAP,KAAiB;AACvD;AACA,UAAI,CAACA,MAAMC,SAAX,EAAsB,OAAO0D,IAAP;AACtB,UAAI/D,KAAKI,KAAL,EAAY,MAAZ,CAAJ,EAAyB,OAAO2D,IAAP;;AAEzB,YAAMC,YAAYd,gCAChB9C,MAAM+B,IAAN,CAAW8B,EADK,EAEhB,IAFgB,CAAlB;AAIA,YAAM3D,mBAAmBX,IAAIY,UAAJ,CACvBH,MAAMC,SAAN,CAAgBG,IADO,EAEvBJ,MAAMI,IAFiB,CAAzB;AAIA,UAAIwD,SAAJ,EAAe;AACb,cAAMvD,uBAAuBL,MAAMK,oBAAnC;AACA,YAAI,CAACA,oBAAL,EAA2B;AACzB,iBAAOsD,IAAP;AACD;AACD,cAAMrD,cACJD,wBAAwBA,qBAAqBE,aAD/C;AAEA,cAAMuD,YAAYV,WAAWW,SAAX,CAAqB/D,KAArB,CAAlB;AACA2D,eAAOf,OACLe,IADK,EAEL;AACE,WAACG,SAAD,GAAaN,eACXM,SADW,EAEX,CAAC,EAAEE,oCAAF,EAAD,KAA8C;AAC5C,mBAAO;AACLC,2BAAc,oBACZL,UAAUxD,IACX,sCAHI;AAIL2B,oBAAM6B,SAJD;AAKLM,oBAAM;AACJ,iBAACxB,eAAD,GAAmB;AACjBuB,+BAAc,iEACZL,UAAUxD,IACX,KAHgB;AAIjB2B,wBAAM,IAAImB,cAAJ,CAAmBC,SAAnB;AAJW;AADf,eALD;AAaL,oBAAMgB,OAAN,CAAcC,MAAd,EAAsBF,IAAtB,EAA4BxD,cAA5B,EAA4CI,WAA5C,EAAyD;AACvD,sBAAM,EAAEC,QAAF,KAAeL,cAArB;AACA,sBAAMM,aACJF,YAAYG,SAAZ,IACAH,YAAYG,SAAZ,CAAsBD,UAFxB;AAGA,sBAAMqD,SAASH,KAAKxB,eAAL,CAAf;AACA,oBAAI;AACF,wBAAM;AACJ4B,wBADI;AAEJ7D;AAFI,sBAGFkC,gCAAgC0B,MAAhC,CAHJ;AAIA,sBAAIC,SAASV,SAAb,EAAwB;AACtB,0BAAM,IAAIzC,KAAJ,CAAU,iBAAV,CAAN;AACD;AACD,sBAAIV,YAAYS,MAAZ,KAAuBZ,YAAYY,MAAvC,EAA+C;AAC7C,0BAAM,IAAIC,KAAJ,CAAU,YAAV,CAAN;AACD;;AAED,wBAAMR,4BAA4BkC,iBAChC/B,WADgC,CAAlC;AAGAH,4CAA0BuD,IAA1B,GAAiCA,IAAjC,CAfE,CAeqC;AACvC,wBAAMrD,cAAcmD,qCAClBrD,yBADkB,EAElBiD,SAFkB,CAApB;AAIA,wBAAMxC,QAAQ1B,qBACZQ,gBADY,EAEZmB,SAFY,EAGZR,WAHY,EAIZ;AACES,iCAAa,KADf,CACsB;AADtB,mBAJY,EAOZC,gBAAgB;AACd,wBAAIvC,iBAAiBgB,MAAMK,oBAA3B,EAAiD;AAC/CkB,mCAAaC,iBAAb,CAA+BxB,KAA/B;AACD;AACDM,gCAAYmB,OAAZ,CAAoB,CAACC,GAAD,EAAMC,GAAN,KAAc;AAChCJ,mCAAaK,KAAb,CACErC,IAAIsC,QAAS,GAAEN,aAAaO,aAAb,EAA6B,IAAGvC,IAAIY,UAAJ,CAC7CuB,IAAItB,IADyC,CAE7C,MAAKZ,OACLiB,YAAYkB,GAAZ,CADK,EAELrB,YAAYqB,GAAZ,EAAiBI,IAFZ,EAGLzB,YAAYqB,GAAZ,EAAiBK,YAHZ,CAIL,EAPJ;AASD,qBAVD;AAWD,mBAtBW,EAuBZtB,cAvBY,EAwBZI,YAAYG,SAxBA,CAAd;AA0BA,wBAAM,EAAEgB,IAAF,EAAQC,MAAR,KAAmB3C,IAAI4C,OAAJ,CAAYf,KAAZ,CAAzB;AACA,sBAAIgB,mBAASC,OAAb,EAAsB,wBAASJ,IAAT;AACtB,wBAAM;AACJK,0BAAM,CAACC,GAAD;AADF,sBAEF,MAAMxB,SAASK,KAAT,CAAea,IAAf,EAAqBC,MAArB,CAFV;AAGA,sBAAIlB,cAAcuB,GAAlB,EAAuB;AACrBvB,+BAAW,IAAX,EAAiBhB,KAAjB,EAAwBuC,IAAIC,aAA5B;AACD;AACD,yBAAOD,GAAP;AACD,iBAvDD,CAuDE,OAAOgC,CAAP,EAAU;AACV,yBAAO,IAAP;AACD;AACF;AA7EI,aAAP;AA+ED,WAlFU,EAmFX;AACEC,2BAAe,IADjB;AAEEC,kCAAsBzE;AAFxB,WAnFW;AADf,SAFK,EA4FJ,sDAAqDqD,iBACpDrD,KADoD,CAEpD,yCAAwCsD,uBACxCtD,KADwC,EAExC,EAAEI,MAAM,aAAR,EAFwC,CAGxC,EAjGG,CAAP;AAmGD;AACD,aAAOuD,IAAP;AACD,KA1HD,EA0HG,EA1HH,CAFK,EA6HJ,mDA7HI,CAAP;AA+HD,GA3JH,EA4JE,CAAC,WAAD,CA5JF;AA8JD,C","file":"PgRowNode.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowNode(builder, { subscriptions }) {\n  builder.hook(\n    \"GraphQLObjectType\",\n    (object, build, context) => {\n      const {\n        addNodeFetcherForTypeName,\n        pgSql: sql,\n        gql2pg,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n      } = build;\n      const {\n        scope: { isPgRowType, pgIntrospection: table },\n      } = context;\n\n      if (!addNodeFetcherForTypeName) {\n        // Node plugin must be disabled.\n        return object;\n      }\n      if (!isPgRowType || !table.namespace || omit(table, \"read\")) {\n        return object;\n      }\n      const sqlFullTableName = sql.identifier(table.namespace.name, table.name);\n      const primaryKeyConstraint = table.primaryKeyConstraint;\n      if (!primaryKeyConstraint) {\n        return object;\n      }\n      const primaryKeys =\n        primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n\n      addNodeFetcherForTypeName(\n        object.name,\n        async (\n          data,\n          identifiers,\n          resolveContext,\n          parsedResolveInfoFragment,\n          ReturnType,\n          resolveData,\n          resolveInfo\n        ) => {\n          const { pgClient } = resolveContext;\n          const liveRecord =\n            resolveInfo &&\n            resolveInfo.rootValue &&\n            resolveInfo.rootValue.liveRecord;\n          if (identifiers.length !== primaryKeys.length) {\n            throw new Error(\"Invalid ID\");\n          }\n          const query = queryFromResolveData(\n            sqlFullTableName,\n            undefined,\n            resolveData,\n            {\n              useAsterisk: false, // Because it's only a single relation, no need\n            },\n            queryBuilder => {\n              if (subscriptions && table.primaryKeyConstraint) {\n                queryBuilder.selectIdentifiers(table);\n              }\n              primaryKeys.forEach((key, idx) => {\n                queryBuilder.where(\n                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                    key.name\n                  )} = ${gql2pg(\n                    identifiers[idx],\n                    primaryKeys[idx].type,\n                    primaryKeys[idx].typeModifier\n                  )}`\n                );\n              });\n            },\n            resolveContext,\n            resolveInfo && resolveInfo.rootValue\n          );\n          const { text, values } = sql.compile(query);\n          if (debugSql.enabled) debugSql(text);\n          const {\n            rows: [row],\n          } = await pgClient.query(text, values);\n          if (subscriptions && liveRecord && row) {\n            liveRecord(\"pg\", table, row.__identifiers);\n          }\n          return row;\n        }\n      );\n      return object;\n    },\n    [\"PgRowNode\"]\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        nodeIdFieldName,\n        getTypeAndIdentifiersFromNodeId,\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        gql2pg,\n        graphql: { GraphQLNonNull, GraphQLID },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      const {\n        scope: { isRootQuery },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootQuery || !nodeIdFieldName) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        introspectionResultsByKind.class.reduce((memo, table) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!table.namespace) return memo;\n          if (omit(table, \"read\")) return memo;\n\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const primaryKeyConstraint = table.primaryKeyConstraint;\n            if (!primaryKeyConstraint) {\n              return memo;\n            }\n            const primaryKeys =\n              primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n            const fieldName = inflection.tableNode(table);\n            memo = extend(\n              memo,\n              {\n                [fieldName]: fieldWithHooks(\n                  fieldName,\n                  ({ getDataFromParsedResolveInfoFragment }) => {\n                    return {\n                      description: `Reads a single \\`${\n                        TableType.name\n                      }\\` using its globally unique \\`ID\\`.`,\n                      type: TableType,\n                      args: {\n                        [nodeIdFieldName]: {\n                          description: `The globally unique \\`ID\\` to be used in selecting a single \\`${\n                            TableType.name\n                          }\\`.`,\n                          type: new GraphQLNonNull(GraphQLID),\n                        },\n                      },\n                      async resolve(parent, args, resolveContext, resolveInfo) {\n                        const { pgClient } = resolveContext;\n                        const liveRecord =\n                          resolveInfo.rootValue &&\n                          resolveInfo.rootValue.liveRecord;\n                        const nodeId = args[nodeIdFieldName];\n                        try {\n                          const {\n                            Type,\n                            identifiers,\n                          } = getTypeAndIdentifiersFromNodeId(nodeId);\n                          if (Type !== TableType) {\n                            throw new Error(\"Mismatched type\");\n                          }\n                          if (identifiers.length !== primaryKeys.length) {\n                            throw new Error(\"Invalid ID\");\n                          }\n\n                          const parsedResolveInfoFragment = parseResolveInfo(\n                            resolveInfo\n                          );\n                          parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                          const resolveData = getDataFromParsedResolveInfoFragment(\n                            parsedResolveInfoFragment,\n                            TableType\n                          );\n                          const query = queryFromResolveData(\n                            sqlFullTableName,\n                            undefined,\n                            resolveData,\n                            {\n                              useAsterisk: false, // Because it's only a single relation, no need\n                            },\n                            queryBuilder => {\n                              if (subscriptions && table.primaryKeyConstraint) {\n                                queryBuilder.selectIdentifiers(table);\n                              }\n                              primaryKeys.forEach((key, idx) => {\n                                queryBuilder.where(\n                                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                    key.name\n                                  )} = ${gql2pg(\n                                    identifiers[idx],\n                                    primaryKeys[idx].type,\n                                    primaryKeys[idx].typeModifier\n                                  )}`\n                                );\n                              });\n                            },\n                            resolveContext,\n                            resolveInfo.rootValue\n                          );\n                          const { text, values } = sql.compile(query);\n                          if (debugSql.enabled) debugSql(text);\n                          const {\n                            rows: [row],\n                          } = await pgClient.query(text, values);\n                          if (liveRecord && row) {\n                            liveRecord(\"pg\", table, row.__identifiers);\n                          }\n                          return row;\n                        } catch (e) {\n                          return null;\n                        }\n                      },\n                    };\n                  },\n                  {\n                    isPgNodeQuery: true,\n                    pgFieldIntrospection: table,\n                  }\n                ),\n              },\n              `Adding row by globally unique identifier field for ${describePgEntity(\n                table\n              )}. You can rename this table via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                { name: \"newNameHere\" }\n              )}`\n            );\n          }\n          return memo;\n        }, {}),\n        `Adding \"row by node ID\" fields to root Query type`\n      );\n    },\n    [\"PgRowNode\"]\n  );\n}: Plugin);\n"]}