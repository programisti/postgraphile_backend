{"version":3,"sources":["../../src/plugins/PgRowNode.js"],"names":["PgRowNode","builder","subscriptions","hook","object","build","context","addNodeFetcherForTypeName","pgSql","sql","gql2pg","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isPgRowType","pgIntrospection","table","namespace","sqlFullTableName","identifier","name","primaryKeyConstraint","primaryKeys","keyAttributes","data","identifiers","resolveContext","parsedResolveInfoFragment","ReturnType","resolveData","pgClient","liveRecord","length","Error","query","undefined","useAsterisk","queryBuilder","selectIdentifiers","forEach","key","idx","where","fragment","getTableAlias","type","typeModifier","text","values","compile","debugSql","enabled","rows","row","__identifiers","fields","nodeIdFieldName","getTypeAndIdentifiersFromNodeId","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","graphql","GraphQLNonNull","GraphQLID","inflection","describePgEntity","sqlCommentByAddingTags","isRootQuery","fieldWithHooks","class","reduce","memo","TableType","id","fieldName","tableNode","getDataFromParsedResolveInfoFragment","description","args","resolve","parent","resolveInfo","nodeId","Type","e","isPgNodeQuery","pgFieldIntrospection"],"mappings":";;;;;;AAEA;;;;;;kBAEgB,eAAeA,SAAf,CAAyBC,OAAzB,EAAkC,EAAEC,aAAF,EAAlC,EAAqD;AACnED,UAAQE,IAAR,CACE,mBADF,EAEE,CAACC,MAAD,EAASC,KAAT,EAAgBC,OAAhB,KAA4B;AAC1B,UAAM;AACJC,+BADI;AAEJC,aAAOC,GAFH;AAGJC,YAHI;AAIJC,8BAAwBC,oBAJpB;AAKJC,cAAQC;AALJ,QAMFT,KANJ;AAOA,UAAM;AACJU,aAAO,EAAEC,WAAF,EAAeC,iBAAiBC,KAAhC;AADH,QAEFZ,OAFJ;;AAIA,QAAI,CAACC,yBAAL,EAAgC;AAC9B;AACA,aAAOH,MAAP;AACD;AACD,QAAI,CAACY,WAAD,IAAgB,CAACE,MAAMC,SAAvB,IAAoCL,KAAKI,KAAL,EAAY,MAAZ,CAAxC,EAA6D;AAC3D,aAAOd,MAAP;AACD;AACD,UAAMgB,mBAAmBX,IAAIY,UAAJ,CAAeH,MAAMC,SAAN,CAAgBG,IAA/B,EAAqCJ,MAAMI,IAA3C,CAAzB;AACA,UAAMC,uBAAuBL,MAAMK,oBAAnC;AACA,QAAI,CAACA,oBAAL,EAA2B;AACzB,aAAOnB,MAAP;AACD;AACD,UAAMoB,cACJD,wBAAwBA,qBAAqBE,aAD/C;;AAGAlB,8BACEH,OAAOkB,IADT,EAEE,OACEI,IADF,EAEEC,WAFF,EAGEC,cAHF,EAIEC,yBAJF,EAKEC,UALF,EAMEC,WANF,KAOK;AACH,YAAM,EAAEC,QAAF,EAAYC,UAAZ,KAA2BL,cAAjC;AACA,UAAID,YAAYO,MAAZ,KAAuBV,YAAYU,MAAvC,EAA+C;AAC7C,cAAM,IAAIC,KAAJ,CAAU,YAAV,CAAN;AACD;AACD,YAAMC,QAAQxB,qBACZQ,gBADY,EAEZiB,SAFY,EAGZN,WAHY,EAIZ;AACEO,qBAAa,KADf,CACsB;AADtB,OAJY,EAOZC,gBAAgB;AACd,YAAIrC,iBAAiBgB,MAAMK,oBAA3B,EAAiD;AAC/CgB,uBAAaC,iBAAb,CAA+BtB,KAA/B;AACD;AACDM,oBAAYiB,OAAZ,CAAoB,CAACC,GAAD,EAAMC,GAAN,KAAc;AAChCJ,uBAAaK,KAAb,CACEnC,IAAIoC,QAAS,GAAEN,aAAaO,aAAb,EAA6B,IAAGrC,IAAIY,UAAJ,CAC7CqB,IAAIpB,IADyC,CAE7C,MAAKZ,OACLiB,YAAYgB,GAAZ,CADK,EAELnB,YAAYmB,GAAZ,EAAiBI,IAFZ,EAGLvB,YAAYmB,GAAZ,EAAiBK,YAHZ,CAIL,EAPJ;AASD,SAVD;AAWD,OAtBW,EAuBZpB,cAvBY,CAAd;AAyBA,YAAM,EAAEqB,IAAF,EAAQC,MAAR,KAAmBzC,IAAI0C,OAAJ,CAAYf,KAAZ,CAAzB;AACA,UAAIgB,mBAASC,OAAb,EAAsB,wBAASJ,IAAT;AACtB,YAAM;AACJK,cAAM,CAACC,GAAD;AADF,UAEF,MAAMvB,SAASI,KAAT,CAAea,IAAf,EAAqBC,MAArB,CAFV;AAGA,UAAIhD,iBAAiB+B,UAAjB,IAA+BsB,GAAnC,EAAwC;AACtCtB,mBAAW,IAAX,EAAiBf,KAAjB,EAAwBqC,IAAIC,aAA5B;AACD;AACD,aAAOD,GAAP;AACD,KAhDH;AAkDA,WAAOnD,MAAP;AACD,GAhFH,EAiFE,CAAC,WAAD,CAjFF;;AAoFAH,UAAQE,IAAR,CACE,0BADF,EAEE,CAACsD,MAAD,EAASpD,KAAT,EAAgBC,OAAhB,KAA4B;AAC1B,UAAM;AACJoD,qBADI;AAEJC,qCAFI;AAGJC,YAHI;AAIJC,sBAJI;AAKJC,qCALI;AAMJC,oCAA8BC,0BAN1B;AAOJxD,aAAOC,GAPH;AAQJC,YARI;AASJuD,eAAS,EAAEC,cAAF,EAAkBC,SAAlB,EATL;AAUJC,gBAVI;AAWJzD,8BAAwBC,oBAXpB;AAYJC,cAAQC,IAZJ;AAaJuD,sBAbI;AAcJC;AAdI,QAeFjE,KAfJ;AAgBA,UAAM;AACJU,aAAO,EAAEwD,WAAF,EADH;AAEJC;AAFI,QAGFlE,OAHJ;;AAKA,QAAI,CAACiE,WAAD,IAAgB,CAACb,eAArB,EAAsC;AACpC,aAAOD,MAAP;AACD;;AAED,WAAOG,OACLH,MADK,EAELO,2BAA2BS,KAA3B,CAAiCC,MAAjC,CAAwC,CAACC,IAAD,EAAOzD,KAAP,KAAiB;AACvD;AACA,UAAI,CAACA,MAAMC,SAAX,EAAsB,OAAOwD,IAAP;AACtB,UAAI7D,KAAKI,KAAL,EAAY,MAAZ,CAAJ,EAAyB,OAAOyD,IAAP;;AAEzB,YAAMC,YAAYd,gCAChB5C,MAAM6B,IAAN,CAAW8B,EADK,EAEhB,IAFgB,CAAlB;AAIA,YAAMzD,mBAAmBX,IAAIY,UAAJ,CACvBH,MAAMC,SAAN,CAAgBG,IADO,EAEvBJ,MAAMI,IAFiB,CAAzB;AAIA,UAAIsD,SAAJ,EAAe;AACb,cAAMrD,uBAAuBL,MAAMK,oBAAnC;AACA,YAAI,CAACA,oBAAL,EAA2B;AACzB,iBAAOoD,IAAP;AACD;AACD,cAAMnD,cACJD,wBAAwBA,qBAAqBE,aAD/C;AAEA,cAAMqD,YAAYV,WAAWW,SAAX,CAAqB7D,KAArB,CAAlB;AACAyD,eAAOf,OACLe,IADK,EAEL;AACE,WAACG,SAAD,GAAaN,eACXM,SADW,EAEX,CAAC,EAAEE,oCAAF,EAAD,KAA8C;AAC5C,mBAAO;AACLC,2BAAc,oBACZL,UAAUtD,IACX,sCAHI;AAILyB,oBAAM6B,SAJD;AAKLM,oBAAM;AACJ,iBAACxB,eAAD,GAAmB;AACjBuB,+BAAc,iEACZL,UAAUtD,IACX,KAHgB;AAIjByB,wBAAM,IAAImB,cAAJ,CAAmBC,SAAnB;AAJW;AADf,eALD;AAaL,oBAAMgB,OAAN,CAAcC,MAAd,EAAsBF,IAAtB,EAA4BtD,cAA5B,EAA4CyD,WAA5C,EAAyD;AACvD,sBAAM,EAAErD,QAAF,EAAYC,UAAZ,KAA2BL,cAAjC;AACA,sBAAM0D,SAASJ,KAAKxB,eAAL,CAAf;AACA,oBAAI;AACF,wBAAM;AACJ6B,wBADI;AAEJ5D;AAFI,sBAGFgC,gCAAgC2B,MAAhC,CAHJ;AAIA,sBAAIC,SAASX,SAAb,EAAwB;AACtB,0BAAM,IAAIzC,KAAJ,CAAU,iBAAV,CAAN;AACD;AACD,sBAAIR,YAAYO,MAAZ,KAAuBV,YAAYU,MAAvC,EAA+C;AAC7C,0BAAM,IAAIC,KAAJ,CAAU,YAAV,CAAN;AACD;;AAED,wBAAMN,4BAA4BgC,iBAChCwB,WADgC,CAAlC;AAGAxD,4CAA0BqD,IAA1B,GAAiCA,IAAjC,CAfE,CAeqC;AACvC,wBAAMnD,cAAciD,qCAClBnD,yBADkB,EAElB+C,SAFkB,CAApB;AAIA,wBAAMxC,QAAQxB,qBACZQ,gBADY,EAEZiB,SAFY,EAGZN,WAHY,EAIZ;AACEO,iCAAa,KADf,CACsB;AADtB,mBAJY,EAOZC,gBAAgB;AACd,wBAAIrC,iBAAiBgB,MAAMK,oBAA3B,EAAiD;AAC/CgB,mCAAaC,iBAAb,CAA+BtB,KAA/B;AACD;AACDM,gCAAYiB,OAAZ,CAAoB,CAACC,GAAD,EAAMC,GAAN,KAAc;AAChCJ,mCAAaK,KAAb,CACEnC,IAAIoC,QAAS,GAAEN,aAAaO,aAAb,EAA6B,IAAGrC,IAAIY,UAAJ,CAC7CqB,IAAIpB,IADyC,CAE7C,MAAKZ,OACLiB,YAAYgB,GAAZ,CADK,EAELnB,YAAYmB,GAAZ,EAAiBI,IAFZ,EAGLvB,YAAYmB,GAAZ,EAAiBK,YAHZ,CAIL,EAPJ;AASD,qBAVD;AAWD,mBAtBW,EAuBZpB,cAvBY,CAAd;AAyBA,wBAAM,EAAEqB,IAAF,EAAQC,MAAR,KAAmBzC,IAAI0C,OAAJ,CAAYf,KAAZ,CAAzB;AACA,sBAAIgB,mBAASC,OAAb,EAAsB,wBAASJ,IAAT;AACtB,wBAAM;AACJK,0BAAM,CAACC,GAAD;AADF,sBAEF,MAAMvB,SAASI,KAAT,CAAea,IAAf,EAAqBC,MAArB,CAFV;AAGA,sBAAIjB,cAAcsB,GAAlB,EAAuB;AACrBtB,+BAAW,IAAX,EAAiBf,KAAjB,EAAwBqC,IAAIC,aAA5B;AACD;AACD,yBAAOD,GAAP;AACD,iBAtDD,CAsDE,OAAOiC,CAAP,EAAU;AACV,yBAAO,IAAP;AACD;AACF;AAzEI,aAAP;AA2ED,WA9EU,EA+EX;AACEC,2BAAe,IADjB;AAEEC,kCAAsBxE;AAFxB,WA/EW;AADf,SAFK,EAwFJ,sDAAqDmD,iBACpDnD,KADoD,CAEpD,yCAAwCoD,uBACxCpD,KADwC,EAExC,EAAEI,MAAM,aAAR,EAFwC,CAGxC,EA7FG,CAAP;AA+FD;AACD,aAAOqD,IAAP;AACD,KAtHD,EAsHG,EAtHH,CAFK,EAyHJ,mDAzHI,CAAP;AA2HD,GAvJH,EAwJE,CAAC,WAAD,CAxJF;AA0JD,C","file":"PgRowNode.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowNode(builder, { subscriptions }) {\n  builder.hook(\n    \"GraphQLObjectType\",\n    (object, build, context) => {\n      const {\n        addNodeFetcherForTypeName,\n        pgSql: sql,\n        gql2pg,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n      } = build;\n      const {\n        scope: { isPgRowType, pgIntrospection: table },\n      } = context;\n\n      if (!addNodeFetcherForTypeName) {\n        // Node plugin must be disabled.\n        return object;\n      }\n      if (!isPgRowType || !table.namespace || omit(table, \"read\")) {\n        return object;\n      }\n      const sqlFullTableName = sql.identifier(table.namespace.name, table.name);\n      const primaryKeyConstraint = table.primaryKeyConstraint;\n      if (!primaryKeyConstraint) {\n        return object;\n      }\n      const primaryKeys =\n        primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n\n      addNodeFetcherForTypeName(\n        object.name,\n        async (\n          data,\n          identifiers,\n          resolveContext,\n          parsedResolveInfoFragment,\n          ReturnType,\n          resolveData\n        ) => {\n          const { pgClient, liveRecord } = resolveContext;\n          if (identifiers.length !== primaryKeys.length) {\n            throw new Error(\"Invalid ID\");\n          }\n          const query = queryFromResolveData(\n            sqlFullTableName,\n            undefined,\n            resolveData,\n            {\n              useAsterisk: false, // Because it's only a single relation, no need\n            },\n            queryBuilder => {\n              if (subscriptions && table.primaryKeyConstraint) {\n                queryBuilder.selectIdentifiers(table);\n              }\n              primaryKeys.forEach((key, idx) => {\n                queryBuilder.where(\n                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                    key.name\n                  )} = ${gql2pg(\n                    identifiers[idx],\n                    primaryKeys[idx].type,\n                    primaryKeys[idx].typeModifier\n                  )}`\n                );\n              });\n            },\n            resolveContext\n          );\n          const { text, values } = sql.compile(query);\n          if (debugSql.enabled) debugSql(text);\n          const {\n            rows: [row],\n          } = await pgClient.query(text, values);\n          if (subscriptions && liveRecord && row) {\n            liveRecord(\"pg\", table, row.__identifiers);\n          }\n          return row;\n        }\n      );\n      return object;\n    },\n    [\"PgRowNode\"]\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        nodeIdFieldName,\n        getTypeAndIdentifiersFromNodeId,\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        gql2pg,\n        graphql: { GraphQLNonNull, GraphQLID },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      const {\n        scope: { isRootQuery },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootQuery || !nodeIdFieldName) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        introspectionResultsByKind.class.reduce((memo, table) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!table.namespace) return memo;\n          if (omit(table, \"read\")) return memo;\n\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const primaryKeyConstraint = table.primaryKeyConstraint;\n            if (!primaryKeyConstraint) {\n              return memo;\n            }\n            const primaryKeys =\n              primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n            const fieldName = inflection.tableNode(table);\n            memo = extend(\n              memo,\n              {\n                [fieldName]: fieldWithHooks(\n                  fieldName,\n                  ({ getDataFromParsedResolveInfoFragment }) => {\n                    return {\n                      description: `Reads a single \\`${\n                        TableType.name\n                      }\\` using its globally unique \\`ID\\`.`,\n                      type: TableType,\n                      args: {\n                        [nodeIdFieldName]: {\n                          description: `The globally unique \\`ID\\` to be used in selecting a single \\`${\n                            TableType.name\n                          }\\`.`,\n                          type: new GraphQLNonNull(GraphQLID),\n                        },\n                      },\n                      async resolve(parent, args, resolveContext, resolveInfo) {\n                        const { pgClient, liveRecord } = resolveContext;\n                        const nodeId = args[nodeIdFieldName];\n                        try {\n                          const {\n                            Type,\n                            identifiers,\n                          } = getTypeAndIdentifiersFromNodeId(nodeId);\n                          if (Type !== TableType) {\n                            throw new Error(\"Mismatched type\");\n                          }\n                          if (identifiers.length !== primaryKeys.length) {\n                            throw new Error(\"Invalid ID\");\n                          }\n\n                          const parsedResolveInfoFragment = parseResolveInfo(\n                            resolveInfo\n                          );\n                          parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                          const resolveData = getDataFromParsedResolveInfoFragment(\n                            parsedResolveInfoFragment,\n                            TableType\n                          );\n                          const query = queryFromResolveData(\n                            sqlFullTableName,\n                            undefined,\n                            resolveData,\n                            {\n                              useAsterisk: false, // Because it's only a single relation, no need\n                            },\n                            queryBuilder => {\n                              if (subscriptions && table.primaryKeyConstraint) {\n                                queryBuilder.selectIdentifiers(table);\n                              }\n                              primaryKeys.forEach((key, idx) => {\n                                queryBuilder.where(\n                                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                    key.name\n                                  )} = ${gql2pg(\n                                    identifiers[idx],\n                                    primaryKeys[idx].type,\n                                    primaryKeys[idx].typeModifier\n                                  )}`\n                                );\n                              });\n                            },\n                            resolveContext\n                          );\n                          const { text, values } = sql.compile(query);\n                          if (debugSql.enabled) debugSql(text);\n                          const {\n                            rows: [row],\n                          } = await pgClient.query(text, values);\n                          if (liveRecord && row) {\n                            liveRecord(\"pg\", table, row.__identifiers);\n                          }\n                          return row;\n                        } catch (e) {\n                          return null;\n                        }\n                      },\n                    };\n                  },\n                  {\n                    isPgNodeQuery: true,\n                    pgFieldIntrospection: table,\n                  }\n                ),\n              },\n              `Adding row by globally unique identifier field for ${describePgEntity(\n                table\n              )}. You can rename this table via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                { name: \"newNameHere\" }\n              )}`\n            );\n          }\n          return memo;\n        }, {}),\n        `Adding \"row by node ID\" fields to root Query type`\n      );\n    },\n    [\"PgRowNode\"]\n  );\n}: Plugin);\n"]}