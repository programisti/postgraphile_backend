{"version":3,"sources":["../../src/plugins/PgTypesPlugin.js"],"names":["indent","str","replace","identity","value","parseCache","parseInterval","result","get","Object","freeze","set","PgTypesPlugin","builder","pgExtendedTypes","pgSkipHstore","disableIssue390Fix","hook","build","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgSql","sql","inflection","graphql","newWithHooks","args","addType","GraphQLNonNull","GraphQLString","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLList","GraphQLEnumType","GraphQLObjectType","GraphQLInputObjectType","GraphQLScalarType","isInputType","getNamedType","Kind","gqlTypeByTypeIdGenerator","gqlInputTypeByTypeIdGenerator","pgGqlTypeByTypeId","pgGqlInputTypeByTypeId","Error","gqlTypeByTypeIdAndModifier","assign","pgGqlTypeByTypeIdAndModifier","gqlInputTypeByTypeIdAndModifier","pgGqlInputTypeByTypeIdAndModifier","pg2GqlMapper","pg2gql","val","type","__isNull","id","map","domainBaseType","isPgArray","Array","isArray","namespaceName","name","v","arrayItemType","gql2pg","modifier","undefined","stack","e","console","warn","null","unmap","domainTypeModifier","fragment","join","identifier","makeIntervalFields","seconds","description","minutes","hours","days","months","years","GQLInterval","builtin","fields","isIntervalType","GQLIntervalInput","inputType","isIntervalInputType","stringType","serialize","String","parseValue","parseLiteral","ast","kind","STRING","BigFloat","BitString","rawTypes","tweakToJson","tweakToText","tweakToNumericText","pgTweaksByTypeIdAndModifer","pgTweaksByTypeId","reduce","memo","typeId","pgTweakFragmentForTypeAndModifier","typeModifier","resolveData","typeModifierKey","tweaker","domainBaseTypeModifier","error","process","env","NODE_ENV","SimpleDate","SimpleDatetime","SimpleTime","SimpleJSON","SimpleUUID","InetType","JSONType","UUIDType","DateType","DateTimeType","TimeType","Point","x","y","isPointType","PointInput","isPointInputType","oidLookup","oidInputLookup","jsonStringify","o","JSON","stringify","keys","parts","key","push","_","f","length","substr","split","parseFloat","depth","enforceGqlTypeByPgTypeId","find","t","reallyEnforceGqlTypeByPgTypeAndModifier","message","originalError","gqlType","gqlInputType","enumType","values","enumVariants","enumName","pgIntrospection","isPgEnumType","subtype","typeById","rangeSubTypeId","gqlRangeSubType","getGqlTypeByTypeIdAndModifier","Range","rangeType","RangeInput","RangeBound","rangeBoundType","inclusive","isPgRangeBoundType","pgSubtypeIntrospection","pgTypeModifier","RangeBoundInput","isPgRangeBoundInputType","start","end","isPgRangeType","isPgRangeInputType","lower","upper","lowerInclusive","upperInclusive","literal","domainBaseTypeId","baseType","baseInputType","create","domainType","category","arrayEntryOutputType","arrayItemTypeId","arrayEntryInputType","getGqlInputTypeByTypeIdAndModifier","useFallback","gen","Type","fallback","registerGqlTypeByTypeId","yieldToExisting","registerGqlInputTypeByTypeId","getGqlTypeByTypeId","getGqlInputTypeByTypeId","pgTweakFragmentForType","extend","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","hstoreType","hstoreExtension","extension","namespaceId","hstoreTypeName","GraphQLHStoreType","makeGraphQLHstoreType","hstoreStringify","isValidHstoreObject","obj","identityWithCheck","TypeError","parseValueLiteral","variables","INT","FLOAT","NULL","VARIABLE","OBJECT","field","GraphQLHStore","toHstoreString","encodeKeyValue"],"mappings":"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","file":"PgTypesPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nimport makeGraphQLJSONType from \"../GraphQLJSON\";\n\nimport rawParseInterval from \"postgres-interval\";\nimport LRU from \"lru-cache\";\n\nfunction indent(str) {\n  return \"  \" + str.replace(/\\n/g, \"\\n  \");\n}\n\nfunction identity(value) {\n  return value;\n}\n\nconst parseCache = LRU(500);\nfunction parseInterval(str) {\n  let result = parseCache.get(str);\n  if (!result) {\n    result = rawParseInterval(str);\n    Object.freeze(result);\n    parseCache.set(str, result);\n  }\n  return result;\n}\n\nexport default (function PgTypesPlugin(\n  builder,\n  {\n    pgExtendedTypes = true,\n    // Adding hstore support is technically a breaking change; this allows people to opt out easily:\n    pgSkipHstore = false,\n    disableIssue390Fix = false,\n  }\n) {\n  // XXX: most of this should be in an \"init\" hook, not a \"build\" hook\n  builder.hook(\n    \"build\",\n    build => {\n      const {\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgSql: sql,\n        inflection,\n        graphql,\n      } = build;\n\n      /*\n       * Note these do not do `foo.bind(build)` because they want to reference\n       * the *latest* value of foo (i.e. after all the build hooks run) rather\n       * than the current value of foo in this current hook.\n       *\n       * Also don't use this in your own code, only construct types *after* the\n       * build hook has completed (i.e. 'init' or later).\n       *\n       * TODO:v5: move this to the 'init' hook.\n       */\n      const newWithHooks = (...args) => build.newWithHooks(...args);\n      const addType = (...args) => build.addType(...args);\n\n      const {\n        GraphQLNonNull,\n        GraphQLString,\n        GraphQLInt,\n        GraphQLFloat,\n        GraphQLBoolean,\n        GraphQLList,\n        GraphQLEnumType,\n        GraphQLObjectType,\n        GraphQLInputObjectType,\n        GraphQLScalarType,\n        isInputType,\n        getNamedType,\n        Kind,\n      } = graphql;\n\n      const gqlTypeByTypeIdGenerator = {};\n      const gqlInputTypeByTypeIdGenerator = {};\n      if (build.pgGqlTypeByTypeId || build.pgGqlInputTypeByTypeId) {\n        // I don't expect anyone to receive this error, because I don't think anyone uses this interface.\n        throw new Error(\n          \"Sorry! This interface is no longer supported because it is not granular enough. It's not hard to port it to the new system - please contact Benjie and he'll walk you through it.\"\n        );\n      }\n      const gqlTypeByTypeIdAndModifier = Object.assign(\n        {},\n        build.pgGqlTypeByTypeIdAndModifier\n      );\n      const gqlInputTypeByTypeIdAndModifier = Object.assign(\n        {},\n        build.pgGqlInputTypeByTypeIdAndModifier\n      );\n      const pg2GqlMapper = {};\n      const pg2gql = (val, type) => {\n        if (val == null) {\n          return val;\n        }\n        if (val.__isNull) {\n          return null;\n        }\n        if (pg2GqlMapper[type.id]) {\n          return pg2GqlMapper[type.id].map(val);\n        } else if (type.domainBaseType) {\n          return pg2gql(val, type.domainBaseType);\n        } else if (type.isPgArray) {\n          if (!Array.isArray(val)) {\n            throw new Error(\n              `Expected array when converting PostgreSQL data into GraphQL; failing type: '${\n                type.namespaceName\n              }.${type.name}'`\n            );\n          }\n          return val.map(v => pg2gql(v, type.arrayItemType));\n        } else {\n          return val;\n        }\n      };\n      const gql2pg = (val, type, modifier) => {\n        if (modifier === undefined) {\n          let stack;\n          try {\n            throw new Error();\n          } catch (e) {\n            stack = e.stack;\n          }\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"gql2pg should be called with three arguments, the third being the type modifier (or `null`); \" +\n              (stack || \"\")\n          );\n          // Hack for backwards compatibility:\n          modifier = null;\n        }\n        if (val == null) {\n          return sql.null;\n        }\n        if (pg2GqlMapper[type.id]) {\n          return pg2GqlMapper[type.id].unmap(val, modifier);\n        } else if (type.domainBaseType) {\n          return gql2pg(val, type.domainBaseType, type.domainTypeModifier);\n        } else if (type.isPgArray) {\n          if (!Array.isArray(val)) {\n            throw new Error(\n              `Expected array when converting GraphQL data into PostgreSQL data; failing type: '${\n                type.namespaceName\n              }.${type.name}' (type: ${type === null ? \"null\" : typeof type})`\n            );\n          }\n          return sql.fragment`array[${sql.join(\n            val.map(v => gql2pg(v, type.arrayItemType, modifier)),\n            \", \"\n          )}]::${sql.identifier(type.namespaceName)}.${sql.identifier(\n            type.name\n          )}`;\n        } else {\n          return sql.value(val);\n        }\n      };\n\n      const makeIntervalFields = () => {\n        return {\n          seconds: {\n            description:\n              \"A quantity of seconds. This is the only non-integer field, as all the other fields will dump their overflow into a smaller unit of time. Intervals don’t have a smaller unit than seconds.\",\n            type: GraphQLFloat,\n          },\n          minutes: {\n            description: \"A quantity of minutes.\",\n            type: GraphQLInt,\n          },\n          hours: {\n            description: \"A quantity of hours.\",\n            type: GraphQLInt,\n          },\n          days: {\n            description: \"A quantity of days.\",\n            type: GraphQLInt,\n          },\n          months: {\n            description: \"A quantity of months.\",\n            type: GraphQLInt,\n          },\n          years: {\n            description: \"A quantity of years.\",\n            type: GraphQLInt,\n          },\n        };\n      };\n      const GQLInterval = newWithHooks(\n        GraphQLObjectType,\n        {\n          name: inflection.builtin(\"Interval\"),\n          description:\n            \"An interval of time that has passed where the smallest distinct unit is a second.\",\n          fields: makeIntervalFields(),\n        },\n        {\n          isIntervalType: true,\n        }\n      );\n      addType(GQLInterval, \"graphile-build-pg built-in\");\n\n      const GQLIntervalInput = newWithHooks(\n        GraphQLInputObjectType,\n        {\n          name: inflection.inputType(inflection.builtin(\"Interval\")),\n          description:\n            \"An interval of time that has passed where the smallest distinct unit is a second.\",\n          fields: makeIntervalFields(),\n        },\n        {\n          isIntervalInputType: true,\n        }\n      );\n      addType(GQLIntervalInput, \"graphile-build-pg built-in\");\n\n      const stringType = (name, description) =>\n        new GraphQLScalarType({\n          name,\n          description,\n          serialize: value => String(value),\n          parseValue: value => String(value),\n          parseLiteral: ast => {\n            if (ast.kind !== Kind.STRING) {\n              throw new Error(\"Can only parse string values\");\n            }\n            return ast.value;\n          },\n        });\n\n      const BigFloat = stringType(\n        inflection.builtin(\"BigFloat\"),\n        \"A floating point number that requires more precision than IEEE 754 binary 64\"\n      );\n      const BitString = stringType(\n        inflection.builtin(\"BitString\"),\n        \"A string representing a series of binary bits\"\n      );\n      addType(BigFloat, \"graphile-build-pg built-in\");\n      addType(BitString, \"graphile-build-pg built-in\");\n\n      const rawTypes = [\n        1186, // interval\n        1082, // date\n        1114, // timestamp\n        1184, // timestamptz\n        1083, // time\n        1266, // timetz\n      ];\n\n      const tweakToJson = fragment => fragment; // Since everything is to_json'd now, just pass through\n      const tweakToText = fragment => sql.fragment`(${fragment})::text`;\n      const tweakToNumericText = fragment =>\n        sql.fragment`(${fragment})::numeric::text`;\n      const pgTweaksByTypeIdAndModifer = {};\n      const pgTweaksByTypeId = Object.assign(\n        // ::text rawTypes\n        rawTypes.reduce((memo, typeId) => {\n          memo[typeId] = tweakToText;\n          return memo;\n        }, {}),\n        {\n          // cast numbers above our ken to strings to avoid loss of precision\n          \"20\": tweakToText,\n          \"1700\": tweakToText,\n          // to_json all dates to make them ISO (overrides rawTypes above)\n          \"1082\": tweakToJson,\n          \"1114\": tweakToJson,\n          \"1184\": tweakToJson,\n          \"1083\": tweakToJson,\n          \"1266\": tweakToJson,\n          \"790\": tweakToNumericText,\n        }\n      );\n\n      const pgTweakFragmentForTypeAndModifier = (\n        fragment,\n        type,\n        typeModifier = null,\n        resolveData\n      ) => {\n        const typeModifierKey = typeModifier != null ? typeModifier : -1;\n        const tweaker =\n          (pgTweaksByTypeIdAndModifer[type.id] &&\n            pgTweaksByTypeIdAndModifer[type.id][typeModifierKey]) ||\n          pgTweaksByTypeId[type.id];\n        if (tweaker) {\n          return tweaker(fragment, resolveData);\n        } else if (type.domainBaseType) {\n          // TODO: check that domains don't support atttypemod\n          return pgTweakFragmentForTypeAndModifier(\n            fragment,\n            type.domainBaseType,\n            type.domainBaseTypeModifier,\n            resolveData\n          );\n        } else if (type.isPgArray) {\n          const error = new Error(\n            `Internal graphile-build-pg error: should not attempt to tweak an array, please process array before tweaking (type: \"${\n              type.namespaceName\n            }.${type.name}\")`\n          );\n          if (process.env.NODE_ENV === \"test\") {\n            // This is to ensure that Graphile core does not introduce these problems\n            throw error;\n          }\n          // eslint-disable-next-line no-console\n          console.error(error);\n          return fragment;\n        } else {\n          return fragment;\n        }\n      };\n      /*\n      Determined by running:\n\n        select oid, typname, typarray, typcategory, typtype from pg_catalog.pg_type where typtype = 'b' order by oid;\n\n      We only need to add oidLookups for types that don't have the correct fallback\n    */\n      const SimpleDate = stringType(\n        inflection.builtin(\"Date\"),\n        \"The day, does not include a time.\"\n      );\n      const SimpleDatetime = stringType(\n        inflection.builtin(\"Datetime\"),\n        \"A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\"\n      );\n      const SimpleTime = stringType(\n        inflection.builtin(\"Time\"),\n        \"The exact time of day, does not include the date. May or may not have a timezone offset.\"\n      );\n      const SimpleJSON = stringType(\n        inflection.builtin(\"JSON\"),\n        \"A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).\"\n      );\n      const SimpleUUID = stringType(\n        inflection.builtin(\"UUID\"),\n        \"A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).\"\n      );\n      const InetType = stringType(\n        inflection.builtin(\"InternetAddress\"),\n        \"An IPv4 or IPv6 host address, and optionally its subnet.\"\n      );\n\n      // pgExtendedTypes might change what types we use for things\n      const JSONType = pgExtendedTypes\n        ? makeGraphQLJSONType(graphql, inflection.builtin(\"JSON\"))\n        : SimpleJSON;\n      const UUIDType = SimpleUUID; // GraphQLUUID\n      const DateType = SimpleDate; // GraphQLDate\n      const DateTimeType = SimpleDatetime; // GraphQLDateTime\n      const TimeType = SimpleTime; // GraphQLTime\n\n      // 'point' in PostgreSQL is a 16-byte type that's comprised of two 8-byte floats.\n      const Point = newWithHooks(\n        GraphQLObjectType,\n        {\n          name: inflection.builtin(\"Point\"),\n          fields: {\n            x: {\n              type: new GraphQLNonNull(GraphQLFloat),\n            },\n            y: {\n              type: new GraphQLNonNull(GraphQLFloat),\n            },\n          },\n        },\n        {\n          isPointType: true,\n        }\n      );\n      const PointInput = newWithHooks(\n        GraphQLInputObjectType,\n        {\n          name: inflection.inputType(inflection.builtin(\"Point\")),\n          fields: {\n            x: {\n              type: new GraphQLNonNull(GraphQLFloat),\n            },\n            y: {\n              type: new GraphQLNonNull(GraphQLFloat),\n            },\n          },\n        },\n        {\n          isPointInputType: true,\n        }\n      );\n\n      // Other plugins might want to use JSON\n      addType(JSONType, \"graphile-build-pg built-in\");\n      addType(UUIDType, \"graphile-build-pg built-in\");\n      addType(DateType, \"graphile-build-pg built-in\");\n      addType(DateTimeType, \"graphile-build-pg built-in\");\n      addType(TimeType, \"graphile-build-pg built-in\");\n\n      const oidLookup = {\n        \"20\": stringType(\n          inflection.builtin(\"BigInt\"),\n          \"A signed eight-byte integer. The upper big integer values are greater then the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers.\"\n        ), // bitint - even though this is int8, it's too big for JS int, so cast to string.\n        \"21\": GraphQLInt, // int2\n        \"23\": GraphQLInt, // int4\n        \"700\": GraphQLFloat, // float4\n        \"701\": GraphQLFloat, // float8\n        \"1700\": BigFloat, // numeric\n        \"790\": GraphQLFloat, // money\n\n        \"1186\": GQLInterval, // interval\n        \"1082\": DateType, // date\n        \"1114\": DateTimeType, // timestamp\n        \"1184\": DateTimeType, // timestamptz\n        \"1083\": TimeType, // time\n        \"1266\": TimeType, // timetz\n\n        \"114\": JSONType, // json\n        \"3802\": JSONType, // jsonb\n        \"2950\": UUIDType, // uuid\n\n        \"1560\": BitString, // bit\n        \"1562\": BitString, // varbit\n\n        \"18\": GraphQLString, // char\n        \"25\": GraphQLString, // text\n        \"1043\": GraphQLString, // varchar\n\n        \"600\": Point, // point\n\n        \"869\": InetType,\n      };\n      const oidInputLookup = {\n        \"1186\": GQLIntervalInput, // interval\n        \"600\": PointInput, // point\n      };\n      const jsonStringify = o => JSON.stringify(o);\n      if (pgExtendedTypes) {\n        pg2GqlMapper[114] = {\n          map: identity,\n          unmap: o => sql.value(jsonStringify(o)),\n        };\n      } else {\n        pg2GqlMapper[114] = {\n          map: jsonStringify,\n          unmap: str => sql.value(str),\n        };\n      }\n      pg2GqlMapper[3802] = pg2GqlMapper[114]; // jsonb\n\n      // interval\n      pg2GqlMapper[1186] = {\n        map: str => parseInterval(str),\n        unmap: o => {\n          const keys = [\n            \"seconds\",\n            \"minutes\",\n            \"hours\",\n            \"days\",\n            \"months\",\n            \"years\",\n          ];\n          const parts = [];\n          for (const key of keys) {\n            if (o[key]) {\n              parts.push(`${o[key]} ${key}`);\n            }\n          }\n          return sql.value(parts.join(\" \") || \"0 seconds\");\n        },\n      };\n\n      pg2GqlMapper[790] = {\n        map: _ => _,\n        unmap: val => sql.fragment`(${sql.value(val)})::money`,\n      };\n\n      // point\n      pg2GqlMapper[600] = {\n        map: f => {\n          if (f[0] === \"(\" && f[f.length - 1] === \")\") {\n            const [x, y] = f\n              .substr(1, f.length - 2)\n              .split(\",\")\n              .map(f => parseFloat(f));\n            return { x, y };\n          }\n        },\n        unmap: o => sql.fragment`point(${sql.value(o.x)}, ${sql.value(o.y)})`,\n      };\n\n      // TODO: add more support for geometric types\n\n      let depth = 0;\n\n      /*\n     * Enforce: this is the fallback when we can't find a specific GraphQL type\n     * for a specific PG type.  Use the generators from\n     * `pgRegisterGqlTypeByTypeId` first, this is a last resort.\n     */\n      const enforceGqlTypeByPgTypeId = (typeId, typeModifier) => {\n        const type = introspectionResultsByKind.type.find(t => t.id === typeId);\n        depth++;\n        if (depth > 50) {\n          throw new Error(\"Type enforcement went too deep - infinite loop?\");\n        }\n        try {\n          return reallyEnforceGqlTypeByPgTypeAndModifier(type, typeModifier);\n        } catch (e) {\n          const error = new Error(\n            `Error occurred when processing database type '${\n              type.namespaceName\n            }.${type.name}' (type=${type.type}):\\n${indent(e.message)}`\n          );\n          // $FlowFixMe\n          error.originalError = e;\n          throw error;\n        } finally {\n          depth--;\n        }\n      };\n      const reallyEnforceGqlTypeByPgTypeAndModifier = (type, typeModifier) => {\n        if (!type.id) {\n          throw new Error(\n            `Invalid argument to enforceGqlTypeByPgTypeId - expected a full type, received '${type}'`\n          );\n        }\n        if (!gqlTypeByTypeIdAndModifier[type.id]) {\n          gqlTypeByTypeIdAndModifier[type.id] = {};\n        }\n        if (!gqlInputTypeByTypeIdAndModifier[type.id]) {\n          gqlInputTypeByTypeIdAndModifier[type.id] = {};\n        }\n        const typeModifierKey = typeModifier != null ? typeModifier : -1;\n        // Explicit overrides\n        if (!gqlTypeByTypeIdAndModifier[type.id][typeModifierKey]) {\n          const gqlType = oidLookup[type.id];\n          if (gqlType) {\n            gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = gqlType;\n          }\n        }\n        if (!gqlInputTypeByTypeIdAndModifier[type.id][typeModifierKey]) {\n          const gqlInputType = oidInputLookup[type.id];\n          if (gqlInputType) {\n            gqlInputTypeByTypeIdAndModifier[type.id][\n              typeModifierKey\n            ] = gqlInputType;\n          }\n        }\n        // Enums\n        if (\n          !gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n          type.type === \"e\"\n        ) {\n          gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = newWithHooks(\n            GraphQLEnumType,\n            {\n              name: inflection.enumType(type),\n              description: type.description,\n              values: type.enumVariants.reduce((memo, value) => {\n                memo[inflection.enumName(value)] = {\n                  value: value,\n                };\n                return memo;\n              }, {}),\n            },\n            {\n              pgIntrospection: type,\n              isPgEnumType: true,\n            }\n          );\n        }\n        // Ranges\n        if (\n          !gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n          type.type === \"r\"\n        ) {\n          const subtype =\n            introspectionResultsByKind.typeById[type.rangeSubTypeId];\n          const gqlRangeSubType = getGqlTypeByTypeIdAndModifier(\n            subtype.id,\n            typeModifier\n          );\n          if (!gqlRangeSubType) {\n            throw new Error(\"Range of unsupported\");\n          }\n          let Range = getTypeByName(inflection.rangeType(gqlRangeSubType.name));\n          let RangeInput;\n          if (!Range) {\n            const RangeBound = newWithHooks(\n              GraphQLObjectType,\n              {\n                name: inflection.rangeBoundType(gqlRangeSubType.name),\n                description:\n                  \"The value at one end of a range. A range can either include this value, or not.\",\n                fields: {\n                  value: {\n                    description: \"The value at one end of our range.\",\n                    type: new GraphQLNonNull(gqlRangeSubType),\n                  },\n                  inclusive: {\n                    description:\n                      \"Whether or not the value of this bound is included in the range.\",\n                    type: new GraphQLNonNull(GraphQLBoolean),\n                  },\n                },\n              },\n              {\n                isPgRangeBoundType: true,\n                pgIntrospection: type,\n                pgSubtypeIntrospection: subtype,\n                pgTypeModifier: typeModifier,\n              }\n            );\n            const RangeBoundInput = newWithHooks(\n              GraphQLInputObjectType,\n              {\n                name: inflection.inputType(RangeBound.name),\n                description:\n                  \"The value at one end of a range. A range can either include this value, or not.\",\n                fields: {\n                  value: {\n                    description: \"The value at one end of our range.\",\n                    type: new GraphQLNonNull(gqlRangeSubType),\n                  },\n                  inclusive: {\n                    description:\n                      \"Whether or not the value of this bound is included in the range.\",\n                    type: new GraphQLNonNull(GraphQLBoolean),\n                  },\n                },\n              },\n              {\n                isPgRangeBoundInputType: true,\n                pgIntrospection: type,\n                pgSubtypeIntrospection: subtype,\n                pgTypeModifier: typeModifier,\n              }\n            );\n            Range = newWithHooks(\n              GraphQLObjectType,\n              {\n                name: inflection.rangeType(gqlRangeSubType.name),\n                description: `A range of \\`${gqlRangeSubType.name}\\`.`,\n                fields: {\n                  start: {\n                    description: \"The starting bound of our range.\",\n                    type: RangeBound,\n                  },\n                  end: {\n                    description: \"The ending bound of our range.\",\n                    type: RangeBound,\n                  },\n                },\n              },\n              {\n                isPgRangeType: true,\n                pgIntrospection: type,\n                pgSubtypeIntrospection: subtype,\n                pgTypeModifier: typeModifier,\n              }\n            );\n            RangeInput = newWithHooks(\n              GraphQLInputObjectType,\n              {\n                name: inflection.inputType(Range.name),\n                description: `A range of \\`${gqlRangeSubType.name}\\`.`,\n                fields: {\n                  start: {\n                    description: \"The starting bound of our range.\",\n                    type: RangeBoundInput,\n                  },\n                  end: {\n                    description: \"The ending bound of our range.\",\n                    type: RangeBoundInput,\n                  },\n                },\n              },\n              {\n                isPgRangeInputType: true,\n                pgIntrospection: type,\n                pgSubtypeIntrospection: subtype,\n                pgTypeModifier: typeModifier,\n              }\n            );\n            addType(Range, \"graphile-build-pg built-in\");\n            addType(RangeInput, \"graphile-build-pg built-in\");\n          } else {\n            RangeInput = getTypeByName(inflection.inputType(Range.name));\n          }\n          gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = Range;\n          gqlInputTypeByTypeIdAndModifier[type.id][\n            typeModifierKey\n          ] = RangeInput;\n          if (pgTweaksByTypeIdAndModifer[type.id] === undefined) {\n            pgTweaksByTypeIdAndModifer[type.id] = {};\n          }\n          pgTweaksByTypeIdAndModifer[type.id][\n            typeModifierKey\n          ] = fragment => sql.fragment`case\n          when (${fragment}) is null then null else json_build_object(\n            'start', case\n              when lower(${fragment}) is null then null\n              else json_build_object('value', ${pgTweakFragmentForTypeAndModifier(\n                sql.fragment`lower(${fragment})`,\n                subtype,\n                typeModifier,\n                {}\n              )}, 'inclusive', lower_inc(${fragment}))\n            end,\n            'end', case\n              when upper(${fragment}) is null then null\n              else json_build_object('value', ${pgTweakFragmentForTypeAndModifier(\n                sql.fragment`upper(${fragment})`,\n                subtype,\n                typeModifier,\n                {}\n              )}, 'inclusive', upper_inc(${fragment}))\n            end\n        ) end`;\n          pg2GqlMapper[type.id] = {\n            map: identity,\n            unmap: ({ start, end }) => {\n              // Ref: https://www.postgresql.org/docs/9.6/static/rangetypes.html#RANGETYPES-CONSTRUCT\n              const lower =\n                (start && gql2pg(start.value, subtype, null)) || sql.null;\n              const upper =\n                (end && gql2pg(end.value, subtype, null)) || sql.null;\n              const lowerInclusive = start && !start.inclusive ? \"(\" : \"[\";\n              const upperInclusive = end && !end.inclusive ? \")\" : \"]\";\n              return sql.fragment`${sql.identifier(\n                type.namespaceName,\n                type.name\n              )}(${lower}, ${upper}, ${sql.literal(\n                lowerInclusive + upperInclusive\n              )})`;\n            },\n          };\n        }\n\n        // Domains\n        if (\n          !gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n          type.type === \"d\" &&\n          type.domainBaseTypeId\n        ) {\n          const baseType = getGqlTypeByTypeIdAndModifier(\n            type.domainBaseTypeId,\n            typeModifier\n          );\n          const baseInputType =\n            gqlInputTypeByTypeIdAndModifier[type.domainBaseTypeId][\n              typeModifierKey\n            ];\n          // Hack stolen from: https://github.com/graphile/postgraphile/blob/ade728ed8f8e3ecdc5fdad7d770c67aa573578eb/src/graphql/schema/type/aliasGqlType.ts#L16\n          gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = Object.assign(\n            Object.create(baseType),\n            {\n              name: inflection.domainType(type),\n              description: type.description,\n            }\n          );\n          if (baseInputType && baseInputType !== baseType) {\n            gqlInputTypeByTypeIdAndModifier[type.id][\n              typeModifierKey\n            ] = Object.assign(Object.create(baseInputType), {\n              name: inflection.inputType(\n                gqlTypeByTypeIdAndModifier[type.id][typeModifierKey]\n              ),\n              description: type.description,\n            });\n          }\n        }\n\n        // Arrays\n        if (\n          !gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n          type.category === \"A\"\n        ) {\n          const arrayEntryOutputType = getGqlTypeByTypeIdAndModifier(\n            type.arrayItemTypeId,\n            typeModifier\n          );\n          gqlTypeByTypeIdAndModifier[type.id][\n            typeModifierKey\n          ] = new GraphQLList(arrayEntryOutputType);\n          if (!disableIssue390Fix) {\n            const arrayEntryInputType = getGqlInputTypeByTypeIdAndModifier(\n              type.arrayItemTypeId,\n              typeModifier\n            );\n            if (arrayEntryInputType) {\n              gqlInputTypeByTypeIdAndModifier[type.id][\n                typeModifierKey\n              ] = new GraphQLList(arrayEntryInputType);\n            }\n          }\n        }\n\n        // Booleans\n        if (\n          !gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n          type.category === \"B\"\n        ) {\n          gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = GraphQLBoolean;\n        }\n\n        // Numbers may be too large for GraphQL/JS to handle, so stringify by\n        // default.\n        if (\n          !gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n          type.category === \"N\"\n        ) {\n          pgTweaksByTypeId[type.id] = tweakToText;\n          gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = BigFloat;\n        }\n\n        // Nothing else worked; pass through as string!\n        if (!gqlTypeByTypeIdAndModifier[type.id][typeModifierKey]) {\n          // XXX: consider using stringType(upperFirst(camelCase(`fallback_${type.name}`)), type.description)?\n          gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = GraphQLString;\n        }\n        // Now for input types, fall back to output types if possible\n        if (!gqlInputTypeByTypeIdAndModifier[type.id][typeModifierKey]) {\n          if (\n            isInputType(gqlTypeByTypeIdAndModifier[type.id][typeModifierKey])\n          ) {\n            gqlInputTypeByTypeIdAndModifier[type.id][typeModifierKey] =\n              gqlTypeByTypeIdAndModifier[type.id][typeModifierKey];\n          }\n        }\n        addType(\n          getNamedType(gqlTypeByTypeIdAndModifier[type.id][typeModifierKey])\n        );\n        return gqlTypeByTypeIdAndModifier[type.id][typeModifierKey];\n      };\n\n      function getGqlTypeByTypeIdAndModifier(\n        typeId,\n        typeModifier = null,\n        useFallback = true\n      ) {\n        const typeModifierKey = typeModifier != null ? typeModifier : -1;\n        if (!gqlTypeByTypeIdAndModifier[typeId]) {\n          gqlTypeByTypeIdAndModifier[typeId] = {};\n        }\n        if (!gqlInputTypeByTypeIdAndModifier[typeId]) {\n          gqlInputTypeByTypeIdAndModifier[typeId] = {};\n        }\n        if (!gqlTypeByTypeIdAndModifier[typeId][typeModifierKey]) {\n          const type = introspectionResultsByKind.type.find(\n            t => t.id === typeId\n          );\n          if (!type) {\n            throw new Error(\n              `Type '${typeId}' not present in introspection results`\n            );\n          }\n          const gen = gqlTypeByTypeIdGenerator[type.id];\n          if (gen) {\n            const set = Type => {\n              gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = Type;\n            };\n            const result = gen(set, typeModifier);\n            if (result) {\n              if (\n                gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n                gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] !== result\n              ) {\n                throw new Error(\n                  `Callback and return types differ when defining type for '${\n                    type.id\n                  }'`\n                );\n              }\n              gqlTypeByTypeIdAndModifier[type.id][typeModifierKey] = result;\n            }\n          }\n        }\n        if (\n          !gqlTypeByTypeIdAndModifier[typeId][typeModifierKey] &&\n          typeModifierKey > -1\n        ) {\n          // Fall back to `null` modifier, but if that still doesn't work, we\n          // still want to pass the modifier to enforceGqlTypeByPgTypeId.\n          const fallback = getGqlTypeByTypeIdAndModifier(typeId, null, false);\n          if (fallback) {\n            return fallback;\n          }\n        }\n        if (\n          useFallback &&\n          !gqlTypeByTypeIdAndModifier[typeId][typeModifierKey]\n        ) {\n          return enforceGqlTypeByPgTypeId(typeId, typeModifier);\n        }\n        return gqlTypeByTypeIdAndModifier[typeId][typeModifierKey];\n      }\n\n      function getGqlInputTypeByTypeIdAndModifier(typeId, typeModifier = null) {\n        // First, load the OUTPUT type (it might register an input type)\n        getGqlTypeByTypeIdAndModifier(typeId, typeModifier);\n\n        const typeModifierKey = typeModifier != null ? typeModifier : -1;\n        if (!gqlInputTypeByTypeIdAndModifier[typeId]) {\n          gqlInputTypeByTypeIdAndModifier[typeId] = {};\n        }\n        if (!gqlInputTypeByTypeIdAndModifier[typeId][typeModifierKey]) {\n          const type = introspectionResultsByKind.typeById[typeId];\n\n          if (!type) {\n            throw new Error(\n              `Type '${typeId}' not present in introspection results`\n            );\n          }\n          const gen = gqlInputTypeByTypeIdGenerator[type.id];\n          if (gen) {\n            const set = Type => {\n              gqlInputTypeByTypeIdAndModifier[type.id][typeModifierKey] = Type;\n            };\n            const result = gen(set, typeModifier);\n            if (result) {\n              if (\n                gqlInputTypeByTypeIdAndModifier[type.id][typeModifierKey] &&\n                gqlInputTypeByTypeIdAndModifier[type.id][typeModifierKey] !==\n                  result\n              ) {\n                throw new Error(\n                  `Callback and return types differ when defining type for '${\n                    type.id\n                  }'`\n                );\n              }\n              gqlInputTypeByTypeIdAndModifier[type.id][\n                typeModifierKey\n              ] = result;\n            }\n          }\n        }\n        // Use the same type as the output type if it's valid input\n        if (\n          !gqlInputTypeByTypeIdAndModifier[typeId][typeModifierKey] &&\n          gqlTypeByTypeIdAndModifier[typeId] &&\n          gqlTypeByTypeIdAndModifier[typeId][typeModifierKey] &&\n          isInputType(gqlTypeByTypeIdAndModifier[typeId][typeModifierKey])\n        ) {\n          gqlInputTypeByTypeIdAndModifier[typeId][typeModifierKey] =\n            gqlTypeByTypeIdAndModifier[typeId][typeModifierKey];\n        }\n        if (\n          !gqlInputTypeByTypeIdAndModifier[typeId][typeModifierKey] &&\n          typeModifierKey > -1\n        ) {\n          // Fall back to default\n          return getGqlInputTypeByTypeIdAndModifier(typeId, null);\n        }\n        return gqlInputTypeByTypeIdAndModifier[typeId][typeModifierKey];\n      }\n      function registerGqlTypeByTypeId(typeId, gen, yieldToExisting = false) {\n        if (gqlTypeByTypeIdGenerator[typeId]) {\n          if (yieldToExisting) {\n            return;\n          }\n          throw new Error(\n            `There's already a type generator registered for '${typeId}'`\n          );\n        }\n        gqlTypeByTypeIdGenerator[typeId] = gen;\n      }\n      function registerGqlInputTypeByTypeId(\n        typeId,\n        gen,\n        yieldToExisting = false\n      ) {\n        if (gqlInputTypeByTypeIdGenerator[typeId]) {\n          if (yieldToExisting) {\n            return;\n          }\n          throw new Error(\n            `There's already an input type generator registered for '${typeId}'`\n          );\n        }\n        gqlInputTypeByTypeIdGenerator[typeId] = gen;\n      }\n\n      // DEPRECATIONS!\n      function getGqlTypeByTypeId(typeId, typeModifier) {\n        if (typeModifier === undefined) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"DEPRECATION WARNING: getGqlTypeByTypeId should not be used - for some columns we also require typeModifier to be specified. Please update your code ASAP to pass `attribute.typeModifier` through as the second parameter (or null if it's not available).\"\n          );\n        }\n        return getGqlTypeByTypeIdAndModifier(typeId, typeModifier);\n      }\n      function getGqlInputTypeByTypeId(typeId, typeModifier) {\n        if (typeModifier === undefined) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"DEPRECATION WARNING: getGqlInputTypeByTypeId should not be used - for some columns we also require typeModifier to be specified. Please update your code ASAP to pass `attribute.typeModifier` through as the second parameter (or null if it's not available).\"\n          );\n        }\n        return getGqlInputTypeByTypeIdAndModifier(typeId, typeModifier);\n      }\n      function pgTweakFragmentForType(\n        fragment,\n        type,\n        typeModifier,\n        resolveData\n      ) {\n        if (typeModifier === undefined) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"DEPRECATION WARNING: pgTweakFragmentForType should not be used - for some columns we also require typeModifier to be specified. Please update your code ASAP to pass `attribute.typeModifier` through as the third parameter (or null if it's not available).\"\n          );\n        }\n        return pgTweakFragmentForTypeAndModifier(\n          fragment,\n          type,\n          typeModifier,\n          resolveData\n        );\n      }\n      // END OF DEPRECATIONS!\n\n      return build.extend(build, {\n        pgRegisterGqlTypeByTypeId: registerGqlTypeByTypeId,\n        pgRegisterGqlInputTypeByTypeId: registerGqlInputTypeByTypeId,\n        pgGetGqlTypeByTypeIdAndModifier: getGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier: getGqlInputTypeByTypeIdAndModifier,\n        pg2GqlMapper,\n        pg2gql,\n        gql2pg,\n        pgTweakFragmentForTypeAndModifier,\n        pgTweaksByTypeId,\n        pgTweaksByTypeIdAndModifer,\n\n        // DEPRECATED METHODS:\n        pgGetGqlTypeByTypeId: getGqlTypeByTypeId, // DEPRECATED, replaced by getGqlTypeByTypeIdAndModifier\n        pgGetGqlInputTypeByTypeId: getGqlInputTypeByTypeId, // DEPRECATED, replaced by getGqlInputTypeByTypeIdAndModifier\n        pgTweakFragmentForType, // DEPRECATED, replaced by pgTweakFragmentForTypeAndModifier\n      });\n    },\n    [\"PgTypes\"],\n    [],\n    [\"PgIntrospection\", \"StandardTypes\"]\n  );\n\n  /* Start of hstore type */\n  builder.hook(\n    \"inflection\",\n    (inflection, build) => {\n      // This hook allows you to append a plugin which renames the KeyValueHash\n      // (hstore) type name.\n      if (pgSkipHstore) return build;\n      return build.extend(inflection, {\n        hstoreType() {\n          return \"KeyValueHash\";\n        },\n      });\n    },\n    [\"PgTypesHstore\"]\n  );\n  builder.hook(\n    \"build\",\n    build => {\n      // This hook tells graphile-build-pg about the hstore database type so it\n      // knows how to express it in input/output.\n      if (pgSkipHstore) return build;\n      const {\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgRegisterGqlTypeByTypeId,\n        pgRegisterGqlInputTypeByTypeId,\n        pg2GqlMapper,\n        pgSql: sql,\n        graphql,\n      } = build;\n\n      // Check we have the hstore extension\n      const hstoreExtension = introspectionResultsByKind.extension.find(\n        e => e.name === \"hstore\"\n      );\n      if (!hstoreExtension) {\n        return build;\n      }\n\n      // Get the 'hstore' type itself:\n      const hstoreType = introspectionResultsByKind.type.find(\n        t =>\n          t.name === \"hstore\" && t.namespaceId === hstoreExtension.namespaceId\n      );\n      if (!hstoreType) {\n        return build;\n      }\n\n      const hstoreTypeName = build.inflection.hstoreType();\n\n      // We're going to use our own special HStore type for this so that we get\n      // better validation; but you could just as easily use JSON directly if you\n      // wanted to.\n      const GraphQLHStoreType = makeGraphQLHstoreType(graphql, hstoreTypeName);\n\n      // Now register the hstore type with the type system for both output and input.\n      pgRegisterGqlTypeByTypeId(hstoreType.id, () => GraphQLHStoreType);\n      pgRegisterGqlInputTypeByTypeId(hstoreType.id, () => GraphQLHStoreType);\n\n      // Finally we must tell the system how to translate the data between PG-land and JS-land:\n      pg2GqlMapper[hstoreType.id] = {\n        // node-postgres parses hstore for us, no action required on map\n        map: identity,\n        // When unmapping we need to convert back to hstore\n        unmap: o =>\n          sql.fragment`(${sql.value(hstoreStringify(o))}::${sql.identifier(\n            hstoreType.namespaceName,\n            hstoreType.name\n          )})`,\n      };\n\n      return build;\n    },\n    [\"PgTypesHstore\"],\n    [],\n    [\"PgTypes\"]\n  );\n  /* End of hstore type */\n}: Plugin);\n\nfunction makeGraphQLHstoreType(graphql, hstoreTypeName) {\n  const { GraphQLScalarType, Kind } = graphql;\n\n  function isValidHstoreObject(obj) {\n    if (obj === null) {\n      // Null is okay\n      return true;\n    } else if (typeof obj === \"object\") {\n      // A hash with string/null values is also okay\n      const keys = Object.keys(obj);\n      for (const key of keys) {\n        const val = obj[key];\n        if (val === null) {\n          // Null is okay\n        } else if (typeof val === \"string\") {\n          // String is okay\n        } else {\n          // Everything else is invalid.\n          return false;\n        }\n      }\n      return true;\n    } else {\n      // Everything else is invalid.\n      return false;\n    }\n  }\n\n  function identityWithCheck(obj) {\n    if (isValidHstoreObject(obj)) {\n      return obj;\n    }\n    throw new TypeError(\n      `This is not a valid ${hstoreTypeName} object, it must be a key/value hash where keys and values are both strings (or null).`\n    );\n  }\n\n  function parseValueLiteral(ast, variables) {\n    switch (ast.kind) {\n      case Kind.INT:\n      case Kind.FLOAT:\n        // Number isn't really okay, but we'll coerce it to a string anyway.\n        return String(parseFloat(ast.value));\n      case Kind.STRING:\n        // String is okay.\n        return String(ast.value);\n      case Kind.NULL:\n        // Null is okay.\n        return null;\n      case Kind.VARIABLE: {\n        // Variable is okay if that variable is either a string or null.\n        const name = ast.name.value;\n        const value = variables ? variables[name] : undefined;\n        if (value === null || typeof value === \"string\") {\n          return value;\n        }\n        return undefined;\n      }\n      default:\n        // Everything else is invalid.\n        return undefined;\n    }\n  }\n\n  function parseLiteral(ast, variables) {\n    switch (ast.kind) {\n      case Kind.OBJECT: {\n        const value = ast.fields.reduce((memo, field) => {\n          memo[field.name.value] = parseValueLiteral(field.value, variables);\n          return memo;\n        }, Object.create(null));\n\n        if (!isValidHstoreObject(value)) {\n          return undefined;\n        }\n        return value;\n      }\n\n      case Kind.NULL:\n        return null;\n\n      case Kind.VARIABLE: {\n        const name = ast.name.value;\n        const value = variables ? variables[name] : undefined;\n\n        if (!isValidHstoreObject(value)) {\n          return undefined;\n        }\n        return value;\n      }\n\n      default:\n        return undefined;\n    }\n  }\n\n  // TODO: use newWithHooks instead\n  const GraphQLHStore = new GraphQLScalarType({\n    name: hstoreTypeName,\n    description:\n      \"A set of key/value pairs, keys are strings, values may be a string or null. Exposed as a JSON object.\",\n    serialize: identity,\n    parseValue: identityWithCheck,\n    parseLiteral,\n  });\n  return GraphQLHStore;\n}\n\n// To include a double quote or a backslash in a key or value, escape it\n// with a backslash.\n// -- https://www.postgresql.org/docs/10/static/hstore.html\nfunction toHstoreString(str) {\n  return '\"' + str.replace(/([\"\\\\])/g, \"\\\\$1\") + '\"';\n}\n\nfunction hstoreStringify(o) {\n  if (o === null) {\n    return null;\n  }\n  if (typeof o !== \"object\") {\n    throw new TypeError(\"Expected an hstore object\");\n  }\n  const keys = Object.keys(o);\n  const encodeKeyValue = key => {\n    const value = o[key];\n    if (value === null) {\n      return `${toHstoreString(key)} => NULL`;\n    } else {\n      return `${toHstoreString(key)} => ${toHstoreString(String(value))}`;\n    }\n  };\n  return keys.map(encodeKeyValue).join(\", \");\n}\n"]}