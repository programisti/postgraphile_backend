{"version":3,"sources":["../../src/plugins/PgMutationUpdateDeletePlugin.js"],"names":["debug","PgMutationUpdateDeletePlugin","builder","pgDisableDefaultMutations","hook","fields","build","context","newWithHooks","getNodeIdForTypeAndIdentifiers","getTypeAndIdentifiersFromNodeId","nodeIdFieldName","fieldDataGeneratorsByType","extend","parseResolveInfo","getTypeByName","gql2pg","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","GraphQLInputObjectType","GraphQLString","GraphQLObjectType","GraphQLID","pgColumnFilter","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgViaTemporaryTable","viaTemporaryTable","describePgEntity","sqlCommentByAddingTags","pgField","scope","isRootMutation","fieldWithHooks","reduce","outerMemo","mode","class","memo","table","namespace","canUpdate","isUpdatable","canDelete","isDeletable","TableType","type","id","commonCodeRenameMe","pgClient","resolveInfo","getDataFromParsedResolveInfoFragment","PayloadType","args","condition","resolveContext","input","parsedResolveInfoFragment","resolveData","sqlTypeIdentifier","identifier","name","sqlMutationQuery","sqlColumns","sqlValues","inputData","patchField","tableFieldName","attributes","forEach","attr","fieldName","column","val","push","typeModifier","length","query","join","map","col","i","fragment","modifiedRowAlias","Symbol","rootValue","row","rows","e","Error","pluralize","_singularizedTableName","clientMutationId","data","uniqueConstraints","constraints","filter","con","Table","tableTypeName","TablePatch","patchType","description","tableName","deletedNodeIdFieldName","deletedNodeId","Object","assign","addDataGenerator","fieldDataGeneratorsByTableType","get","gens","gen","resolve","__identifiers","isPgMutationPayloadDeletedNodeIdField","__origin","isMutationPayload","isPgUpdatePayloadType","isPgDeletePayloadType","pgIntrospection","primaryKeyConstraint","primaryKeys","keyAttributes","InputType","isPgUpdateInputType","isPgUpdateNodeInputType","isPgDeleteInputType","isPgDeleteNodeInputType","pgInflection","isMutationInput","parent","nodeId","Type","identifiers","key","idx","isPgNodeMutation","pgFieldIntrospection","constraint","keys","every","_","some","typeId","isPgUpdateByKeysInputType","isPgDeleteByKeysInputType","pgKeys","pgFieldConstraint"],"mappings":"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","file":"PgMutationUpdateDeletePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (async function PgMutationUpdateDeletePlugin(\n  builder,\n  { pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        newWithHooks,\n        getNodeIdForTypeAndIdentifiers,\n        getTypeAndIdentifiersFromNodeId,\n        nodeIdFieldName,\n        fieldDataGeneratorsByType,\n        extend,\n        parseResolveInfo,\n        getTypeByName,\n        gql2pg,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        graphql: {\n          GraphQLNonNull,\n          GraphQLInputObjectType,\n          GraphQLString,\n          GraphQLObjectType,\n          GraphQLID,\n        },\n        pgColumnFilter,\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        pgViaTemporaryTable: viaTemporaryTable,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n      const {\n        scope: { isRootMutation },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootMutation) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        [\"update\", \"delete\"].reduce(\n          (outerMemo, mode) =>\n            introspectionResultsByKind.class.reduce((memo, table) => {\n              // PERFORMANCE: These used to be .filter(...) calls\n              if (!table.namespace) return memo;\n              const canUpdate =\n                mode === \"update\" &&\n                table.isUpdatable &&\n                !omit(table, \"update\");\n              const canDelete =\n                mode === \"delete\" &&\n                table.isDeletable &&\n                !omit(table, \"delete\");\n              if (!canUpdate && !canDelete) return memo;\n\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                table.type.id,\n                null\n              );\n              if (!TableType) {\n                return memo;\n              }\n              async function commonCodeRenameMe(\n                pgClient,\n                resolveInfo,\n                getDataFromParsedResolveInfoFragment,\n                PayloadType,\n                args,\n                condition,\n                context,\n                resolveContext\n              ) {\n                const { input } = args;\n                const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n                parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                const resolveData = getDataFromParsedResolveInfoFragment(\n                  parsedResolveInfoFragment,\n                  PayloadType\n                );\n\n                const sqlTypeIdentifier = sql.identifier(\n                  table.namespace.name,\n                  table.name\n                );\n\n                let sqlMutationQuery;\n                if (mode === \"update\") {\n                  const sqlColumns = [];\n                  const sqlValues = [];\n                  const inputData =\n                    input[\n                      inflection.patchField(inflection.tableFieldName(table))\n                    ];\n                  table.attributes.forEach(attr => {\n                    // PERFORMANCE: These used to be .filter(...) calls\n                    if (!pgColumnFilter(attr, build, context)) return;\n                    if (omit(attr, \"update\")) return;\n\n                    const fieldName = inflection.column(attr);\n                    if (\n                      fieldName in inputData /* Because we care about null! */\n                    ) {\n                      const val = inputData[fieldName];\n                      sqlColumns.push(sql.identifier(attr.name));\n                      sqlValues.push(gql2pg(val, attr.type, attr.typeModifier));\n                    }\n                  });\n                  if (sqlColumns.length === 0) {\n                    return null;\n                  }\n                  sqlMutationQuery = sql.query`\n                update ${sql.identifier(\n                  table.namespace.name,\n                  table.name\n                )} set ${sql.join(\n                    sqlColumns.map(\n                      (col, i) => sql.fragment`${col} = ${sqlValues[i]}`\n                    ),\n                    \", \"\n                  )}\n                where ${condition}\n                returning *`;\n                } else {\n                  sqlMutationQuery = sql.query`\n                delete from ${sql.identifier(table.namespace.name, table.name)}\n                where ${condition}\n                returning *`;\n                }\n\n                const modifiedRowAlias = sql.identifier(Symbol());\n                const query = queryFromResolveData(\n                  modifiedRowAlias,\n                  modifiedRowAlias,\n                  resolveData,\n                  {},\n                  null,\n                  resolveContext,\n                  resolveInfo.rootValue\n                );\n                let row;\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  const rows = await viaTemporaryTable(\n                    pgClient,\n                    sqlTypeIdentifier,\n                    sqlMutationQuery,\n                    modifiedRowAlias,\n                    query\n                  );\n                  row = rows[0];\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n                if (!row) {\n                  throw new Error(\n                    `No values were ${mode}d in collection '${inflection.pluralize(\n                      inflection._singularizedTableName(table)\n                    )}' because no values you can ${mode} were found matching these criteria.`\n                  );\n                }\n                return {\n                  clientMutationId: input.clientMutationId,\n                  data: row,\n                };\n              }\n              if (TableType) {\n                const uniqueConstraints = table.constraints.filter(\n                  con => con.type === \"u\" || con.type === \"p\"\n                );\n                const Table = pgGetGqlTypeByTypeIdAndModifier(\n                  table.type.id,\n                  null\n                );\n                const tableTypeName = Table.name;\n                const TablePatch = getTypeByName(\n                  inflection.patchType(Table.name)\n                );\n                const PayloadType = newWithHooks(\n                  GraphQLObjectType,\n                  {\n                    name: inflection[\n                      mode === \"delete\"\n                        ? \"deletePayloadType\"\n                        : \"updatePayloadType\"\n                    ](table),\n                    description: `The output of our ${mode} \\`${tableTypeName}\\` mutation.`,\n                    fields: ({ fieldWithHooks }) => {\n                      const tableName = inflection.tableFieldName(table);\n                      // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.\n                      const deletedNodeIdFieldName = inflection.deletedNodeId(\n                        table\n                      );\n                      return Object.assign(\n                        {\n                          clientMutationId: {\n                            description:\n                              \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                            type: GraphQLString,\n                          },\n                          [tableName]: pgField(\n                            build,\n                            fieldWithHooks,\n                            tableName,\n                            {\n                              description: `The \\`${tableTypeName}\\` that was ${mode}d by this mutation.`,\n                              type: Table,\n                            },\n                            {},\n                            false\n                          ),\n                        },\n                        mode === \"delete\"\n                          ? {\n                              [deletedNodeIdFieldName]: fieldWithHooks(\n                                deletedNodeIdFieldName,\n                                ({ addDataGenerator }) => {\n                                  const fieldDataGeneratorsByTableType = fieldDataGeneratorsByType.get(\n                                    TableType\n                                  );\n\n                                  const gens =\n                                    fieldDataGeneratorsByTableType &&\n                                    fieldDataGeneratorsByTableType[\n                                      nodeIdFieldName\n                                    ];\n                                  if (gens) {\n                                    gens.forEach(gen => addDataGenerator(gen));\n                                  }\n                                  return {\n                                    type: GraphQLID,\n                                    resolve(data) {\n                                      return (\n                                        data.data.__identifiers &&\n                                        getNodeIdForTypeAndIdentifiers(\n                                          Table,\n                                          ...data.data.__identifiers\n                                        )\n                                      );\n                                    },\n                                  };\n                                },\n                                {\n                                  isPgMutationPayloadDeletedNodeIdField: true,\n                                }\n                              ),\n                            }\n                          : null\n                      );\n                    },\n                  },\n                  {\n                    __origin: `Adding table ${mode} mutation payload type for ${describePgEntity(\n                      table\n                    )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                      table,\n                      {\n                        name: \"newNameHere\",\n                      }\n                    )}`,\n                    isMutationPayload: true,\n                    isPgUpdatePayloadType: mode === \"update\",\n                    isPgDeletePayloadType: mode === \"delete\",\n                    pgIntrospection: table,\n                  }\n                );\n\n                // NodeId\n                const primaryKeyConstraint = table.primaryKeyConstraint;\n                if (nodeIdFieldName && primaryKeyConstraint) {\n                  const primaryKeys =\n                    primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n                  const fieldName = inflection[\n                    mode === \"update\" ? \"updateNode\" : \"deleteNode\"\n                  ](table);\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: `All input for the \\`${fieldName}\\` mutation.`,\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateNodeInputType\"\n                          : \"deleteNodeInputType\"\n                      ](table),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            description:\n                              \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                            type: GraphQLString,\n                          },\n                          [nodeIdFieldName]: {\n                            description: `The globally unique \\`ID\\` which will identify a single \\`${tableTypeName}\\` to be ${mode}d.`,\n                            type: new GraphQLNonNull(GraphQLID),\n                          },\n                        },\n                        mode === \"update\"\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} (by node ID) mutation input type for ${describePgEntity(\n                        table\n                      )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateNodeInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteNodeInputType: mode === \"delete\",\n                      pgInflection: table, // TODO:v5: remove - TYPO!\n                      pgIntrospection: table,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const {\n                            getDataFromParsedResolveInfoFragment,\n                          } = context;\n                          return {\n                            description:\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using its globally unique id and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using its globally unique id.`,\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              args,\n                              resolveContext,\n                              resolveInfo\n                            ) {\n                              const { input } = args;\n                              const { pgClient } = resolveContext;\n                              const nodeId = input[nodeIdFieldName];\n                              try {\n                                const {\n                                  Type,\n                                  identifiers,\n                                } = getTypeAndIdentifiersFromNodeId(nodeId);\n                                if (Type !== TableType) {\n                                  throw new Error(\"Mismatched type\");\n                                }\n                                if (identifiers.length !== primaryKeys.length) {\n                                  throw new Error(\"Invalid ID\");\n                                }\n\n                                return commonCodeRenameMe(\n                                  pgClient,\n                                  resolveInfo,\n                                  getDataFromParsedResolveInfoFragment,\n                                  PayloadType,\n                                  args,\n                                  sql.fragment`(${sql.join(\n                                    primaryKeys.map(\n                                      (key, idx) =>\n                                        sql.fragment`${sql.identifier(\n                                          key.name\n                                        )} = ${gql2pg(\n                                          identifiers[idx],\n                                          key.type,\n                                          key.typeModifier\n                                        )}`\n                                    ),\n                                    \") and (\"\n                                  )})`,\n                                  context,\n                                  resolveContext\n                                );\n                              } catch (e) {\n                                debug(e);\n                                return null;\n                              }\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: true,\n                          pgFieldIntrospection: table,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    \"Adding ${mode} mutation for ${describePgEntity(table)}\"\n                  );\n                }\n\n                // Unique\n                uniqueConstraints.forEach(constraint => {\n                  if (omit(constraint, mode)) {\n                    return;\n                  }\n                  const keys = constraint.keyAttributes;\n                  if (!keys.every(_ => _)) {\n                    throw new Error(\n                      `Consistency error: could not find an attribute in the constraint when building the ${mode} mutation for ${describePgEntity(\n                        table\n                      )}!`\n                    );\n                  }\n                  if (keys.some(key => omit(key, \"read\"))) {\n                    return;\n                  }\n                  const fieldName = inflection[\n                    mode === \"update\" ? \"updateByKeys\" : \"deleteByKeys\"\n                  ](keys, table, constraint);\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: `All input for the \\`${fieldName}\\` mutation.`,\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateByKeysInputType\"\n                          : \"deleteByKeysInputType\"\n                      ](keys, table, constraint),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            type: GraphQLString,\n                          },\n                        },\n                        mode === \"update\"\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null,\n                        keys.reduce((memo, key) => {\n                          memo[inflection.column(key)] = {\n                            description: key.description,\n                            type: new GraphQLNonNull(\n                              pgGetGqlInputTypeByTypeIdAndModifier(\n                                key.typeId,\n                                key.typeModifier\n                              )\n                            ),\n                          };\n                          return memo;\n                        }, {})\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} mutation input type for ${describePgEntity(\n                        constraint\n                      )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateByKeysInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteByKeysInputType: mode === \"delete\",\n                      pgInflection: table, // TODO:v5: remove - TYPO!\n                      pgIntrospection: table,\n                      pgKeys: keys,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const {\n                            getDataFromParsedResolveInfoFragment,\n                          } = context;\n                          return {\n                            description:\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using a unique key and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using a unique key.`,\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              args,\n                              resolveContext,\n                              resolveInfo\n                            ) {\n                              const { input } = args;\n                              const { pgClient } = resolveContext;\n                              return commonCodeRenameMe(\n                                pgClient,\n                                resolveInfo,\n                                getDataFromParsedResolveInfoFragment,\n                                PayloadType,\n                                args,\n                                sql.fragment`(${sql.join(\n                                  keys.map(\n                                    key =>\n                                      sql.fragment`${sql.identifier(\n                                        key.name\n                                      )} = ${gql2pg(\n                                        input[inflection.column(key)],\n                                        key.type,\n                                        key.typeModifier\n                                      )}`\n                                  ),\n                                  \") and (\"\n                                )})`,\n                                context,\n                                resolveContext\n                              );\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: false,\n                          pgFieldIntrospection: table,\n                          pgFieldConstraint: constraint,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    `Adding ${mode} mutation for ${describePgEntity(\n                      constraint\n                    )}`\n                  );\n                });\n              }\n              return memo;\n            }, outerMemo),\n          {}\n        ),\n        `Adding default update/delete mutations to root Mutation type`\n      );\n    },\n    [\"PgMutationUpdateDelete\"]\n  );\n}: Plugin);\n"]}