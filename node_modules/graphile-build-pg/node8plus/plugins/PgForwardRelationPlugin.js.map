{"version":3,"sources":["../../src/plugins/PgForwardRelationPlugin.js"],"names":["debug","PgForwardRelationPlugin","builder","subscriptions","hook","fields","build","context","extend","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","sqlCommentByAddingTags","describePgEntity","scope","isPgRowType","isPgCompositeType","isMutationPayload","pgIntrospection","pgIntrospectionTable","fieldWithHooks","Self","table","kind","namespace","foreignKeyConstraints","constraints","filter","con","type","reduce","memo","constraint","gqlTableType","id","tableTypeName","name","classId","foreignTable","classById","foreignClassId","gqlForeignTableType","foreignTableTypeName","Error","foreignSchema","keys","keyAttributes","foreignKeys","foreignKeyAttributes","every","_","some","key","fieldName","singleRelationByKeys","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","foreignTableAlias","identifier","Symbol","query","useAsterisk","asJson","innerQueryBuilder","parentQueryBuilder","primaryKeyConstraint","selectIdentifiers","forEach","i","where","fragment","getTableAlias","rootValue","alias","description","tags","forwardDescription","resolve","rawData","_args","resolveContext","resolveInfo","data","safeAlias","record","liveRecord","__identifiers","pgFieldIntrospection","isPgForwardRelationField"],"mappings":"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","file":"PgForwardRelationPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (function PgForwardRelationPlugin(builder, { subscriptions }) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        getSafeAliasFromResolveInfo,\n        getSafeAliasFromAlias,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        sqlCommentByAddingTags,\n        describePgEntity,\n      } = build;\n      const {\n        scope: {\n          isPgRowType,\n          isPgCompositeType,\n          isMutationPayload,\n          pgIntrospection,\n          pgIntrospectionTable,\n        },\n        fieldWithHooks,\n        Self,\n      } = context;\n\n      const table = pgIntrospectionTable || pgIntrospection;\n      if (\n        !(isPgRowType || isMutationPayload || isPgCompositeType) ||\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace\n      ) {\n        return fields;\n      }\n      // This is a relation in which we (table) are local, and there's a foreign table\n\n      const foreignKeyConstraints = table.constraints.filter(\n        con => con.type === \"f\"\n      );\n\n      return extend(\n        fields,\n        foreignKeyConstraints.reduce((memo, constraint) => {\n          if (omit(constraint, \"read\")) {\n            return memo;\n          }\n          const gqlTableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const tableTypeName = gqlTableType.name;\n          if (!gqlTableType) {\n            debug(\n              `Could not determine type for table with id ${constraint.classId}`\n            );\n            return memo;\n          }\n          const foreignTable =\n            introspectionResultsByKind.classById[constraint.foreignClassId];\n          const gqlForeignTableType = pgGetGqlTypeByTypeIdAndModifier(\n            foreignTable.type.id,\n            null\n          );\n          const foreignTableTypeName = gqlForeignTableType.name;\n          if (!gqlForeignTableType) {\n            debug(\n              `Could not determine type for foreign table with id ${\n                constraint.foreignClassId\n              }`\n            );\n            return memo;\n          }\n          if (!foreignTable) {\n            throw new Error(\n              `Could not find the foreign table (constraint: ${\n                constraint.name\n              })`\n            );\n          }\n          if (omit(foreignTable, \"read\")) {\n            return memo;\n          }\n          const foreignSchema = foreignTable.namespace;\n\n          const keys = constraint.keyAttributes;\n          const foreignKeys = constraint.foreignKeyAttributes;\n          if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n            throw new Error(\"Could not find key columns!\");\n          }\n          if (keys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n          if (foreignKeys.some(key => omit(key, \"read\"))) {\n            return memo;\n          }\n\n          const fieldName = inflection.singleRelationByKeys(\n            keys,\n            foreignTable,\n            table,\n            constraint\n          );\n\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                ({\n                  getDataFromParsedResolveInfoFragment,\n                  addDataGenerator,\n                }) => {\n                  addDataGenerator(parsedResolveInfoFragment => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(() => {\n                          const resolveData = getDataFromParsedResolveInfoFragment(\n                            parsedResolveInfoFragment,\n                            gqlForeignTableType\n                          );\n                          const foreignTableAlias = sql.identifier(Symbol());\n                          const query = queryFromResolveData(\n                            sql.identifier(\n                              foreignSchema.name,\n                              foreignTable.name\n                            ),\n                            foreignTableAlias,\n                            resolveData,\n                            {\n                              useAsterisk: false, // Because it's only a single relation, no need\n                              asJson: true,\n                            },\n                            innerQueryBuilder => {\n                              innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                              if (subscriptions && table.primaryKeyConstraint) {\n                                queryBuilder.selectIdentifiers(table);\n                              }\n                              if (\n                                subscriptions &&\n                                foreignTable.primaryKeyConstraint\n                              ) {\n                                innerQueryBuilder.selectIdentifiers(\n                                  foreignTable\n                                );\n                              }\n                              keys.forEach((key, i) => {\n                                innerQueryBuilder.where(\n                                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                    key.name\n                                  )} = ${foreignTableAlias}.${sql.identifier(\n                                    foreignKeys[i].name\n                                  )}`\n                                );\n                              });\n                            },\n                            queryBuilder.context,\n                            queryBuilder.rootValue\n                          );\n                          return sql.fragment`(${query})`;\n                        }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                      },\n                    };\n                  });\n                  return {\n                    description:\n                      constraint.tags.forwardDescription ||\n                      `Reads a single \\`${foreignTableTypeName}\\` that is related to this \\`${tableTypeName}\\`.`,\n                    type: gqlForeignTableType, // Nullable since RLS may forbid fetching\n                    resolve: (rawData, _args, resolveContext, resolveInfo) => {\n                      const data = isMutationPayload ? rawData.data : rawData;\n                      if (!data) return null;\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      const record = data[safeAlias];\n                      const liveRecord =\n                        resolveInfo.rootValue &&\n                        resolveInfo.rootValue.liveRecord;\n                      if (record && liveRecord) {\n                        liveRecord(\"pg\", foreignTable, record.__identifiers);\n                      }\n                      return record;\n                    },\n                  };\n                },\n                {\n                  pgFieldIntrospection: constraint,\n                  isPgForwardRelationField: true,\n                }\n              ),\n            },\n            `Forward relation for ${describePgEntity(\n              constraint\n            )}. To rename this relation with smart comments:\\n\\n  ${sqlCommentByAddingTags(\n              constraint,\n              {\n                fieldName: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n        `Adding forward relations to '${Self.name}'`\n      );\n    },\n    [\"PgForwardRelation\"]\n  );\n}: Plugin);\n"]}