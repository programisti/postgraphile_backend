{"version":3,"sources":["../../src/plugins/PgTablesPlugin.js"],"names":["base64","str","Buffer","from","String","toString","hasNonNullKey","row","Array","isArray","__identifiers","every","i","k","hasOwnProperty","PgTablesPlugin","builder","pgForbidSetofFunctionsToReturnNull","subscriptions","handleNullRow","_identifiers","identifiers","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","getSafeAliasFromResolveInfo","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","inflection","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","class","forEach","table","tablePgType","type","Error","arrayTablePgType","arrayType","primaryKeyConstraint","primaryKeys","keyAttributes","attributes","tableTypeName","tableType","shouldHaveNodeId","isSelectable","namespace","length","TableType","TablePatchType","TableBaseInputType","id","cb","description","name","interfaces","builtin","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","selectIdentifiers","resolve","data","__origin","pgIntrospection","isPgRowType","isPgCompoundType","pgCreateInputFields","pgPatchInputFields","pgBaseInputFields","inputType","isInputType","pgAddSubfield","fieldName","attrName","pgType","spec","typeModifier","patchType","isPgPatch","baseInputType","isPgBaseInput","map","unmap","obj","modifier","fieldLookup","attr2sql","attr","column","inputField","v","fragment","identifier","namespaceName","null","join","EdgeType","edge","fieldWithHooks","cursor","addDataGenerator","usesCursor","__cursor","JSON","stringify","isCursorField","node","_args","resolveContext","resolveInfo","safeAlias","record","liveRecord","rootValue","withQueryBuilder","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","recurseDataGeneratorsForField","nodes","entry","edges","_context","hoistCursor","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","_set","RelevantTableInputType"],"mappings":"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","file":"PgTablesPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nconst hasNonNullKey = row => {\n  if (\n    Array.isArray(row.__identifiers) &&\n    row.__identifiers.every(i => i != null)\n  ) {\n    return true;\n  }\n  for (const k in row) {\n    if (row.hasOwnProperty(k)) {\n      if ((k[0] !== \"_\" || k[1] !== \"_\") && row[k] !== null) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport default (function PgTablesPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false, subscriptions = false }\n) {\n  const handleNullRow = pgForbidSetofFunctionsToReturnNull\n    ? (row, _identifiers) => row\n    : (row, identifiers) => {\n        if ((identifiers && hasNonNullKey(identifiers)) || hasNonNullKey(row)) {\n          return row;\n        } else {\n          return null;\n        }\n      };\n\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        getNodeIdForTypeAndIdentifiers,\n        nodeIdFieldName,\n        newWithHooks,\n        getSafeAliasFromResolveInfo,\n        pgSql: sql,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgRegisterGqlTypeByTypeId,\n        pgRegisterGqlInputTypeByTypeId,\n        pg2GqlMapper,\n        gql2pg,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLNonNull,\n          GraphQLID,\n          GraphQLList,\n          GraphQLInputObjectType,\n        },\n        inflection,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const nullableIf = (condition, Type) =>\n        condition ? Type : new GraphQLNonNull(Type);\n      const Cursor = getTypeByName(\"Cursor\");\n\n      introspectionResultsByKind.class.forEach(table => {\n        const tablePgType = table.type;\n        if (!tablePgType) {\n          throw new Error(\"Could not determine the type for this table\");\n        }\n        const arrayTablePgType = tablePgType.arrayType;\n        const primaryKeyConstraint = table.primaryKeyConstraint;\n        const primaryKeys =\n          primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n        const attributes = table.attributes;\n        const tableTypeName = inflection.tableType(table);\n        const shouldHaveNodeId: boolean =\n          nodeIdFieldName &&\n          table.isSelectable &&\n          table.namespace &&\n          primaryKeys &&\n          primaryKeys.length\n            ? true\n            : false;\n        let TableType;\n        let TablePatchType;\n        let TableBaseInputType;\n        pgRegisterGqlTypeByTypeId(\n          tablePgType.id,\n          cb => {\n            if (TableType) {\n              return TableType;\n            }\n            if (pg2GqlMapper[tablePgType.id]) {\n              // Already handled\n              throw new Error(\n                `Register was called but there's already a mapper in place for '${\n                  tablePgType.id\n                }'!`\n              );\n            }\n            TableType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: table.description || tablePgType.description,\n                name: tableTypeName,\n                interfaces: () => {\n                  if (shouldHaveNodeId) {\n                    return [getTypeByName(inflection.builtin(\"Node\"))];\n                  } else {\n                    return [];\n                  }\n                },\n                fields: ({ addDataGeneratorForField, Self }) => {\n                  const fields = {};\n                  if (shouldHaveNodeId) {\n                    // Enable nodeId interface\n                    addDataGeneratorForField(nodeIdFieldName, () => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.selectIdentifiers(table);\n                        },\n                      };\n                    });\n                    fields[nodeIdFieldName] = {\n                      description:\n                        \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                      type: new GraphQLNonNull(GraphQLID),\n                      resolve(data) {\n                        return (\n                          data.__identifiers &&\n                          getNodeIdForTypeAndIdentifiers(\n                            Self,\n                            ...data.__identifiers\n                          )\n                        );\n                      },\n                    };\n                  }\n                  return fields;\n                },\n              },\n              {\n                __origin: `Adding table type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n              }\n            );\n            cb(TableType);\n            const pgCreateInputFields = {};\n            const pgPatchInputFields = {};\n            const pgBaseInputFields = {};\n            newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `An input for mutations affecting \\`${tableTypeName}\\``,\n                name: inflection.inputType(TableType),\n              },\n              {\n                __origin: `Adding table input type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isInputType: true,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgCreateInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              },\n              true // If no fields, skip type automatically\n            );\n\n            if (table.isSelectable) {\n              // XXX: these don't belong here; but we have to keep them here\n              // because third-party code depends on `getTypeByName` to find\n              // them; so we have to register them ahead of time. A better\n              // approach is to use the modifier to specify the type you need,\n              // 'patch' or 'base', so they can be registered just in time.\n              TablePatchType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                  name: inflection.patchType(TableType),\n                },\n                {\n                  __origin: `Adding table patch type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgPatch: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgPatchInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                },\n                true // Safe to skip this if no fields support updating\n              );\n              TableBaseInputType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: `An input representation of \\`${tableTypeName}\\` with nullable fields.`,\n                  name: inflection.baseInputType(TableType),\n                },\n                {\n                  __origin: `Adding table base input type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgBaseInput: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgBaseInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                }\n              );\n            }\n\n            pg2GqlMapper[tablePgType.id] = {\n              map: _ => _,\n              unmap: (obj, modifier) => {\n                let fieldLookup;\n                if (modifier === \"patch\") {\n                  fieldLookup = pgPatchInputFields;\n                } else if (modifier === \"base\") {\n                  fieldLookup = pgBaseInputFields;\n                } else {\n                  fieldLookup = pgCreateInputFields;\n                }\n\n                const attr2sql = attr => {\n                  // TODO: this should use `fieldInput[*].name` to find the attribute\n                  const fieldName = inflection.column(attr);\n                  const inputField = fieldLookup[fieldName];\n                  const v = obj[fieldName];\n                  if (inputField && v != null) {\n                    const { type, typeModifier } = inputField;\n                    return sql.fragment`${gql2pg(\n                      v,\n                      type,\n                      typeModifier\n                    )}::${sql.identifier(type.namespaceName, type.name)}`;\n                  } else {\n                    return sql.null; // TODO: return default instead.\n                  }\n                };\n\n                return sql.fragment`row(${sql.join(\n                  attributes.map(attr2sql),\n                  \",\"\n                )})::${sql.identifier(\n                  tablePgType.namespaceName,\n                  tablePgType.name\n                )}`;\n              },\n            };\n\n            const EdgeType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: `A \\`${tableTypeName}\\` edge in the connection.`,\n                name: inflection.edge(TableType.name),\n                fields: ({ fieldWithHooks }) => {\n                  return {\n                    cursor: fieldWithHooks(\n                      \"cursor\",\n                      ({ addDataGenerator }) => {\n                        addDataGenerator(() => ({\n                          usesCursor: [true],\n                          pgQuery: queryBuilder => {\n                            if (primaryKeys) {\n                              queryBuilder.selectIdentifiers(table);\n                            }\n                          },\n                        }));\n                        return {\n                          description: \"A cursor for use in pagination.\",\n                          type: Cursor,\n                          resolve(data) {\n                            return (\n                              data.__cursor &&\n                              base64(JSON.stringify(data.__cursor))\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isCursorField: true,\n                      }\n                    ),\n                    node: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"node\",\n                      {\n                        description: `The \\`${tableTypeName}\\` at the end of the edge.`,\n                        type: nullableIf(\n                          !pgForbidSetofFunctionsToReturnNull,\n                          TableType\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const record = handleNullRow(\n                            data[safeAlias],\n                            data.__identifiers\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          if (\n                            record &&\n                            primaryKeys &&\n                            liveRecord &&\n                            data.__identifiers\n                          ) {\n                            liveRecord(\"pg\", table, data.__identifiers);\n                          }\n                          return record;\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                  };\n                },\n              },\n              {\n                __origin: `Adding table edge type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isEdgeType: true,\n                isPgRowEdgeType: true,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n            const PageInfo = getTypeByName(inflection.builtin(\"PageInfo\"));\n\n            /*const ConnectionType = */\n            newWithHooks(\n              GraphQLObjectType,\n              {\n                description: `A connection to a list of \\`${tableTypeName}\\` values.`,\n                name: inflection.connection(TableType.name),\n                fields: ({ recurseDataGeneratorsForField, fieldWithHooks }) => {\n                  recurseDataGeneratorsForField(\"pageInfo\", true);\n                  return {\n                    nodes: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"nodes\",\n                      {\n                        description: `A list of \\`${tableTypeName}\\` objects.`,\n                        type: new GraphQLNonNull(\n                          new GraphQLList(\n                            nullableIf(\n                              !pgForbidSetofFunctionsToReturnNull,\n                              TableType\n                            )\n                          )\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          return data.data.map(entry => {\n                            const record = handleNullRow(\n                              entry[safeAlias],\n                              entry[safeAlias].__identifiers\n                            );\n                            if (\n                              record &&\n                              liveRecord &&\n                              primaryKeys &&\n                              entry[safeAlias].__identifiers\n                            ) {\n                              liveRecord(\n                                \"pg\",\n                                table,\n                                entry[safeAlias].__identifiers\n                              );\n                            }\n\n                            return record;\n                          });\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                    edges: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"edges\",\n                      {\n                        description: `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                        type: new GraphQLNonNull(\n                          new GraphQLList(new GraphQLNonNull(EdgeType))\n                        ),\n                        resolve(data, _args, _context, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          return data.data.map(entry => ({\n                            ...entry,\n                            ...entry[safeAlias],\n                          }));\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        hoistCursor: true,\n                      }\n                    ),\n                    pageInfo: PageInfo && {\n                      description: \"Information to aid in pagination.\",\n                      type: new GraphQLNonNull(PageInfo),\n                      resolve(data) {\n                        return data;\n                      },\n                    },\n                  };\n                },\n              },\n              {\n                __origin: `Adding table connection type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isConnectionType: true,\n                isPgRowConnectionType: true,\n                edgeType: EdgeType,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          tablePgType.id,\n          (_set, modifier) => {\n            // This must come first, it triggers creation of all the types\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              tablePgType.id,\n              null\n            );\n            // This must come after the pgGetGqlTypeByTypeIdAndModifier call\n            if (modifier === \"patch\") {\n              // TODO: v5: move the definition from above down here\n              return TablePatchType;\n            }\n            if (modifier === \"base\") {\n              // TODO: v5: move the definition from above down here\n              return TableBaseInputType;\n            }\n            if (TableType) {\n              return getTypeByName(inflection.inputType(TableType));\n            }\n            return null;\n          },\n          true\n        );\n\n        if (arrayTablePgType) {\n          // Note: these do not return\n          //\n          // `new GraphQLList(new GraphQLNonNull(...))`\n          //\n          // because it's possible to return null entries from postgresql\n          // functions. We should probably add a flag to instead export\n          // the non-null version as that's more typical.\n          pgRegisterGqlTypeByTypeId(\n            arrayTablePgType.id,\n            () => {\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                tablePgType.id,\n                null\n              );\n              return new GraphQLList(TableType);\n            },\n            true\n          );\n          pgRegisterGqlInputTypeByTypeId(\n            arrayTablePgType.id,\n            (_set, modifier) => {\n              const RelevantTableInputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                tablePgType.id,\n                modifier\n              );\n              if (RelevantTableInputType) {\n                return new GraphQLList(RelevantTableInputType);\n              }\n            },\n            true\n          );\n        }\n      });\n      return _;\n    },\n    [\"PgTables\"],\n    [],\n    [\"PgTypes\"]\n  );\n}: Plugin);\n"]}