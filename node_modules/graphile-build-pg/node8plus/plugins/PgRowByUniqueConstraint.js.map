{"version":3,"sources":["../../src/plugins/PgRowByUniqueConstraint.js"],"names":["PgRowByUniqueConstraint","builder","subscriptions","hook","fields","build","context","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","gql2pg","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isRootQuery","fieldWithHooks","class","reduce","memo","table","namespace","TableType","type","id","sqlFullTableName","identifier","name","uniqueConstraints","constraints","filter","con","forEach","constraint","keys","keyAttributes","some","key","every","_","Error","fieldName","rowByUniqueKeys","getDataFromParsedResolveInfoFragment","args","InputType","typeId","typeModifier","column","resolve","parent","resolveContext","resolveInfo","pgClient","liveRecord","parsedResolveInfoFragment","resolveData","query","undefined","useAsterisk","queryBuilder","primaryKeyConstraint","selectIdentifiers","where","fragment","getTableAlias","text","values","compile","debugSql","enabled","rows","row","__identifiers","isPgRowByUniqueConstraintField","pgFieldIntrospection"],"mappings":"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","file":"PgRowByUniqueConstraint.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowByUniqueConstraint(\n  builder,\n  { subscriptions }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        gql2pg,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        graphql: { GraphQLNonNull },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n      } = build;\n      const {\n        scope: { isRootQuery },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootQuery) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        introspectionResultsByKind.class.reduce((memo, table) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!table.namespace) return memo;\n          if (omit(table, \"read\")) return memo;\n\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const uniqueConstraints = table.constraints.filter(\n              con => con.type === \"u\" || con.type === \"p\"\n            );\n            uniqueConstraints.forEach(constraint => {\n              if (omit(constraint, \"read\")) {\n                return;\n              }\n              const keys = constraint.keyAttributes;\n              if (keys.some(key => omit(key, \"read\"))) {\n                return;\n              }\n              if (!keys.every(_ => _)) {\n                throw new Error(\n                  \"Consistency error: could not find an attribute!\"\n                );\n              }\n              const fieldName = inflection.rowByUniqueKeys(\n                keys,\n                table,\n                constraint\n              );\n              memo[fieldName] = fieldWithHooks(\n                fieldName,\n                ({ getDataFromParsedResolveInfoFragment }) => {\n                  return {\n                    type: TableType,\n                    args: keys.reduce((memo, key) => {\n                      const InputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                        key.typeId,\n                        key.typeModifier\n                      );\n                      if (!InputType) {\n                        throw new Error(\n                          `Could not find input type for key '${\n                            key.name\n                          }' on type '${TableType.name}'`\n                        );\n                      }\n                      memo[inflection.column(key)] = {\n                        type: new GraphQLNonNull(InputType),\n                      };\n                      return memo;\n                    }, {}),\n                    async resolve(parent, args, resolveContext, resolveInfo) {\n                      const { pgClient, liveRecord } = resolveContext;\n                      const parsedResolveInfoFragment = parseResolveInfo(\n                        resolveInfo\n                      );\n                      parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        TableType\n                      );\n                      const query = queryFromResolveData(\n                        sqlFullTableName,\n                        undefined,\n                        resolveData,\n                        {\n                          useAsterisk: false, // Because it's only a single relation, no need\n                        },\n                        queryBuilder => {\n                          if (subscriptions && table.primaryKeyConstraint) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                          keys.forEach(key => {\n                            queryBuilder.where(\n                              sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                key.name\n                              )} = ${gql2pg(\n                                args[inflection.column(key)],\n                                key.type,\n                                key.typeModifier\n                              )}`\n                            );\n                          });\n                        },\n                        resolveContext\n                      );\n                      const { text, values } = sql.compile(query);\n                      if (debugSql.enabled) debugSql(text);\n                      const {\n                        rows: [row],\n                      } = await pgClient.query(text, values);\n                      if (subscriptions && liveRecord && row) {\n                        liveRecord(\"pg\", table, row.__identifiers);\n                      }\n                      return row;\n                    },\n                  };\n                },\n                {\n                  isPgRowByUniqueConstraintField: true,\n                  pgFieldIntrospection: constraint,\n                }\n              );\n            });\n          }\n          return memo;\n        }, {}),\n        `Adding \"row by unique constraint\" fields to root Query type`\n      );\n    },\n    [\"PgRowByUniqueConstraint\"]\n  );\n}: Plugin);\n"]}