{"version":3,"sources":["../src/queryFromResolveDataFactory.js"],"names":["sql","identity","_","undefined","queryBuilderOptions","from","fromAlias","resolveData","inOptions","withBuilder","context","rootValue","pgQuery","pgAggregateQuery","pgCursorPrefix","reallyRawCursorPrefix","pgDontUseAsterisk","calculateHasNextPage","calculateHasPreviousPage","usesCursor","explicitlyUsesCursor","preventAsterisk","length","options","useAsterisk","rawCursorPrefix","filter","queryBuilder","QueryBuilder","fn","generateNextPrevPageSql","sqlQueryAlias","canHaveCursorInWhere","queryHasBefore","queryHasFirst","offset","invert","sqlCommonUnbounded","fragment","getTableExpression","getTableAlias","sqlCommon","buildWhereClause","isForwardOrSymmetric","literal","buildWhereBoundClause","getSelectCursor","blank","value","limit","getFinalLimitAndOffset","getPgCursorPrefix","data","cursorPrefix","map","val","withPagination","withPaginationAsFields","withCursor","selectCursor","orderBy","getOrderByExpressionsAndDirections","expr","isOrderUnique","join","setCursorComparator","cursorValue","isAfter","orderByExpressionsAndDirections","sqlCursors","Array","isArray","whereBound","sqlFilter","i","sqlExpression","ascending","comparison","Number","sqlOldFilter","null","getOffset","Math","max","Error","query","build","haveFields","getSelectFieldsCount","identifier","Symbol","sqlSummaryAlias","compiledData","upper","queryHasAfter","lower","queryHasZeroLimit","getFinalLimit","first","queryHasLast","last","hasNextPage","getFinalOffset","hasPreviousPage","sqlWith","sqlFrom","fields","push","aggregateQueryBuilder","aggregateJsonBuildObject","onlyJsonField","aggregatesSql","alias","jsonbBuildObject"],"mappings":"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","file":"queryFromResolveDataFactory.js","sourcesContent":["// @flow\nimport QueryBuilder from \"./QueryBuilder\";\nimport type QueryBuilderOptions from \"./QueryBuilder\";\nimport type { RawAlias } from \"./QueryBuilder\";\nimport * as sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport type { DataForType } from \"graphile-build\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\nimport assert from \"assert\";\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype GraphQLContext = any;\n\nconst identity = _ => _ !== null && _ !== undefined;\n\n// $FlowFixMe\nexport default (queryBuilderOptions: QueryBuilderOptions = {}) => (\n  from: SQL,\n  fromAlias: ?SQL,\n  resolveData: DataForType,\n  inOptions: {\n    withPagination?: boolean,\n    withPaginationAsFields?: boolean,\n    asJson?: boolean,\n    asJsonAggregate?: boolean,\n    addNullCase?: boolean,\n    addNotDistinctFromNullCase?: boolean,\n    onlyJsonField?: boolean,\n    useAsterisk?: boolean,\n  },\n  // TODO:v5: context is not optional\n  withBuilder?: ((builder: QueryBuilder) => void) | null | void,\n  context?: GraphQLContext = {},\n  rootValue?: any // eslint-disable-line flowtype/no-weak-types\n) => {\n  const {\n    pgQuery,\n    pgAggregateQuery,\n    pgCursorPrefix: reallyRawCursorPrefix,\n    pgDontUseAsterisk,\n    calculateHasNextPage,\n    calculateHasPreviousPage,\n    usesCursor: explicitlyUsesCursor,\n  } = resolveData;\n\n  const preventAsterisk = pgDontUseAsterisk\n    ? pgDontUseAsterisk.length > 0\n    : false;\n  const options = {\n    ...inOptions,\n    // Allow pgDontUseAsterisk to override useAsterisk\n    useAsterisk: inOptions.useAsterisk && !preventAsterisk,\n  };\n\n  const usesCursor: boolean =\n    (explicitlyUsesCursor && explicitlyUsesCursor.length > 0) ||\n    (calculateHasNextPage && calculateHasNextPage.length > 0) ||\n    (calculateHasPreviousPage && calculateHasPreviousPage.length > 0) ||\n    false;\n  const rawCursorPrefix =\n    reallyRawCursorPrefix && reallyRawCursorPrefix.filter(identity);\n\n  // $FlowFixMe\n  const queryBuilder = new QueryBuilder(\n    // $FlowFixMe\n    queryBuilderOptions,\n    context,\n    rootValue\n  );\n  queryBuilder.from(from, fromAlias ? fromAlias : undefined);\n\n  if (withBuilder) {\n    withBuilder(queryBuilder);\n  }\n  for (const fn of pgQuery || []) {\n    fn(queryBuilder, resolveData);\n  }\n\n  function generateNextPrevPageSql(\n    sqlQueryAlias,\n    canHaveCursorInWhere,\n    queryHasBefore,\n    queryHasFirst,\n    offset = 0,\n    invert = false\n  ) {\n    /*\n     * Strap in, 'coz this function gets hairy!\n     *\n     * The point of this function is to return SQL which will resolve to a\n     * boolean true/false depending on whether or not there is a (invert ?\n     * \"previous\" : \"next\") page.\n     *\n     * Connections have before, after, first, last and offset.\n     * - Users are forbidden from setting both first and last.\n     * - Users are forbidden from setting both offset and last.\n     *\n     * Further there are two main modes of paginating, one works by adding a\n     * where clause (this is preferred, but is not always possible, and is\n     * indicated by `canHaveCursorInWhere === true`) and the other works using\n     * standard LIMIT/OFFSET SQL pagination (and is indicated by\n     * `canHaveCursorInWhere === false`).\n     *\n     * The following diagram shows a full collection of records, #, starting at\n     * START and ending at END. The key after, before, offset, first and last\n     * variables are shown. One thing not show is that it's possible to have\n     * fewer records between before and after than requested by first or last.\n     * Another detail not clearly show is that if there is no `after` then\n     * `START` is used, similarly if there is no `before` then `END` is used.\n     *\n     *   #################################################### < collection\n     *   ^      ^<-offset->^<-first->^      ^<-last->^      ^\n     *   |      |          |         |      |        |      |\n     *   |      |          +---------+      +--------+      |\n     *   |      |          |  DATA1           DATA2  |      |\n     *   |      |          |                         |      |\n     *   |      |          |                         |      |\n     *   |      |          +-------------------------+      |\n     *   |      |                     DATA3          |      |\n     *   |    after                                before   |\n     *   |                                                  |\n     * START                                               END\n     *\n     * We want one of the three DATA blocks:\n     *\n     * - If `first` is set, then we want DATA1.\n     * - If `last` is set then we want DATA2.\n     * - If neither is set then we want DATA3.\n     *\n     * (Remember: you cannot set both `first` and `last` at the same time.)\n     *\n     * When invert === false:\n     *\n     *   Note that both DATA2 and DATA3 end at the same point, and we only care\n     *   if there's data *after* the relevant DATA block, so really we only\n     *   care if the query specified `first` (`queryHasFirst`) which makes\n     *   things complex (ending at the end of DATA1), otherwise we can use\n     *   `before` as the bound (end of DATA2/DATA3).\n     *\n     * When invert === true:\n     *\n     *   Similarly, DATA1 and DATA3 start at the same point, and we're going\n     *   backwards so we only care if there's data *before* the DATA block, so\n     *   really we just need to know if the query set `last` or not, but since\n     *   this is inverted we call it `queryHasFirst`.\n     *\n     * When `invert` is false we're calculating `hasNextPage`, when true we're\n     * calculating `hasPreviousPage`.\n     *\n     * Because of the near-symmetry of requesting hasPreviousPage vs\n     * hasNextPage we always pretend we're determining `hasNextPage`, and we\n     * just invert everything.\n     */\n\n    const sqlCommonUnbounded = sql.fragment`\n      select 1\n      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n      `;\n    /*\n     * This variable is a fragment to go into an `EXISTS(...)` call (after some tweaks).\n     *\n     * The buildWhereClause takes three arguments:\n     *\n     * - includeLowerBound (we want this for hasNextPage but not hasPreviousPage)\n     * - includeUpperBound (we want this for hasPreviousPage but not hasNextPage)\n     * - options (specifically `{addNullCase, addNotDistinctFromNullCase}`) -\n     *   we just pass this through.\n     *\n     * So in hasNextPage mode (invert === false), this common SQL ends up\n     * representing the collection from `(after || START)` onwards with no\n     * upper bound. In hasPreviousPage mode (invert === true), it represents\n     * everything from `(before || END)` backwards, with no lower bound.\n     */\n    const sqlCommon = sql.fragment`\n      ${sqlCommonUnbounded}\n      where ${queryBuilder.buildWhereClause(!invert, invert, options)}\n    `;\n\n    /*\n     * Since the offset makes the diagram asymmetric, if offset === 0\n     * then the diagram is symmetric and things are simplified a little.\n     */\n    const isForwardOrSymmetric = !invert || offset === 0;\n\n    if (!isForwardOrSymmetric) {\n      assert(invert);\n      assert(offset > 0);\n      // We're looking for a previous page, and there's an offset, so lets just\n      // assume there's a previous page where offset is smaller.\n      return sql.literal(true);\n    } else if (canHaveCursorInWhere) {\n      assert(isForwardOrSymmetric);\n      if (!queryHasBefore && !queryHasFirst) {\n        assert(isForwardOrSymmetric);\n        // There can be no next page since there's no upper bound\n        return sql.literal(false);\n      } else if (queryHasBefore && !queryHasFirst) {\n        /*\n         * We invert the upper buildWhereBoundClause to only represent the data\n         * after `before`, then check if there's at least one record in that set.\n         *\n         * This only works if the `before` cursor can be represented in the\n         * SQL WHERE clause, otherwise we're doing limit/offset pagination\n         * which requires different logic. It also only works if there's no\n         * `first` clause, otherwise there could be a next page before the\n         * `before` clause.\n         */\n        return sql.fragment`exists(\n          ${sqlCommonUnbounded}\n          where ${queryBuilder.buildWhereClause(false, false, options)}\n          and not (${queryBuilder.buildWhereBoundClause(invert)})\n        )`;\n      } else {\n        assert(queryHasFirst);\n        // queryHasBefore could be true or false.\n        /*\n         * There's a few ways that we could determine if there's a next page.\n         *\n         * If !queryHasBefore, we could COUNT(*) the number of rows in\n         * `sqlCommon` and see if it's larger than `first`:\n         * `(select count(*) > ${first} from (${sqlCommon}) __random_table_alias__)`\n         *\n         * If !queryHasBefore, we could build a subquery table of offsetData\n         * from sqlCommon and see if it contains any rows:\n         * `EXISTS(select 1 from (${sqlCommon} OFFSET ${first}) __random_table_alias__)`.\n         *\n         * We could see if there's at least one row in sqlCommon that's not\n         * already in our chosen result set.\n         *\n         * We've chosen the latter approach here because it doesn't place a limit\n         * on queryHasBefore.\n         */\n        // Drop the `first` limit, see if there are any records that aren't\n        // already in the list we've fetched.\n        return sql.fragment`exists(\n          ${sqlCommon}\n          and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})\n          ${\n            offset === 0 ? sql.blank : sql.fragment`offset ${sql.value(offset)}`\n          }\n        )`;\n      }\n    } else {\n      assert(!invert || offset === 0); // isForwardOrSymmetric\n      assert(!canHaveCursorInWhere);\n      // We're dealing with LIMIT/OFFSET pagination here, which means `natural`\n      // cursors, so the `queryBuilder` factors the before/after, first/last\n      // into the limit / offset.\n      const { limit } = queryBuilder.getFinalLimitAndOffset();\n\n      if (limit == null) {\n        // If paginating backwards, then offset > 0 has already been dealt\n        // with. Unbounded, so there's no next page.\n        return sql.fragment`false`;\n      } else if (invert) {\n        assert(offset === 0);\n        // Paginating backwards and there's no offset (which factors in before/after), so there's no previous page.\n        return sql.fragment`false`;\n      } else {\n        assert(!invert);\n        /*\n         * We're paginating forwards; either there's a before, there's a first,\n         * or both.\n         *\n         * We want to see if there's more than limit+offset records in sqlCommon.\n         */\n        return sql.fragment`exists(\n          ${sqlCommon}\n          offset ${sql.literal(limit + offset)}\n        )`;\n      }\n    }\n  }\n  const getPgCursorPrefix = () =>\n    rawCursorPrefix && rawCursorPrefix.length > 0\n      ? rawCursorPrefix\n      : queryBuilder.data.cursorPrefix.map(val => sql.literal(val));\n  if (\n    options.withPagination ||\n    options.withPaginationAsFields ||\n    options.withCursor\n  ) {\n    // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation\n    if (usesCursor) {\n      queryBuilder.selectCursor(() => {\n        const orderBy = queryBuilder\n          .getOrderByExpressionsAndDirections()\n          .map(([expr]) => expr);\n        if (queryBuilder.isOrderUnique() && orderBy.length > 0) {\n          return sql.fragment`json_build_array(${sql.join(\n            [\n              ...getPgCursorPrefix(),\n              sql.fragment`json_build_array(${sql.join(orderBy, \", \")})`,\n            ],\n            \", \"\n          )})`;\n        } else {\n          return sql.fragment`json_build_array(${sql.join(\n            getPgCursorPrefix(),\n            \", \"\n          )}, (row_number() over (partition by 1)))`;\n        }\n      });\n    }\n  }\n  if (options.withPagination || options.withPaginationAsFields) {\n    queryBuilder.setCursorComparator((cursorValue, isAfter) => {\n      const orderByExpressionsAndDirections = queryBuilder.getOrderByExpressionsAndDirections();\n      if (\n        orderByExpressionsAndDirections.length > 0 &&\n        queryBuilder.isOrderUnique()\n      ) {\n        const sqlCursors = cursorValue[getPgCursorPrefix().length].map(val =>\n          sql.value(val)\n        );\n        if (!Array.isArray(sqlCursors)) {\n          queryBuilder.whereBound(sql.literal(false), isAfter);\n        }\n        let sqlFilter = sql.fragment`false`;\n        for (let i = orderByExpressionsAndDirections.length - 1; i >= 0; i--) {\n          const [sqlExpression, ascending] = orderByExpressionsAndDirections[i];\n          // If ascending and isAfter then >\n          // If ascending and isBefore then <\n          const comparison =\n            Number(ascending) ^ Number(!isAfter)\n              ? sql.fragment`>`\n              : sql.fragment`<`;\n\n          const sqlOldFilter = sqlFilter;\n          sqlFilter = sql.fragment`\n          (\n            (\n              ${sqlExpression} ${comparison} ${sqlCursors[i] || sql.null}\n            )\n          OR\n            (\n              (\n                ${sqlExpression} = ${sqlCursors[i] || sql.null}\n              AND\n                ${sqlOldFilter}\n              )\n            )\n          )\n          `;\n        }\n        queryBuilder.whereBound(sqlFilter, isAfter);\n      } else if (\n        cursorValue[0] === \"natural\" &&\n        isSafeInteger(cursorValue[1]) &&\n        cursorValue[1] >= 0\n      ) {\n        if (isAfter) {\n          queryBuilder.offset(() => cursorValue[1]);\n        } else {\n          queryBuilder.limit(() => {\n            const offset = queryBuilder.getOffset();\n            return Math.max(0, cursorValue[1] - offset - 1);\n          });\n        }\n      } else {\n        throw new Error(\"Cannot use cursors without orderBy\");\n      }\n    });\n\n    const query = queryBuilder.build(options);\n    const haveFields = queryBuilder.getSelectFieldsCount() > 0;\n    const sqlQueryAlias = sql.identifier(Symbol());\n    const sqlSummaryAlias = sql.identifier(Symbol());\n    //\n    // Tables should ALWAYS push their PK onto the order stack, if this isn't\n    // present then we're either dealing with a view or a table without a PK.\n    // Either way, we don't have anything to guarantee uniqueness so we need to\n    // fall back to limit/offset.\n    //\n    // TODO: support unique keys in PgAllRows etc\n    // TODO: add a warning for cursor-based pagination when using the fallback\n    // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey\n    const canHaveCursorInWhere =\n      queryBuilder.getOrderByExpressionsAndDirections().length > 0 &&\n      queryBuilder.isOrderUnique();\n    const queryHasBefore =\n      queryBuilder.compiledData.whereBound.upper.length > 0;\n    const queryHasAfter = queryBuilder.compiledData.whereBound.lower.length > 0;\n    const queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;\n    const queryHasFirst = isSafeInteger(queryBuilder.compiledData.first);\n    const queryHasLast = isSafeInteger(queryBuilder.compiledData.last);\n    const hasNextPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasBefore,\n          queryHasFirst,\n          queryBuilder.getFinalOffset() || 0\n        );\n    const hasPreviousPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasAfter,\n          queryHasLast,\n          queryBuilder.getFinalOffset() || 0,\n          true\n        );\n\n    const sqlWith = haveFields\n      ? sql.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})`\n      : sql.fragment``;\n    const sqlFrom = sql.fragment``;\n    const fields: Array<[SQL, RawAlias]> = [];\n    if (haveFields) {\n      fields.push([\n        sql.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`,\n        \"data\",\n      ]);\n      if (calculateHasNextPage) {\n        fields.push([hasNextPage, \"hasNextPage\"]);\n      }\n      if (calculateHasPreviousPage) {\n        fields.push([hasPreviousPage, \"hasPreviousPage\"]);\n      }\n    }\n    if (pgAggregateQuery && pgAggregateQuery.length) {\n      const aggregateQueryBuilder = new QueryBuilder(\n        // $FlowFixMe\n        queryBuilderOptions,\n        context,\n        rootValue\n      );\n      aggregateQueryBuilder.from(\n        queryBuilder.getTableExpression(),\n        queryBuilder.getTableAlias()\n      );\n\n      for (const fn of pgAggregateQuery) {\n        fn(aggregateQueryBuilder);\n      }\n      const aggregateJsonBuildObject = aggregateQueryBuilder.build({\n        onlyJsonField: true,\n      });\n      const aggregatesSql = sql.fragment`\n      (\n        select ${aggregateJsonBuildObject}\n        from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n        where ${queryBuilder.buildWhereClause(false, false, options)}\n      )\n      `;\n      fields.push([aggregatesSql, \"aggregates\"]);\n    }\n    if (options.withPaginationAsFields) {\n      return sql.fragment`${sqlWith} select ${sql.join(\n        fields.map(\n          ([expr, alias]) => sql.fragment`${expr} as ${sql.identifier(alias)}`\n        ),\n        \", \"\n      )} ${sqlFrom}`;\n    } else {\n      return sql.fragment`${sqlWith} select ${queryBuilder.jsonbBuildObject(\n        fields\n      )} ${sqlFrom}`;\n    }\n  } else {\n    const query = queryBuilder.build(options);\n    return query;\n  }\n};\n"]}