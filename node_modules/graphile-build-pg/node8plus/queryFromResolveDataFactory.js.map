{"version":3,"sources":["../src/queryFromResolveDataFactory.js"],"names":["sql","identity","_","undefined","queryBuilderOptions","from","fromAlias","resolveData","options","withBuilder","context","pgQuery","pgAggregateQuery","pgCursorPrefix","reallyRawCursorPrefix","calculateHasNextPage","calculateHasPreviousPage","usesCursor","explicitlyUsesCursor","length","rawCursorPrefix","filter","queryBuilder","QueryBuilder","fn","generateNextPrevPageSql","sqlQueryAlias","canHaveCursorInWhere","queryHasBefore","queryHasFirst","offset","invert","sqlCommonUnbounded","fragment","getTableExpression","getTableAlias","sqlCommon","buildWhereClause","isForwardOrSymmetric","literal","buildWhereBoundClause","getSelectCursor","blank","value","limit","getFinalLimitAndOffset","getPgCursorPrefix","data","cursorPrefix","map","val","withPagination","withPaginationAsFields","withCursor","selectCursor","orderBy","getOrderByExpressionsAndDirections","expr","isOrderUnique","join","setCursorComparator","cursorValue","isAfter","orderByExpressionsAndDirections","sqlCursors","Array","isArray","whereBound","sqlFilter","i","sqlExpression","ascending","comparison","Number","sqlOldFilter","null","getOffset","Math","max","Error","query","build","haveFields","getSelectFieldsCount","identifier","Symbol","sqlSummaryAlias","compiledData","upper","queryHasAfter","lower","queryHasZeroLimit","getFinalLimit","first","queryHasLast","last","hasNextPage","getFinalOffset","hasPreviousPage","sqlWith","sqlFrom","fields","push","aggregateQueryBuilder","aggregateJsonBuildObject","onlyJsonField","aggregatesSql","alias","jsonbBuildObject"],"mappings":"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","file":"queryFromResolveDataFactory.js","sourcesContent":["// @flow\nimport QueryBuilder from \"./QueryBuilder\";\nimport type QueryBuilderOptions from \"./QueryBuilder\";\nimport type { RawAlias } from \"./QueryBuilder\";\nimport * as sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport type { DataForType } from \"graphile-build\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\nimport assert from \"assert\";\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype GraphQLContext = any;\n\nconst identity = _ => _ !== null && _ !== undefined;\n\n// $FlowFixMe\nexport default (queryBuilderOptions: QueryBuilderOptions = {}) => (\n  from: SQL,\n  fromAlias: ?SQL,\n  resolveData: DataForType,\n  options: {\n    withPagination?: boolean,\n    withPaginationAsFields?: boolean,\n    asJson?: boolean,\n    asJsonAggregate?: boolean,\n    addNullCase?: boolean,\n    onlyJsonField?: boolean,\n    useAsterisk?: boolean,\n  },\n  // TODO:v5: context is not optional\n  withBuilder?: ((builder: QueryBuilder) => void) | null | void,\n  context?: GraphQLContext = {}\n) => {\n  const {\n    pgQuery,\n    pgAggregateQuery,\n    pgCursorPrefix: reallyRawCursorPrefix,\n    calculateHasNextPage,\n    calculateHasPreviousPage,\n    usesCursor: explicitlyUsesCursor,\n  } = resolveData;\n\n  const usesCursor: boolean =\n    (explicitlyUsesCursor && explicitlyUsesCursor.length > 0) ||\n    (calculateHasNextPage && calculateHasNextPage.length > 0) ||\n    (calculateHasPreviousPage && calculateHasPreviousPage.length > 0) ||\n    false;\n  const rawCursorPrefix =\n    reallyRawCursorPrefix && reallyRawCursorPrefix.filter(identity);\n\n  // $FlowFixMe\n  const queryBuilder = new QueryBuilder(queryBuilderOptions, context);\n  queryBuilder.from(from, fromAlias ? fromAlias : undefined);\n\n  if (withBuilder) {\n    withBuilder(queryBuilder);\n  }\n  for (const fn of pgQuery || []) {\n    fn(queryBuilder, resolveData);\n  }\n\n  function generateNextPrevPageSql(\n    sqlQueryAlias,\n    canHaveCursorInWhere,\n    queryHasBefore,\n    queryHasFirst,\n    offset = 0,\n    invert = false\n  ) {\n    /*\n     * Strap in, 'coz this function gets hairy!\n     *\n     * The point of this function is to return SQL which will resolve to a\n     * boolean true/false depending on whether or not there is a (invert ?\n     * \"previous\" : \"next\") page.\n     *\n     * Connections have before, after, first, last and offset.\n     * - Users are forbidden from setting both first and last.\n     * - Users are forbidden from setting both offset and last.\n     *\n     * Further there are two main modes of paginating, one works by adding a\n     * where clause (this is preferred, but is not always possible, and is\n     * indicated by `canHaveCursorInWhere === true`) and the other works using\n     * standard LIMIT/OFFSET SQL pagination (and is indicated by\n     * `canHaveCursorInWhere === false`).\n     *\n     * The following diagram shows a full collection of records, #, starting at\n     * START and ending at END. The key after, before, offset, first and last\n     * variables are shown. One thing not show is that it's possible to have\n     * fewer records between before and after than requested by first or last.\n     * Another detail not clearly show is that if there is no `after` then\n     * `START` is used, similarly if there is no `before` then `END` is used.\n     *\n     *   #################################################### < collection\n     *   ^      ^<-offset->^<-first->^      ^<-last->^      ^\n     *   |      |          |         |      |        |      |\n     *   |      |          +---------+      +--------+      |\n     *   |      |          |  DATA1           DATA2  |      |\n     *   |      |          |                         |      |\n     *   |      |          |                         |      |\n     *   |      |          +-------------------------+      |\n     *   |      |                     DATA3          |      |\n     *   |    after                                before   |\n     *   |                                                  |\n     * START                                               END\n     *\n     * We want one of the three DATA blocks:\n     *\n     * - If `first` is set, then we want DATA1.\n     * - If `last` is set then we want DATA2.\n     * - If neither is set then we want DATA3.\n     *\n     * (Remember: you cannot set both `first` and `last` at the same time.)\n     *\n     * When invert === false:\n     *\n     *   Note that both DATA2 and DATA3 end at the same point, and we only care\n     *   if there's data *after* the relevant DATA block, so really we only\n     *   care if the query specified `first` (`queryHasFirst`) which makes\n     *   things complex (ending at the end of DATA1), otherwise we can use\n     *   `before` as the bound (end of DATA2/DATA3).\n     *\n     * When invert === true:\n     *\n     *   Similarly, DATA1 and DATA3 start at the same point, and we're going\n     *   backwards so we only care if there's data *before* the DATA block, so\n     *   really we just need to know if the query set `last` or not, but since\n     *   this is inverted we call it `queryHasFirst`.\n     *\n     * When `invert` is false we're calculating `hasNextPage`, when true we're\n     * calculating `hasPreviousPage`.\n     *\n     * Because of the near-symmetry of requesting hasPreviousPage vs\n     * hasNextPage we always pretend we're determining `hasNextPage`, and we\n     * just invert everything.\n     */\n\n    const sqlCommonUnbounded = sql.fragment`\n      select 1\n      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n      `;\n    /*\n     * This variable is a fragment to go into an `EXISTS(...)` call (after some tweaks).\n     *\n     * The buildWhereClause takes three arguments:\n     *\n     * - includeLowerBound (we want this for hasNextPage but not hasPreviousPage)\n     * - includeUpperBound (we want this for hasPreviousPage but not hasNextPage)\n     * - options (specifically `{addNullCase}`) - we just pass this through.\n     *\n     * So in hasNextPage mode (invert === false), this common SQL ends up\n     * representing the collection from `(after || START)` onwards with no\n     * upper bound. In hasPreviousPage mode (invert === true), it represents\n     * everything from `(before || END)` backwards, with no lower bound.\n     */\n    const sqlCommon = sql.fragment`\n      ${sqlCommonUnbounded}\n      where ${queryBuilder.buildWhereClause(!invert, invert, options)}\n    `;\n\n    /*\n     * Since the offset makes the diagram asymmetric, if offset === 0\n     * then the diagram is symmetric and things are simplified a little.\n     */\n    const isForwardOrSymmetric = !invert || offset === 0;\n\n    if (!isForwardOrSymmetric) {\n      assert(invert);\n      assert(offset > 0);\n      // We're looking for a previous page, and there's an offset, so lets just\n      // assume there's a previous page where offset is smaller.\n      return sql.literal(true);\n    } else if (canHaveCursorInWhere) {\n      assert(isForwardOrSymmetric);\n      if (!queryHasBefore && !queryHasFirst) {\n        assert(isForwardOrSymmetric);\n        // There can be no next page since there's no upper bound\n        return sql.literal(false);\n      } else if (queryHasBefore && !queryHasFirst) {\n        /*\n         * We invert the upper buildWhereBoundClause to only represent the data\n         * after `before`, then check if there's at least one record in that set.\n         *\n         * This only works if the `before` cursor can be represented in the\n         * SQL WHERE clause, otherwise we're doing limit/offset pagination\n         * which requires different logic. It also only works if there's no\n         * `first` clause, otherwise there could be a next page before the\n         * `before` clause.\n         */\n        return sql.fragment`exists(\n          ${sqlCommonUnbounded}\n          where ${queryBuilder.buildWhereClause(false, false, options)}\n          and not (${queryBuilder.buildWhereBoundClause(invert)})\n        )`;\n      } else {\n        assert(queryHasFirst);\n        // queryHasBefore could be true or false.\n        /*\n         * There's a few ways that we could determine if there's a next page.\n         *\n         * If !queryHasBefore, we could COUNT(*) the number of rows in\n         * `sqlCommon` and see if it's larger than `first`:\n         * `(select count(*) > ${first} from (${sqlCommon}) __random_table_alias__)`\n         *\n         * If !queryHasBefore, we could build a subquery table of offsetData\n         * from sqlCommon and see if it contains any rows:\n         * `EXISTS(select 1 from (${sqlCommon} OFFSET ${first}) __random_table_alias__)`.\n         *\n         * We could see if there's at least one row in sqlCommon that's not\n         * already in our chosen result set.\n         *\n         * We've chosen the latter approach here because it doesn't place a limit\n         * on queryHasBefore.\n         */\n        // Drop the `first` limit, see if there are any records that aren't\n        // already in the list we've fetched.\n        return sql.fragment`exists(\n          ${sqlCommon}\n          and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})\n          ${\n            offset === 0 ? sql.blank : sql.fragment`offset ${sql.value(offset)}`\n          }\n        )`;\n      }\n    } else {\n      assert(!invert || offset === 0); // isForwardOrSymmetric\n      assert(!canHaveCursorInWhere);\n      // We're dealing with LIMIT/OFFSET pagination here, which means `natural`\n      // cursors, so the `queryBuilder` factors the before/after, first/last\n      // into the limit / offset.\n      const { limit } = queryBuilder.getFinalLimitAndOffset();\n\n      if (limit == null) {\n        // If paginating backwards, then offset > 0 has already been dealt\n        // with. Unbounded, so there's no next page.\n        return sql.fragment`false`;\n      } else if (invert) {\n        assert(offset === 0);\n        // Paginating backwards and there's no offset (which factors in before/after), so there's no previous page.\n        return sql.fragment`false`;\n      } else {\n        assert(!invert);\n        /*\n         * We're paginating forwards; either there's a before, there's a first,\n         * or both.\n         *\n         * We want to see if there's more than limit+offset records in sqlCommon.\n         */\n        return sql.fragment`exists(\n          ${sqlCommon}\n          offset ${sql.literal(limit + offset)}\n        )`;\n      }\n    }\n  }\n  const getPgCursorPrefix = () =>\n    rawCursorPrefix && rawCursorPrefix.length > 0\n      ? rawCursorPrefix\n      : queryBuilder.data.cursorPrefix.map(val => sql.literal(val));\n  if (\n    options.withPagination ||\n    options.withPaginationAsFields ||\n    options.withCursor\n  ) {\n    // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation\n    if (usesCursor) {\n      queryBuilder.selectCursor(() => {\n        const orderBy = queryBuilder\n          .getOrderByExpressionsAndDirections()\n          .map(([expr]) => expr);\n        if (queryBuilder.isOrderUnique() && orderBy.length > 0) {\n          return sql.fragment`json_build_array(${sql.join(\n            [\n              ...getPgCursorPrefix(),\n              sql.fragment`json_build_array(${sql.join(orderBy, \", \")})`,\n            ],\n            \", \"\n          )})`;\n        } else {\n          return sql.fragment`json_build_array(${sql.join(\n            getPgCursorPrefix(),\n            \", \"\n          )}, (row_number() over (partition by 1)))`;\n        }\n      });\n    }\n  }\n  if (options.withPagination || options.withPaginationAsFields) {\n    queryBuilder.setCursorComparator((cursorValue, isAfter) => {\n      const orderByExpressionsAndDirections = queryBuilder.getOrderByExpressionsAndDirections();\n      if (\n        orderByExpressionsAndDirections.length > 0 &&\n        queryBuilder.isOrderUnique()\n      ) {\n        const sqlCursors = cursorValue[getPgCursorPrefix().length].map(val =>\n          sql.value(val)\n        );\n        if (!Array.isArray(sqlCursors)) {\n          queryBuilder.whereBound(sql.literal(false), isAfter);\n        }\n        let sqlFilter = sql.fragment`false`;\n        for (let i = orderByExpressionsAndDirections.length - 1; i >= 0; i--) {\n          const [sqlExpression, ascending] = orderByExpressionsAndDirections[i];\n          // If ascending and isAfter then >\n          // If ascending and isBefore then <\n          const comparison =\n            Number(ascending) ^ Number(!isAfter)\n              ? sql.fragment`>`\n              : sql.fragment`<`;\n\n          const sqlOldFilter = sqlFilter;\n          sqlFilter = sql.fragment`\n          (\n            (\n              ${sqlExpression} ${comparison} ${sqlCursors[i] || sql.null}\n            )\n          OR\n            (\n              (\n                ${sqlExpression} = ${sqlCursors[i] || sql.null}\n              AND\n                ${sqlOldFilter}\n              )\n            )\n          )\n          `;\n        }\n        queryBuilder.whereBound(sqlFilter, isAfter);\n      } else if (\n        cursorValue[0] === \"natural\" &&\n        isSafeInteger(cursorValue[1]) &&\n        cursorValue[1] >= 0\n      ) {\n        if (isAfter) {\n          queryBuilder.offset(() => cursorValue[1]);\n        } else {\n          queryBuilder.limit(() => {\n            const offset = queryBuilder.getOffset();\n            return Math.max(0, cursorValue[1] - offset - 1);\n          });\n        }\n      } else {\n        throw new Error(\"Cannot use cursors without orderBy\");\n      }\n    });\n\n    const query = queryBuilder.build(options);\n    const haveFields = queryBuilder.getSelectFieldsCount() > 0;\n    const sqlQueryAlias = sql.identifier(Symbol());\n    const sqlSummaryAlias = sql.identifier(Symbol());\n    //\n    // Tables should ALWAYS push their PK onto the order stack, if this isn't\n    // present then we're either dealing with a view or a table without a PK.\n    // Either way, we don't have anything to guarantee uniqueness so we need to\n    // fall back to limit/offset.\n    //\n    // TODO: support unique keys in PgAllRows etc\n    // TODO: add a warning for cursor-based pagination when using the fallback\n    // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey\n    const canHaveCursorInWhere =\n      queryBuilder.getOrderByExpressionsAndDirections().length > 0 &&\n      queryBuilder.isOrderUnique();\n    const queryHasBefore =\n      queryBuilder.compiledData.whereBound.upper.length > 0;\n    const queryHasAfter = queryBuilder.compiledData.whereBound.lower.length > 0;\n    const queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;\n    const queryHasFirst = isSafeInteger(queryBuilder.compiledData.first);\n    const queryHasLast = isSafeInteger(queryBuilder.compiledData.last);\n    const hasNextPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasBefore,\n          queryHasFirst,\n          queryBuilder.getFinalOffset() || 0\n        );\n    const hasPreviousPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasAfter,\n          queryHasLast,\n          queryBuilder.getFinalOffset() || 0,\n          true\n        );\n\n    const sqlWith = haveFields\n      ? sql.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})`\n      : sql.fragment``;\n    const sqlFrom = sql.fragment``;\n    const fields: Array<[SQL, RawAlias]> = [];\n    if (haveFields) {\n      fields.push([\n        sql.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`,\n        \"data\",\n      ]);\n      if (calculateHasNextPage) {\n        fields.push([hasNextPage, \"hasNextPage\"]);\n      }\n      if (calculateHasPreviousPage) {\n        fields.push([hasPreviousPage, \"hasPreviousPage\"]);\n      }\n    }\n    if (pgAggregateQuery && pgAggregateQuery.length) {\n      const aggregateQueryBuilder = new QueryBuilder(\n        queryBuilderOptions,\n        context\n      );\n      aggregateQueryBuilder.from(\n        queryBuilder.getTableExpression(),\n        queryBuilder.getTableAlias()\n      );\n\n      for (const fn of pgAggregateQuery) {\n        fn(aggregateQueryBuilder);\n      }\n      const aggregateJsonBuildObject = aggregateQueryBuilder.build({\n        onlyJsonField: true,\n      });\n      const aggregatesSql = sql.fragment`\n      (\n        select ${aggregateJsonBuildObject}\n        from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n        where ${queryBuilder.buildWhereClause(false, false, options)}\n      )\n      `;\n      fields.push([aggregatesSql, \"aggregates\"]);\n    }\n    if (options.withPaginationAsFields) {\n      return sql.fragment`${sqlWith} select ${sql.join(\n        fields.map(\n          ([expr, alias]) => sql.fragment`${expr} as ${sql.identifier(alias)}`\n        ),\n        \", \"\n      )} ${sqlFrom}`;\n    } else {\n      return sql.fragment`${sqlWith} select ${queryBuilder.jsonbBuildObject(\n        fields\n      )} ${sqlFrom}`;\n    }\n  } else {\n    const query = queryBuilder.build(options);\n    return query;\n  }\n};\n"]}