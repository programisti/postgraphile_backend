{"version":3,"sources":["../src/Live.js"],"names":["makeAsyncIteratorFromMonitor","MONITOR_THROTTLE_DURATION","parseInt","process","env","LIVE_THROTTLE","LiveSource","subscribeCollection","_callback","_collectionIdentifier","_predicate","subscribeRecord","_recordIdentifier","LiveProvider","constructor","namespace","sources","registerSource","source","push","collectionIdentifierIsValid","recordIdentifierIsValid","LiveMonitor","providers","extraRootValue","released","subscriptionReleasersByCounter","changeCallback","changeCounter","liveConditionsByCounter","handleChange","Error","bind","leading","trailing","onChange","resetBefore","currentCounter","oldCounters","Object","keys","filter","n","oldCounter","releaser","release","cancel","Infinity","cb","counter","String","changeRootValue","liveCollection","liveRecord","liveConditions","console","warn","callback","setImmediate","collectionIdentifier","predicate","provider","length","recordIdentifier","LiveCoordinator","subscribe","registerProvider","getMonitor","_parent","_args","_context","_info","monitor","liveAbort","e","iterator","throw","onClose"],"mappings":"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","file":"Live.js","sourcesContent":["// @flow\n/* eslint-disable flowtype/no-weak-types */\nimport callbackToAsyncIterator from \"./callbackToAsyncIterator\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport { throttle } from \"lodash\";\n\ntype SubscriptionReleaser = () => void;\ntype SubscriptionCallback = () => void;\n\ntype Predicate = (record: any) => boolean;\ntype PredicateGenerator = (data: any) => Predicate;\n\nconst MONITOR_THROTTLE_DURATION =\n  parseInt(process.env.LIVE_THROTTLE || \"\", 10) || 500;\n\n/*\n * Sources are long-lived (i.e. in \"watch\" mode you just re-use the same one\n * over and over) because there is no release for them\n */\nexport class LiveSource {\n  subscribeCollection(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _predicate?: Predicate\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n\n  subscribeRecord(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n}\n\n/*\n * Providers enable a namespace, perform validation, and track the sources used\n * by that namespace within one single schema build. The should not directly use\n * any long-lived features as they do not have an explicit \"release\"/\"close\"\n * command when a new schema is built.\n */\nexport class LiveProvider {\n  sources: Array<LiveSource>;\n  namespace: string;\n\n  constructor(namespace: string) {\n    this.namespace = namespace;\n    this.sources = [];\n  }\n\n  registerSource(source: LiveSource) {\n    this.sources.push(source);\n  }\n\n  collectionIdentifierIsValid(_collectionIdentifier: any): boolean {\n    return false;\n  }\n\n  recordIdentifierIsValid(\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): boolean {\n    return false;\n  }\n}\n\n/*\n * During a single execution of GraphQL (specifically a subscription request),\n * the LiveMonitor tracks the resources viewed and subscribes to updates in them.\n */\nexport class LiveMonitor {\n  released: boolean;\n  providers: { [namespace: string]: LiveProvider };\n  subscriptionReleasersByCounter: {\n    [counter: string]: (() => void)[],\n  };\n  liveConditionsByCounter: { [counter: string]: Array<PredicateGenerator> };\n  changeCallback: ((arg: any) => void) | null;\n  changeCounter: number;\n  extraRootValue: any;\n\n  constructor(\n    providers: { [namespace: string]: LiveProvider },\n    extraRootValue: any\n  ) {\n    this.extraRootValue = extraRootValue;\n    this.released = false;\n    this.providers = providers;\n    this.subscriptionReleasersByCounter = {};\n    this.changeCallback = null;\n    this.changeCounter = 0;\n    this.liveConditionsByCounter = {};\n    if (!this.handleChange) {\n      throw new Error(\"This is just to make flow happy\");\n    }\n    this.handleChange = throttle(\n      this.handleChange.bind(this),\n      MONITOR_THROTTLE_DURATION,\n      {\n        leading: true,\n        trailing: true,\n      }\n    );\n    this.onChange = this.onChange.bind(this);\n  }\n\n  resetBefore(currentCounter: number) {\n    // Clear out of date subscriptionReleasers\n    {\n      const oldCounters = Object.keys(\n        this.subscriptionReleasersByCounter\n      ).filter(n => parseInt(n, 10) < currentCounter);\n      for (const oldCounter of oldCounters) {\n        for (const releaser of this.subscriptionReleasersByCounter[\n          oldCounter\n        ]) {\n          releaser();\n        }\n        delete this.subscriptionReleasersByCounter[oldCounter];\n      }\n    }\n    // Clear out of date liveConditions\n    {\n      const oldCounters = Object.keys(this.liveConditionsByCounter).filter(\n        n => parseInt(n, 10) < currentCounter\n      );\n      for (const oldCounter of oldCounters) {\n        delete this.liveConditionsByCounter[oldCounter];\n      }\n    }\n  }\n\n  release() {\n    if (this.handleChange) {\n      this.handleChange.cancel();\n    }\n    this.handleChange = null;\n    this.resetBefore(Infinity);\n    this.providers = {};\n    this.released = true;\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  handleChange: (() => void) | null;\n  handleChange() {\n    // This function is throttled to MONITOR_THROTTLE_DURATION (see constructor)\n    if (this.changeCallback) {\n      // Convince Flow this won't suddenly become null\n      const cb = this.changeCallback;\n      const counter = this.changeCounter++;\n      /*\n       * In live queries we need to know when the current result set has\n       * finished being calculated so that we know we've received all the\n       * liveRecord / liveCollection calls and can release the out of date\n       * ones. To achieve this, we use a custom `subscribe` function which\n       * calls `rootValue.release()` once the result set has been calculated.\n       */\n      this.subscriptionReleasersByCounter[String(counter)] = [];\n      this.liveConditionsByCounter[String(counter)] = [];\n      const changeRootValue = {\n        ...this.extraRootValue,\n        counter,\n        liveCollection: this.liveCollection.bind(this, counter),\n        liveRecord: this.liveRecord.bind(this, counter),\n        liveConditions: this.liveConditionsByCounter[String(counter)],\n        release: () => {\n          // Despite it's name, this means that the execution has complete, which means we're actually releasing everything *before* this.\n          this.resetBefore(counter);\n        },\n      };\n      cb(changeRootValue);\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\"Change occurred, but no-one was listening\");\n    }\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  onChange: (callback: () => void) => void;\n  onChange(callback: () => void) {\n    if (this.released) {\n      throw new Error(\"Monitors cannot be reused.\");\n    }\n    if (this.changeCallback) {\n      throw new Error(\"Already monitoring for changes\");\n    }\n    // Throttle to every 250ms\n    this.changeCallback = callback;\n    if (this.handleChange) {\n      setImmediate(this.handleChange);\n    }\n    return () => {\n      if (this.changeCallback === callback) {\n        this.changeCallback = null;\n      }\n      this.release();\n    };\n  }\n\n  liveCollection(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    predicate: (record: any) => boolean = () => true\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeCollection(\n        handleChange,\n        collectionIdentifier,\n        predicate\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n\n  liveRecord(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    recordIdentifier: any\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    // TODO: if (recordIdentifier == null) {return}\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    if (\n      !provider.recordIdentifierIsValid(collectionIdentifier, recordIdentifier)\n    ) {\n      throw new Error(\n        `Invalid record identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeRecord(\n        handleChange,\n        collectionIdentifier,\n        recordIdentifier\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n}\n\n/*\n * There is one coordinator for each build of the GraphQL schema, it tracks the providers\n * and gives a handy `subscribe` method that can be used for live queries (assuming\n * that the `resolve` is provided the same as in a Query).\n */\nexport class LiveCoordinator {\n  providers: { [namespace: string]: LiveProvider };\n\n  constructor() {\n    this.providers = {};\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  registerProvider(provider: LiveProvider) {\n    const { namespace } = provider;\n    if (this.providers[namespace]) {\n      throw new Error(`Namespace ${namespace} already registered with Live`);\n    }\n    this.providers[namespace] = provider;\n  }\n\n  registerSource(namespace: string, source: LiveSource) {\n    if (!this.providers[namespace]) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `LiveProvider '${namespace}' is not registered, skipping live source.`\n      );\n      return;\n    }\n    this.providers[namespace].registerSource(source);\n  }\n\n  getMonitor(extraRootValue: any) {\n    return new LiveMonitor(this.providers, extraRootValue);\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  subscribe: (\n    _parent: any,\n    _args: any,\n    context: any,\n    _info: GraphQLResolveInfo\n  ) => any;\n  subscribe(\n    _parent: any,\n    _args: any,\n    _context: any,\n    _info: GraphQLResolveInfo\n  ) {\n    const monitor = this.getMonitor({\n      liveAbort: e => {\n        if (iterator) iterator.throw(e);\n      },\n    });\n    const iterator = makeAsyncIteratorFromMonitor(monitor);\n    return iterator;\n  }\n}\n\nexport function makeAsyncIteratorFromMonitor(monitor: LiveMonitor) {\n  return callbackToAsyncIterator(monitor.onChange, {\n    onClose: release => {\n      if (release) release();\n    },\n  });\n}\n"]}