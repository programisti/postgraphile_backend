{"version":3,"sources":["../src/Live.js"],"names":["makeAsyncIteratorFromMonitor","MONITOR_THROTTLE_DURATION","parseInt","process","env","LIVE_THROTTLE","LiveSource","subscribeCollection","_callback","_collectionIdentifier","_predicate","subscribeRecord","_recordIdentifier","LiveProvider","constructor","namespace","sources","registerSource","source","push","collectionIdentifierIsValid","recordIdentifierIsValid","LiveMonitor","providers","released","subscriptionReleasers","changeCallback","liveConditions","handleChange","Error","bind","leading","trailing","onChange","reset","releaser","splice","liveCollection","length","release","cancel","cb","console","warn","callback","setImmediate","collectionIdentifier","predicate","provider","liveRecord","recordIdentifier","LiveCoordinator","subscribe","registerProvider","getMonitorAndContext","monitor","context","_parent","_args","_info","additionalContext","Object","assign","iterator","liveAbort","e","throw","onClose"],"mappings":"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","file":"Live.js","sourcesContent":["// @flow\n/* eslint-disable flowtype/no-weak-types */\nimport callbackToAsyncIterator from \"./callbackToAsyncIterator\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport { throttle } from \"lodash\";\n\ntype SubscriptionReleaser = () => void;\ntype SubscriptionCallback = () => void;\n\ntype Predicate = (record: any) => boolean;\ntype PredicateGenerator = (data: any) => Predicate;\n\nconst MONITOR_THROTTLE_DURATION =\n  parseInt(process.env.LIVE_THROTTLE || \"\", 10) || 500;\n\n/*\n * Sources are long-lived (i.e. in \"watch\" mode you just re-use the same one\n * over and over) because there is no release for them\n */\nexport class LiveSource {\n  subscribeCollection(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _predicate?: Predicate\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n\n  subscribeRecord(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n}\n\n/*\n * Providers enable a namespace, perform validation, and track the sources used\n * by that namespace within one single schema build. The should not directly use\n * any long-lived features as they do not have an explicit \"release\"/\"close\"\n * command when a new schema is built.\n */\nexport class LiveProvider {\n  sources: Array<LiveSource>;\n  namespace: string;\n\n  constructor(namespace: string) {\n    this.namespace = namespace;\n    this.sources = [];\n  }\n\n  registerSource(source: LiveSource) {\n    this.sources.push(source);\n  }\n\n  collectionIdentifierIsValid(_collectionIdentifier: any): boolean {\n    return false;\n  }\n\n  recordIdentifierIsValid(\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): boolean {\n    return false;\n  }\n}\n\n/*\n * During a single execution of GraphQL (specifically a subscription request),\n * the LiveMonitor tracks the resources viewed and subscribes to updates in them.\n */\nexport class LiveMonitor {\n  released: boolean;\n  providers: { [namespace: string]: LiveProvider };\n  subscriptionReleasers: (() => void)[];\n  changeCallback: (() => void) | null;\n  liveConditions: Array<PredicateGenerator>;\n\n  constructor(providers: { [namespace: string]: LiveProvider }) {\n    this.released = false;\n    this.providers = providers;\n    this.subscriptionReleasers = [];\n    this.changeCallback = null;\n    this.liveConditions = [];\n    if (!this.handleChange) {\n      throw new Error(\"This is just to make flow happy\");\n    }\n    this.handleChange = throttle(\n      this.handleChange.bind(this),\n      MONITOR_THROTTLE_DURATION,\n      {\n        leading: true,\n        trailing: true,\n      }\n    );\n    this.onChange = this.onChange.bind(this);\n  }\n\n  reset() {\n    // clear monitoring\n    for (const releaser of this.subscriptionReleasers) {\n      releaser();\n    }\n    this.subscriptionReleasers = [];\n    // Delete everything from liveConditions, we'll be getting fresh conditions soon enough\n    this.liveConditions.splice(0, this.liveCollection.length);\n  }\n\n  release() {\n    if (this.handleChange) {\n      this.handleChange.cancel();\n    }\n    this.handleChange = null;\n    this.reset();\n    this.providers = {};\n    this.released = true;\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  handleChange: (() => void) | null;\n  handleChange() {\n    if (this.changeCallback) {\n      // Convince Flow this won't suddenly become null\n      const cb = this.changeCallback;\n      this.reset();\n      cb();\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\"Change occurred, but no-one was listening\");\n    }\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  onChange: (callback: () => void) => void;\n  onChange(callback: () => void) {\n    if (this.released) {\n      throw new Error(\"Monitors cannot be reused.\");\n    }\n    if (this.changeCallback) {\n      throw new Error(\"Already monitoring for changes\");\n    }\n    // Throttle to every 250ms\n    this.changeCallback = callback;\n    if (this.handleChange) {\n      setImmediate(this.handleChange);\n    }\n    return () => {\n      if (this.changeCallback === callback) {\n        this.changeCallback = null;\n      }\n      this.release();\n    };\n  }\n\n  liveCollection(\n    namespace: string,\n    collectionIdentifier: any,\n    predicate: (record: any) => boolean = () => true\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeCollection(\n        handleChange,\n        collectionIdentifier,\n        predicate\n      );\n      if (releaser) {\n        this.subscriptionReleasers.push(releaser);\n      }\n    }\n  }\n\n  liveRecord(\n    namespace: string,\n    collectionIdentifier: any,\n    recordIdentifier: any\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    // TODO: if (recordIdentifier == null) {return}\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    if (\n      !provider.recordIdentifierIsValid(collectionIdentifier, recordIdentifier)\n    ) {\n      throw new Error(\n        `Invalid record identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeRecord(\n        handleChange,\n        collectionIdentifier,\n        recordIdentifier\n      );\n      if (releaser) {\n        this.subscriptionReleasers.push(releaser);\n      }\n    }\n  }\n}\n\n/*\n * There is one coordinator for each build of the GraphQL schema, it tracks the providers\n * and gives a handy `subscribe` method that can be used for live queries (assuming\n * that the `resolve` is provided the same as in a Query).\n */\nexport class LiveCoordinator {\n  providers: { [namespace: string]: LiveProvider };\n\n  constructor() {\n    this.providers = {};\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  registerProvider(provider: LiveProvider) {\n    const { namespace } = provider;\n    if (this.providers[namespace]) {\n      throw new Error(`Namespace ${namespace} already registered with Live`);\n    }\n    this.providers[namespace] = provider;\n  }\n\n  registerSource(namespace: string, source: LiveSource) {\n    if (!this.providers[namespace]) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `LiveProvider '${namespace}' is not registered, skipping live source.`\n      );\n      return;\n    }\n    this.providers[namespace].registerSource(source);\n  }\n\n  getMonitorAndContext() {\n    const monitor = new LiveMonitor(this.providers);\n    return {\n      monitor,\n      context: {\n        liveCollection: monitor.liveCollection.bind(monitor),\n        liveRecord: monitor.liveRecord.bind(monitor),\n        liveConditions: monitor.liveConditions,\n      },\n    };\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  subscribe: (\n    _parent: any,\n    _args: any,\n    context: any,\n    _info: GraphQLResolveInfo\n  ) => any;\n  subscribe(_parent: any, _args: any, context: any, _info: GraphQLResolveInfo) {\n    const { monitor, context: additionalContext } = this.getMonitorAndContext();\n    Object.assign(context, additionalContext);\n    const iterator = makeAsyncIteratorFromMonitor(monitor);\n    context.liveAbort = e => {\n      iterator.throw(e);\n    };\n    return iterator;\n  }\n}\n\nexport function makeAsyncIteratorFromMonitor(monitor: LiveMonitor) {\n  return callbackToAsyncIterator(monitor.onChange, {\n    onClose: release => {\n      if (release) release();\n    },\n  });\n}\n"]}