{"version":3,"sources":["../src/callbackToAsyncIterator.js"],"names":["callbackToAsyncIterator","defaultOnError","err","Error","listener","options","onError","buffering","onClose","pullQueue","pushQueue","listening","listenerReturnValue","pushValue","value","length","shift","done","push","pullValue","Promise","resolve","emptyQueue","forEach","undefined","then","a","catch","next","return","throw","error","reject","$$asyncIterator"],"mappings":";;;;;kBAYwBA,uB;;AANxB;;AAEA,MAAMC,iBAAkBC,GAAD,IAAgB;AACrC,QAAM,IAAIC,KAAJ,CAAUD,GAAV,CAAN;AACD,CAFD;AAPA;AACA;AACA;AACA;AACA;AAOe,SAASF,uBAAT,CAIbI,QAJa,EAKbC,UAII,EATS,EAUb;AACA,QAAM,EAAEC,UAAUL,cAAZ,EAA4BM,YAAY,IAAxC,EAA8CC,OAA9C,KAA0DH,OAAhE;AACA,MAAII,YAAY,EAAhB;AACA,MAAIC,YAAY,EAAhB;AACA,MAAIC,YAAY,IAAhB;AACA,MAAIC,mBAAJ;;AAEA,WAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,QAAIL,UAAUM,MAAV,KAAqB,CAAzB,EAA4B;AAC1BN,gBAAUO,KAAV,GAAkB,EAAEF,KAAF,EAASG,MAAM,KAAf,EAAlB;AACD,KAFD,MAEO,IAAIV,cAAc,IAAlB,EAAwB;AAC7BG,gBAAUQ,IAAV,CAAeJ,KAAf;AACD;AACF;;AAED,WAASK,SAAT,GAAqB;AACnB,WAAO,IAAIC,OAAJ,CAAYC,WAAW;AAC5B,UAAIX,UAAUK,MAAV,KAAqB,CAAzB,EAA4B;AAC1BM,gBAAQ,EAAEP,OAAOJ,UAAUM,KAAV,EAAT,EAA4BC,MAAM,KAAlC,EAAR;AACD,OAFD,MAEO;AACLR,kBAAUS,IAAV,CAAeG,OAAf;AACD;AACF,KANM,CAAP;AAOD;;AAED,WAASC,UAAT,GAAsB;AACpB,QAAIX,SAAJ,EAAe;AACbA,kBAAY,KAAZ;AACAF,gBAAUc,OAAV,CAAkBF,WAAWA,QAAQ,EAAEP,OAAOU,SAAT,EAAoBP,MAAM,IAA1B,EAAR,CAA7B;AACAR,kBAAY,EAAZ;AACAC,kBAAY,EAAZ;AACAF,iBAAWA,QAAQI,mBAAR,CAAX;AACD;AACF;;AAED,MAAI;AACF;AACAQ,YAAQC,OAAR,CAAgBjB,SAASU,SAASD,UAAUC,KAAV,CAAlB,CAAhB,EACGW,IADH,CACQC,KAAK;AACTd,4BAAsBc,CAAtB;AACD,KAHH,EAIGC,KAJH,CAISzB,OAAO;AACZI,cAAQJ,GAAR;AACD,KANH;;AAQA,WAAO;AACL0B,aAA0D;AACxD,eAAOjB,YAAYQ,WAAZ,GAA0B,KAAKU,MAAL,EAAjC;AACD,OAHI;AAILA,eAA8D;AAC5DP;AACA,eAAOF,QAAQC,OAAR,CAAgB,EAAEP,OAAOU,SAAT,EAAoBP,MAAM,IAA1B,EAAhB,CAAP;AACD,OAPI;AAQLa,YAAMC,KAAN,EAAa;AACXT;AACAhB,gBAAQyB,KAAR;AACA,eAAOX,QAAQY,MAAR,CAAeD,KAAf,CAAP;AACD,OAZI;AAaL,OAACE,wBAAD,IAAoB;AAClB,eAAO,IAAP;AACD;AAfI,KAAP;AAiBD,GA3BD,CA2BE,OAAO/B,GAAP,EAAY;AACZI,YAAQJ,GAAR;AACA,WAAO;AACL0B,aAAO;AACL,eAAOR,QAAQY,MAAR,CAAe9B,GAAf,CAAP;AACD,OAHI;AAIL2B,eAAS;AACP,eAAOT,QAAQY,MAAR,CAAe9B,GAAf,CAAP;AACD,OANI;AAOL4B,YAAMC,KAAN,EAAa;AACX,eAAOX,QAAQY,MAAR,CAAeD,KAAf,CAAP;AACD,OATI;AAUL,OAACE,wBAAD,IAAoB;AAClB,eAAO,IAAP;AACD;AAZI,KAAP;AAcD;AACF","file":"callbackToAsyncIterator.js","sourcesContent":["// @flow\n/* eslint-disable flowtype/no-weak-types */\n// Turn a callback-based listener into an async iterator\n// From https://raw.githubusercontent.com/withspectrum/callback-to-async-iterator/master/src/index.js\n// License MIT (Copyright (c) 2017 Maximilian Stoiber)\n// Based on https://github.com/apollographql/graphql-subscriptions/blob/master/src/event-emitter-to-async-iterator.ts\nimport { $$asyncIterator } from \"iterall\";\n\nconst defaultOnError = (err: Error) => {\n  throw new Error(err);\n};\n\nexport default function callbackToAsyncIterator<\n  CallbackInput: any,\n  ReturnVal: any\n>(\n  listener: ((arg: CallbackInput) => any) => ?ReturnVal | Promise<?ReturnVal>,\n  options?: {\n    onError?: (err: Error) => void,\n    onClose?: (arg?: ?ReturnVal) => void,\n    buffering?: boolean,\n  } = {}\n) {\n  const { onError = defaultOnError, buffering = true, onClose } = options;\n  let pullQueue = [];\n  let pushQueue = [];\n  let listening = true;\n  let listenerReturnValue;\n\n  function pushValue(value) {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value, done: false });\n    } else if (buffering === true) {\n      pushQueue.push(value);\n    }\n  }\n\n  function pullValue() {\n    return new Promise(resolve => {\n      if (pushQueue.length !== 0) {\n        resolve({ value: pushQueue.shift(), done: false });\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n  }\n\n  function emptyQueue() {\n    if (listening) {\n      listening = false;\n      pullQueue.forEach(resolve => resolve({ value: undefined, done: true }));\n      pullQueue = [];\n      pushQueue = [];\n      onClose && onClose(listenerReturnValue);\n    }\n  }\n\n  try {\n    // Start listener\n    Promise.resolve(listener(value => pushValue(value)))\n      .then(a => {\n        listenerReturnValue = a;\n      })\n      .catch(err => {\n        onError(err);\n      });\n\n    return {\n      next(): Promise<{ value?: CallbackInput, done: boolean }> {\n        return listening ? pullValue() : this.return();\n      },\n      return(): Promise<{ value: typeof undefined, done: boolean }> {\n        emptyQueue();\n        return Promise.resolve({ value: undefined, done: true });\n      },\n      throw(error) {\n        emptyQueue();\n        onError(error);\n        return Promise.reject(error);\n      },\n      [$$asyncIterator]() {\n        return this;\n      },\n    };\n  } catch (err) {\n    onError(err);\n    return {\n      next() {\n        return Promise.reject(err);\n      },\n      return() {\n        return Promise.reject(err);\n      },\n      throw(error) {\n        return Promise.reject(error);\n      },\n      [$$asyncIterator]() {\n        return this;\n      },\n    };\n  }\n}\n"]}