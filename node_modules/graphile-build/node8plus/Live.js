"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LiveCoordinator = exports.LiveMonitor = exports.LiveProvider = exports.LiveSource = undefined;
exports.makeAsyncIteratorFromMonitor = makeAsyncIteratorFromMonitor;

var _callbackToAsyncIterator = require("./callbackToAsyncIterator");

var _callbackToAsyncIterator2 = _interopRequireDefault(_callbackToAsyncIterator);

var _lodash = require("lodash");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable flowtype/no-weak-types */
const MONITOR_THROTTLE_DURATION = parseInt(process.env.LIVE_THROTTLE || "", 10) || 500;

/*
 * Sources are long-lived (i.e. in "watch" mode you just re-use the same one
 * over and over) because there is no release for them
 */
class LiveSource {
  subscribeCollection(_callback, _collectionIdentifier, _predicate) {
    return null;
  }

  subscribeRecord(_callback, _collectionIdentifier, _recordIdentifier) {
    return null;
  }
}

exports.LiveSource = LiveSource; /*
                                  * Providers enable a namespace, perform validation, and track the sources used
                                  * by that namespace within one single schema build. The should not directly use
                                  * any long-lived features as they do not have an explicit "release"/"close"
                                  * command when a new schema is built.
                                  */

class LiveProvider {

  constructor(namespace) {
    this.namespace = namespace;
    this.sources = [];
  }

  registerSource(source) {
    this.sources.push(source);
  }

  collectionIdentifierIsValid(_collectionIdentifier) {
    return false;
  }

  recordIdentifierIsValid(_collectionIdentifier, _recordIdentifier) {
    return false;
  }
}

exports.LiveProvider = LiveProvider; /*
                                      * During a single execution of GraphQL (specifically a subscription request),
                                      * the LiveMonitor tracks the resources viewed and subscribes to updates in them.
                                      */

class LiveMonitor {

  constructor(providers) {
    this.released = false;
    this.providers = providers;
    this.subscriptionReleasers = [];
    this.changeCallback = null;
    this.liveConditions = [];
    if (!this.handleChange) {
      throw new Error("This is just to make flow happy");
    }
    this.handleChange = (0, _lodash.throttle)(this.handleChange.bind(this), MONITOR_THROTTLE_DURATION, {
      leading: true,
      trailing: true
    });
    this.onChange = this.onChange.bind(this);
  }

  reset() {
    // clear monitoring
    for (const releaser of this.subscriptionReleasers) {
      releaser();
    }
    this.subscriptionReleasers = [];
    // Delete everything from liveConditions, we'll be getting fresh conditions soon enough
    this.liveConditions.splice(0, this.liveCollection.length);
  }

  release() {
    if (this.handleChange) {
      this.handleChange.cancel();
    }
    this.handleChange = null;
    this.reset();
    this.providers = {};
    this.released = true;
  }

  // Tell Flow that we're okay with overwriting this

  handleChange() {
    if (this.changeCallback) {
      // Convince Flow this won't suddenly become null
      const cb = this.changeCallback;
      this.reset();
      cb();
    } else {
      // eslint-disable-next-line no-console
      console.warn("Change occurred, but no-one was listening");
    }
  }

  // Tell Flow that we're okay with overwriting this

  onChange(callback) {
    if (this.released) {
      throw new Error("Monitors cannot be reused.");
    }
    if (this.changeCallback) {
      throw new Error("Already monitoring for changes");
    }
    // Throttle to every 250ms
    this.changeCallback = callback;
    if (this.handleChange) {
      setImmediate(this.handleChange);
    }
    return () => {
      if (this.changeCallback === callback) {
        this.changeCallback = null;
      }
      this.release();
    };
  }

  liveCollection(namespace, collectionIdentifier, predicate = () => true) {
    const handleChange = this.handleChange;
    if (this.released || !handleChange) {
      return;
    }
    const provider = this.providers[namespace];
    if (!provider || provider.sources.length === 0) return;
    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {
      throw new Error(`Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`);
    }
    for (const source of provider.sources) {
      const releaser = source.subscribeCollection(handleChange, collectionIdentifier, predicate);
      if (releaser) {
        this.subscriptionReleasers.push(releaser);
      }
    }
  }

  liveRecord(namespace, collectionIdentifier, recordIdentifier) {
    const handleChange = this.handleChange;
    if (this.released || !handleChange) {
      return;
    }
    // TODO: if (recordIdentifier == null) {return}
    const provider = this.providers[namespace];
    if (!provider || provider.sources.length === 0) return;
    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {
      throw new Error(`Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`);
    }
    if (!provider.recordIdentifierIsValid(collectionIdentifier, recordIdentifier)) {
      throw new Error(`Invalid record identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`);
    }
    for (const source of provider.sources) {
      const releaser = source.subscribeRecord(handleChange, collectionIdentifier, recordIdentifier);
      if (releaser) {
        this.subscriptionReleasers.push(releaser);
      }
    }
  }
}

exports.LiveMonitor = LiveMonitor; /*
                                    * There is one coordinator for each build of the GraphQL schema, it tracks the providers
                                    * and gives a handy `subscribe` method that can be used for live queries (assuming
                                    * that the `resolve` is provided the same as in a Query).
                                    */

class LiveCoordinator {

  constructor() {
    this.providers = {};
    this.subscribe = this.subscribe.bind(this);
  }

  registerProvider(provider) {
    const { namespace } = provider;
    if (this.providers[namespace]) {
      throw new Error(`Namespace ${namespace} already registered with Live`);
    }
    this.providers[namespace] = provider;
  }

  registerSource(namespace, source) {
    if (!this.providers[namespace]) {
      // eslint-disable-next-line no-console
      console.warn(`LiveProvider '${namespace}' is not registered, skipping live source.`);
      return;
    }
    this.providers[namespace].registerSource(source);
  }

  getMonitorAndContext() {
    const monitor = new LiveMonitor(this.providers);
    return {
      monitor,
      context: {
        liveCollection: monitor.liveCollection.bind(monitor),
        liveRecord: monitor.liveRecord.bind(monitor),
        liveConditions: monitor.liveConditions
      }
    };
  }

  // Tell Flow that we're okay with overwriting this

  subscribe(_parent, _args, context, _info) {
    const { monitor, context: additionalContext } = this.getMonitorAndContext();
    Object.assign(context, additionalContext);
    const iterator = makeAsyncIteratorFromMonitor(monitor);
    context.liveAbort = e => {
      iterator.throw(e);
    };
    return iterator;
  }
}

exports.LiveCoordinator = LiveCoordinator;
function makeAsyncIteratorFromMonitor(monitor) {
  return (0, _callbackToAsyncIterator2.default)(monitor.onChange, {
    onClose: release => {
      if (release) release();
    }
  });
}
//# sourceMappingURL=Live.js.map