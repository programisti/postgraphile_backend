"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const events_1 = require("events");
const postgraphile_core_1 = require("postgraphile-core");
const createPostGraphileHttpRequestHandler_1 = require("./http/createPostGraphileHttpRequestHandler");
const exportPostGraphileSchema_1 = require("./schema/exportPostGraphileSchema");
const pluginHook_1 = require("./pluginHook");
const chalk = require("chalk");
// tslint:disable-next-line no-any
function isPlainObject(obj) {
    if (!obj || typeof obj !== 'object' || String(obj) !== '[object Object]')
        return false;
    const proto = Object.getPrototypeOf(obj);
    if (proto === null || proto === Object.prototype) {
        return true;
    }
    return false;
}
/**
 * Creates a PostGraphile Http request handler by first introspecting the
 * database to get a GraphQL schema, and then using that to create the Http
 * request handler.
 */
function getPostgraphileSchemaBuilder(pgPool, schema, incomingOptions) {
    if (incomingOptions.live && incomingOptions.subscriptions == null) {
        // live implies subscriptions
        incomingOptions.subscriptions = true;
    }
    const pluginHook = pluginHook_1.pluginHookFromOptions(incomingOptions);
    const options = pluginHook('postgraphile:options', incomingOptions, {
        pgPool,
        schema,
    });
    // Check for a jwtSecret without a jwtPgTypeIdentifier
    // a secret without a token identifier prevents JWT creation
    if (options.jwtSecret && !options.jwtPgTypeIdentifier) {
        // tslint:disable-next-line no-console
        console.warn('WARNING: jwtSecret provided, however jwtPgTypeIdentifier (token identifier) not provided.');
    }
    if (options.handleErrors && (options.extendedErrors || options.showErrorStack)) {
        throw new Error(`You cannot combine 'handleErrors' with the other error options`);
    }
    // Creates the Postgres schemas array.
    const pgSchemas = Array.isArray(schema) ? schema : [schema];
    const _emitter = options._emitter || new events_1.EventEmitter();
    // Creates a promise which will resolve to a GraphQL schema. Connects a
    // client from our pool to introspect the database.
    //
    // This is not a constant because when we are in watch mode, we want to swap
    // out the `gqlSchema`.
    let gqlSchema;
    const gqlSchemaPromise = createGqlSchema();
    return {
        _emitter,
        getGraphQLSchema: () => Promise.resolve(gqlSchema || gqlSchemaPromise),
        options,
    };
    async function createGqlSchema() {
        try {
            if (options.watchPg) {
                await postgraphile_core_1.watchPostGraphileSchema(pgPool, pgSchemas, options, newSchema => {
                    gqlSchema = newSchema;
                    _emitter.emit('schemas:changed');
                    exportGqlSchema(gqlSchema);
                });
                if (!gqlSchema) {
                    throw new Error("Consistency error: watchPostGraphileSchema promises to call the callback before the promise resolves; but this hasn't happened");
                }
            }
            else {
                gqlSchema = await postgraphile_core_1.createPostGraphileSchema(pgPool, pgSchemas, options);
                exportGqlSchema(gqlSchema);
            }
            return gqlSchema;
        }
        catch (error) {
            // If we fail to build our schema, log the error and exit the process.
            return handleFatalError(error, 'building the initial schema');
        }
    }
    async function exportGqlSchema(newGqlSchema) {
        try {
            await exportPostGraphileSchema_1.default(newGqlSchema, options);
        }
        catch (error) {
            // If we fail to export our schema, log the error and exit the process.
            handleFatalError(error, 'exporting the schema');
        }
    }
}
exports.getPostgraphileSchemaBuilder = getPostgraphileSchemaBuilder;
function postgraphile(poolOrConfig, schemaOrOptions, maybeOptions) {
    let schema;
    // These are the raw options we're passed in; getPostgraphileSchemaBuilder
    // must process them with `pluginHook` before we can rely on them.
    let incomingOptions;
    // If the second argument is a string or array, it is the schemas so set the
    // `schema` value and try to use the third argument (or a default) for
    // `incomingOptions`.
    if (typeof schemaOrOptions === 'string' || Array.isArray(schemaOrOptions)) {
        schema = schemaOrOptions;
        incomingOptions = maybeOptions || {};
    }
    // If the second argument is null or an object then use default `schema`
    // and set incomingOptions to second or third argument (or default).
    else if (typeof schemaOrOptions === 'object') {
        schema = 'public';
        incomingOptions = schemaOrOptions || maybeOptions || {};
    }
    // Otherwise if the second argument is present it's invalid: throw an error.
    else if (arguments.length > 1) {
        throw new Error('The second argument to postgraphile was invalid... did you mean to set a schema?');
    }
    // No schema or options specified, use defaults.
    else {
        schema = 'public';
        incomingOptions = {};
    }
    if (typeof poolOrConfig === 'undefined' && arguments.length >= 1) {
        throw new Error('The first argument to postgraphile was `undefined`... did you mean to set pool options?');
    }
    // Do some things with `poolOrConfig` so that in the end, we actually get a
    // Postgres pool.
    const pgPool = toPgPool(poolOrConfig);
    pgPool.on('error', err => {
        /*
         * This handler is required so that client connection errors don't bring
         * the server down (via `unhandledError`).
         *
         * `pg` will automatically terminate the client and remove it from the
         * pool, so we don't actually need to take any action here, just ensure
         * that the event listener is registered.
         */
        // tslint:disable-next-line no-console
        console.error('PostgreSQL client generated error: ', err.message);
    });
    const { getGraphQLSchema, options, _emitter } = getPostgraphileSchemaBuilder(pgPool, schema, incomingOptions);
    return createPostGraphileHttpRequestHandler_1.default(Object.assign({}, (typeof poolOrConfig === 'string' ? { ownerConnectionString: poolOrConfig } : {}), options, { getGqlSchema: getGraphQLSchema, pgPool,
        _emitter }));
}
exports.default = postgraphile;
function handleFatalError(error, when) {
    process.stderr.write(`A fatal error occurred when ${chalk.bold(when)}, so the process will now exit. Error details:\n\n`);
    process.stderr.write(`${error.stack}\n`); // console.error fails under the tests
    process.exit(1);
    // `process.exit` will mean all code below it will never get called.
    // However, we need to return a value with type `never` here for
    // TypeScript.
    return null;
}
function hasPoolConstructor(obj) {
    return (
    // tslint:disable-next-line no-any
    (obj && typeof obj.constructor === 'function' && obj.constructor === pg_1.Pool.super_) ||
        false);
}
function constructorName(obj) {
    return ((obj &&
        typeof obj.constructor === 'function' &&
        obj.constructor.name &&
        String(obj.constructor.name)) ||
        null);
}
// tslint:disable-next-line no-any
function toPgPool(poolOrConfig) {
    if (quacksLikePgPool(poolOrConfig)) {
        // If it is already a `Pool`, just use it.
        return poolOrConfig;
    }
    if (typeof poolOrConfig === 'string') {
        // If it is a string, let us parse it to get a config to create a `Pool`.
        return new pg_1.Pool({ connectionString: poolOrConfig });
    }
    else if (!poolOrConfig) {
        // Use an empty config and let the defaults take over.
        return new pg_1.Pool({});
    }
    else if (isPlainObject(poolOrConfig)) {
        // The user handed over a configuration object, pass it through
        return new pg_1.Pool(poolOrConfig);
    }
    else {
        throw new Error('Invalid connection string / Pool ');
    }
}
// tslint:disable-next-line no-any
function quacksLikePgPool(pgConfig) {
    if (pgConfig instanceof pg_1.Pool)
        return true;
    if (hasPoolConstructor(pgConfig))
        return true;
    // A diagnosis of exclusion
    if (!pgConfig || typeof pgConfig !== 'object')
        return false;
    if (constructorName(pgConfig) !== 'Pool' && constructorName(pgConfig) !== 'BoundPool')
        return false;
    if (!pgConfig['Client'])
        return false;
    if (!pgConfig['options'])
        return false;
    if (typeof pgConfig['connect'] !== 'function')
        return false;
    if (typeof pgConfig['end'] !== 'function')
        return false;
    if (typeof pgConfig['query'] !== 'function')
        return false;
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zdGdyYXBoaWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Bvc3RncmFwaGlsZS9wb3N0Z3JhcGhpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFBc0M7QUFFdEMsbUNBQXNDO0FBQ3RDLHlEQUFzRjtBQUN0RixzR0FBK0Y7QUFDL0YsZ0ZBQXlFO0FBQ3pFLDZDQUFxRDtBQUVyRCwrQkFBZ0M7QUFFaEMsa0NBQWtDO0FBQ2xDLHVCQUF1QixHQUFRO0lBQzdCLElBQUksQ0FBQyxHQUFHLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxpQkFBaUI7UUFBRSxPQUFPLEtBQUssQ0FBQztJQUN2RixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pDLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssTUFBTSxDQUFDLFNBQVMsRUFBRTtRQUNoRCxPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBUUQ7Ozs7R0FJRztBQUNILHNDQUNFLE1BQVksRUFDWixNQUE4QixFQUM5QixlQUFvQztJQUVwQyxJQUFJLGVBQWUsQ0FBQyxJQUFJLElBQUksZUFBZSxDQUFDLGFBQWEsSUFBSSxJQUFJLEVBQUU7UUFDakUsNkJBQTZCO1FBQzdCLGVBQWUsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0tBQ3RDO0lBQ0QsTUFBTSxVQUFVLEdBQUcsa0NBQXFCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDMUQsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLHNCQUFzQixFQUFFLGVBQWUsRUFBRTtRQUNsRSxNQUFNO1FBQ04sTUFBTTtLQUNQLENBQUMsQ0FBQztJQUNILHNEQUFzRDtJQUN0RCw0REFBNEQ7SUFDNUQsSUFBSSxPQUFPLENBQUMsU0FBUyxJQUFJLENBQUMsT0FBTyxD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